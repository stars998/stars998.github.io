<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="勾魂大猩猩">
    <meta name="description" content="

编译型和解释型的概述？
编译型：整体翻译，将源文件编译成字节码文件。

优点：阅读效率高；
缺点：需要等待；

翻译型：逐行翻译，将字节码文件转换成对应平台的机器语言。

优点：无需等待，直接阅读；
缺点：阅读效率低；

C++属于“编">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>勾魂大猩猩</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

	
<meta name="generator" content="Hexo 6.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">勾魂大猩猩</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">勾魂大猩猩</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/stars998/stars998.github.io" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>click me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/stars998/stars998.github.io" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="click me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title"></h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2022-08-19
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <ol>
<li><ul>
<li><p>编译型和解释型的概述？</p>
<p><strong>编译型</strong>：整体翻译，将源文件编译成字节码文件。</p>
<ul>
<li>优点：阅读效率高；</li>
<li>缺点：需要等待；</li>
</ul>
<p><strong>翻译型</strong>：逐行翻译，将字节码文件转换成对应平台的机器语言。</p>
<ul>
<li>优点：无需等待，直接阅读；</li>
<li>缺点：阅读效率低；</li>
</ul>
<p>C++属于“编译型”语言，JavaScript属于“解释型”语言，Java属于“编译型+解释型”语言【<strong>一次编译，到处运行</strong>】。</p>
<hr>
<h4 id="跨平台需要满足的条件？"><a href="#跨平台需要满足的条件？" class="headerlink" title="跨平台需要满足的条件？"></a>跨平台需要满足的条件？</h4><ol>
<li>各平台只识别机器语言；</li>
<li>各平台的机器指令不同；</li>
</ol>
<hr>
<p><strong>注意</strong>：源文件编译之后，如果得到的“二进制文件”<strong>能直接在平台上运行</strong>，则我们就称之为“<strong>机器码</strong>”；</p>
<p> 源文件编译之后，如果得到的“二进制文件”<strong>不能直接在平台上运行</strong>，则我们就称之为“<strong>字节码</strong>”。</p>
<hr>
<h4 id="常见的DOS命令？"><a href="#常见的DOS命令？" class="headerlink" title="常见的DOS命令？"></a>常见的DOS命令？</h4><ol>
<li><p>切换盘符：</p>
<ul>
<li>D: 或 d:</li>
</ul>
</li>
<li><p>切换目录：</p>
<ul>
<li>cd 文件夹名 –&gt; 进入某个目录</li>
<li>cd 路径 –&gt; 进入某个目录</li>
</ul>
<p>eg: cd D:\course\01_JavaSE\document 或 cd course\01_JavaSE\document</p>
<p><strong>注意</strong>：通过”cd”命令来切换目录的时候，切记不要跨盘符切换。</p>
<p>cd .. –&gt; 返回上一级目录</p>
<p><strong>注意</strong>：此处”..”指的就是“上一级目录”。</p>
<p>cd &#x2F; 或 cd \ –&gt; 返回根目录</p>
</li>
<li><p>查看目录中的所有内容</p>
<ul>
<li>dir –&gt; 查看当前目录中的所有文件和文件夹</li>
</ul>
<p>注意：此处的”.” 代表的是当前所在目录，”..”代表的是上一级目录</p>
</li>
<li><p>常见的辅助命令</p>
<p>cls –&gt; 清屏操作</p>
<p>键盘上下键 –&gt; 查看上一条或下一条已经执行过的命令</p>
<p>tab键 –&gt; 文件名或文件夹名自动补全</p>
<p>exit –&gt; 关闭DOS命令窗口(退出)</p>
</li>
<li><p>操作文件夹的命令</p>
<ul>
<li>md –&gt; 新建文件夹</li>
<li>rd –&gt; 删除文件夹</li>
</ul>
</li>
<li><p>操作文件的命令</p>
<ul>
<li>文件名或程序名</li>
<li>copy 要复制文件的路径 目的路径</li>
<li>del 文件名 –&gt; 删除文件</li>
</ul>
</li>
<li><p>常见的辅助命令</p>
<ul>
<li>help –&gt; 帮助命令（显示常见的DOS命令及其作用）</li>
</ul>
<p>注意：DOS命令不区分大小写，但是文件名或文件夹名需要区分大小写！</p>
<ul>
<li>ipconfig –&gt; 查看当前电脑的ip地址</li>
</ul>
</li>
</ol>
<hr>
<h3 id="DAY02"><a href="#DAY02" class="headerlink" title="DAY02"></a>DAY02</h3><h4 id="PATH环境变量配置"><a href="#PATH环境变量配置" class="headerlink" title="PATH环境变量配置"></a>PATH环境变量配置</h4><hr>
<h4 id="第一个程序的步骤："><a href="#第一个程序的步骤：" class="headerlink" title="第一个程序的步骤："></a>第一个程序的步骤：</h4><ol>
<li>编辑阶段<ul>
<li>新建一个Java源文件，然后在源文件中编辑代码。</li>
</ul>
</li>
<li>编译阶段<ul>
<li>把源文件编译为字节码文件，从而解决各平台只识别机器语言的问题。</li>
<li>实现：在源文件所在的目录中，我们使用javac.exe来实现编译操作，例如：javac HelloWorld.java</li>
</ul>
</li>
<li>执行阶段<ul>
<li>把字节码文件在虚拟机中解释执行，从而解决了各平台机器指令不一样的问题。</li>
<li>实现：在字节码文件所在的目录中，我们使用java.exe来实现解释执行的操作，例如：java HelloWorld</li>
</ul>
</li>
</ol>
<hr>
<h4 id="如何取消隐藏已知文件类型的后缀？"><a href="#如何取消隐藏已知文件类型的后缀？" class="headerlink" title="如何取消隐藏已知文件类型的后缀？"></a>如何取消隐藏已知文件类型的后缀？</h4><ul>
<li>方式一：在文件所在目录中，我们选中“查看”，然后再勾选“文件扩展名”；</li>
<li>方式二：打开控制面板，选中“外观和个性化”，–&gt;“文件资源管理器选项”，–&gt;“查看”,最后取消勾选“隐藏已知文件类型的扩展名”。</li>
</ul>
<hr>
<h4 id="处理使用Notepad-出现的乱码问题？"><a href="#处理使用Notepad-出现的乱码问题？" class="headerlink" title="处理使用Notepad++出现的乱码问题？"></a>处理使用Notepad++出现的乱码问题？</h4><p>原因：DOS命令采用的是ANSI编吗，而Notepad++采用的是UTF-8编码，则编码和编码采用的《编码表》不一致，那么就会出现乱码问题。</p>
<p>解决：把Notepad++的编码设置为ANSI编码表即可。</p>
<p>需求：新建一个源文件，然后通过Notepad++打开该源文件，要求打开的源文件默认就是ANSI编码，如何实现？</p>
<p>实现：在导航栏位置选中“设置”，然后选中“首选项”，–&gt;“新建”，然后设置编码为“ANSI”并设置默认语言为“java”,最后点击“关闭”按钮。</p>
<p>经典错误：“错误：编码GBK的不可映射字符” –&gt; 编码问题，编码和解码没有使用同一个编码表。</p>
<hr>
<h4 id="编辑阶段的整体注意点"><a href="#编辑阶段的整体注意点" class="headerlink" title="编辑阶段的整体注意点"></a>编辑阶段的整体注意点</h4><ul>
<li><p>见名知意、注意缩进、成对编程；</p>
</li>
<li><p>严格区分大小写，英文大写字母与小写字母意义不一样；</p>
</li>
<li><p>都是英文标点符号；</p>
<p>–&gt; 经典错误：”非法字符”：’\uff09’ –&gt; 使用了中文的标点符号；</p>
</li>
<li><p>main方法写法固定，是程序的入口，能被虚拟机识别并执行。</p>
</li>
</ul>
<hr>
<h4 id="关于定义类的注意点？"><a href="#关于定义类的注意点？" class="headerlink" title="关于定义类的注意点？"></a>关于定义类的注意点？</h4><ul>
<li><p>使用public修饰的类，该类的名字必须和源文件名字保持一致，否则就会编译错误；</p>
</li>
<li><p>在源文件中，我们可以使用class来定义任意多个类，编译后就会生成任意多个字节码文件。</p>
<p>–&gt; 编译后，没有类都会生成一个字节码文件，并且字节码文件名字就是类名。</p>
</li>
<li><p>在源文件中，我们可以定义多个类，但是最多只能有一个类使用public修饰（0或1）。</p>
</li>
</ul>
<hr>
<h4 id="DOS下编译解释【了解】"><a href="#DOS下编译解释【了解】" class="headerlink" title="DOS下编译解释【了解】"></a>DOS下编译解释【了解】</h4><p>问题：想要在任意目录中，去编译指定目录中的源文件，如何实现？</p>
<p>解决：java D:\course\JavaProjects\01_JavaSE\day02\HelloWorld03.java</p>
<p>问题：想要在任意目录中，去解释执行指定目录中的字节码文件，如何实现？？</p>
<p>分析：java D:\course\JavaProjects\01_JavaSE\day02\Helloworld03 –&gt; 错误演示</p>
<p>解决：配置classpath环境变量来实现【了解】–&gt;为理解idea源文件与字节码文件分离做铺垫</p>
<p>问题：配置了classpath环境变量的作用？</p>
<p>答：一旦配置classpath环境变量，则做解释执行操作的时候，就不会在当前所在目录中找字节码文件，而是直接去classpath路径中找字节码文件。</p>
<p>需求：做解释执行操作时，如果当前位置有该字节码文件，则就执行当前目录中的字节码文件，</p>
<p> 如果当前目录中没有该字节码文件，则才去执行指定目录中的字节码文件，如何实现？</p>
<p>解决：设置classpath环境变量的值为”.;D:\course\JavaProjects\01_JavaSE\day02”即可。</p>
<hr>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>作用：解释说明代码</p>
<p><strong>分类：</strong></p>
<ol>
<li>单行注释<ul>
<li>快捷键：ctrl + &#x2F;</li>
<li>语法：&#x2F;&#x2F;</li>
</ul>
</li>
<li>多行注释<ul>
<li>快捷键：ctrl + shift + &#x2F;</li>
<li>语法：&#x2F;* 注释内容 *&#x2F;</li>
</ul>
</li>
<li>文档注释<ul>
<li>语法：&#x2F;** 注释内容 *&#x2F;</li>
</ul>
</li>
</ol>
<hr>
<h4 id="常见的转义字符"><a href="#常见的转义字符" class="headerlink" title="常见的转义字符"></a>常见的转义字符</h4><ul>
<li>\t –&gt; 制表符。作用：显示多个空格，并且还有对齐的功能；</li>
<li>\n –&gt; 换行符。作用：具有换行功能。</li>
</ul>
<hr>
<h4 id="理解编译和反编译"><a href="#理解编译和反编译" class="headerlink" title="理解编译和反编译"></a>理解编译和反编译</h4><p>编译：把源文件编译为字节码文件，也就是把”*.java”文件编译为”.class”文件</p>
<p>反编译：把字节码文件编译为源文件。</p>
<p><strong>反编译的实现方式：</strong></p>
<p><strong>方式一：提供javap.exe来实现</strong></p>
<ul>
<li>实现：在字节码文件所在目录中，我们通过javap.exe来实现反编译，例如:javap HelloWorld04</li>
<li>优点：能看到编译时期默认做的操作，例如<strong>能看到编译时期默认提供的无参构造方法</strong>。</li>
<li>缺点：反编译之后，我们无法看到方法内部的具体实现，也就是看不到方法体。</li>
</ul>
<p><strong>方法二：通过jd-gui.exe来实现</strong></p>
<ul>
<li>实现：打开jd-gui.exe程序，然后把需要反编译的字节码文件拖拽进入jd-gui.exe程序中即可。</li>
<li>优点：反编译之后，<strong>我们能够看到方法内部的具体实现，也就是能看到方法体。</strong></li>
<li>缺点：不能看到编译时期默认做的操作，例如无法看到编译时期默认提供的无参构造方法。</li>
</ul>
<p><strong>方法一与方法二可以看作是互补的。</strong></p>
<hr>
<h4 id="文件存储的的单位"><a href="#文件存储的的单位" class="headerlink" title="文件存储的的单位"></a>文件存储的的单位</h4><p>实际开发中，我们把字节称之为文件存储的最小单位。</p>
<p>开发中，<strong>字节有两种表示方式</strong>，分别为：</p>
<ol>
<li><p>无符号表示</p>
<p>（只能表示正数，不能表示负数）</p>
<ul>
<li>1个字节无符号表示的数值范围在【0,2^8-1】之间，也就是表示范围在【0,255】之间。</li>
<li>作用：基本数据类型中，char类型采用的就是无符号来表示。</li>
</ul>
</li>
<li><p>有符号表示</p>
<p>（不但能表示正数，还能表示负数）</p>
<ul>
<li>1个字节有符号表示的数值范围在[-2^ 7,2^7-1]之间，也就是表示范围在[-128,127]之间。</li>
<li>作用：基本数据类型中，byte、short、int和long类型采用的就是有符号来表示。</li>
</ul>
</li>
<li><p>常见的文件存储单位及其换算公式</p>
<ul>
<li>1KB &#x3D; 1024Byte</li>
<li>1MB &#x3D; 1024KB</li>
<li>1GB &#x3D; 1024MB</li>
</ul>
</li>
<li><p>问题</p>
<p>：长度单位的换算使用的是1000，为什么文件存储单位换算使用的是1024呢？</p>
<ul>
<li>答：二进制早期有电信号开关演变而来，也就是意味着文件存储的换算肯定使用的是2的多少次方，而2的10次方结果就是1024，也就是2^10是最接近于1000的整数，因此就使用了1024来作为文件存储的换算值。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="DAY03"><a href="#DAY03" class="headerlink" title="DAY03"></a>DAY03</h3><h4 id="标识符的作用"><a href="#标识符的作用" class="headerlink" title="标识符的作用"></a>标识符的作用</h4><ul>
<li>标识符就是给类名、方法名、变量名、常量名和包名命名的规则。</li>
</ul>
<hr>
<h4 id="标识符的规则"><a href="#标识符的规则" class="headerlink" title="标识符的规则"></a>标识符的规则</h4><ol>
<li>必须由数字、字母、下划线和&amp;组成，并且开头不能是数字。</li>
<li>标识符不能是关键字或保留字，因为关键字和保留字是给编程语言使用。</li>
<li>在java语言中，对于标识符的长度没有任何限制，也就是标识符可以任意长。<ul>
<li>补充：java语言默认采用Unicode编码表，而Unicode编码表几乎包含了全世界所有的文字。</li>
<li>注意：此处的“字母”我们应该广义地去理解，也就是此处“字母”可以是“英文”，也可以是“中文”。</li>
<li>建议：给标识符进行命名的时候，我们不建议使用“中文汉字”来进行命名。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="命名规范的讲解"><a href="#命名规范的讲解" class="headerlink" title="命名规范的讲解"></a>命名规范的讲解</h4><p>明确：命名的时候不建议使用”中文汉字“，并且还必须做到“见名知意”的要求。</p>
<p>类名：必须遵守“大驼峰”的命名规范，大驼峰：每个单词首字母都大写。</p>
<ul>
<li>例如：HelloWorld、VariableDemo</li>
</ul>
<p>方法名、变量名：必须遵守“小驼峰”的命名规则，小驼峰：第一个单词首字符小写，从第二个单词起首字母都大写。</p>
<ul>
<li>例如：userName、maxValue</li>
</ul>
<p>常量名：必须遵守“字母全部大写，多个单词之间以下划线连接”的命名规范。</p>
<ul>
<li>例如：USER、NAME</li>
</ul>
<p>包名：必须遵守“单词全部小写，多个单词之间以 ‘.’ 连接，并且必须做到顶级域名倒着写”的命名规范。</p>
<ul>
<li>例如：com.bjpowernote.demo</li>
</ul>
<hr>
<h3 id="DAY04"><a href="#DAY04" class="headerlink" title="DAY04"></a>DAY04</h3><h4 id="数据类型的分类"><a href="#数据类型的分类" class="headerlink" title="数据类型的分类"></a>数据类型的分类</h4><ol>
<li><p>基本数据类型【八大基本数据类型】</p>
<ul>
<li>整数型：byte、short、int、long</li>
<li>浮点数：float、double</li>
<li>布尔型：boolean</li>
<li>字符型：char</li>
</ul>
</li>
<li><p>引用数据类型</p>
<ul>
<li>数组、字符串、类和接口等等</li>
</ul>
</li>
<li><p><strong>整数型（有符号表示）</strong></p>
<ul>
<li>byte，占用1个字节，则表示范围在[-2^7, 2^7-1]之间，–&gt; [-128, 127]。</li>
<li>short, 占用2个字节，[-2^15, 2^15-1], –&gt; [-32768,32767]。</li>
<li>int, 占用4个字节，[-2^31, 2^31-1], –&gt; 大概在正负21亿之间。</li>
<li>long, 占用8个字节，[-2^63, 2^63]。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><p>占用的字节数越大，则表示的数值范围也就越大，开发中我们需要根据存储数值的大小来选择合适的数据类型。</p>
<p>–&gt; 存储的数值大小不能超出其数据类型的表示范围，否则就会编译错误。</p>
<p>–&gt; 实际开发中，byte和short几乎不会使用。存储较小的数值使用int，存储较大的数值使用long。</p>
</li>
<li><p>开发中，只能使用八进制、十进制、十六进制来表示整数，不能“直接”使用二进制来表示整数。</p>
<ol>
<li>int num1 &#x3D; 017：八进制；</li>
<li>int num1 &#x3D; 23：十进制；</li>
<li>int num1 &#x3D; 0x2B：十六进制；</li>
</ol>
</li>
<li><p>整数固定值常量默认为int类型,在整数固定值常量的末尾添加”L”【推荐】或”l”，则该常量就变为Long类型。</p>
</li>
</ul>
</li>
<li><p><strong>浮点型（小数）</strong></p>
<ul>
<li>float，占用4个字节，我们称之为“单精度类型”，理论上能精确到小数点后7位。</li>
<li>double，占用8个字节，我们称之为“双精度类型”，理论上精确度是float的两倍。</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><p>占用的字节数越大，则表示小数的精确度就越高，开发中我们建议使用double类型。</p>
<p>–&gt; 开发中，float类型很少使用，因为精确度太低，而double类型很常用。</p>
</li>
<li><p>小数的表示方式有：1）生活中的表示小数；2）使用科学计数法来表示小数。</p>
<p>–&gt; 3.14E3，等效于：3140.0 –&gt; “乘以10的3次方”</p>
<p>–&gt; 3.14E-3，等效于：0.00314 –&gt; “除以10的3次方”</p>
</li>
<li><p>注意：使用科学计数法来表示小数的时候，此处的英文字母不区分大小写（E或e）。</p>
</li>
<li><p>因为小数存储的区别，因此不建议使用小数来做特别精确的运算，因为得到结果可能不精确。</p>
<p>–&gt; double sum &#x3D; 0.001 + 0.0002; 理论结果是：0.0003 实际结果：0.000300000000000000000003</p>
</li>
<li><p>小数固定值常量默认为double类型，在小数固定值常量末尾添加”F”【推荐】或”f”，则该常量就变为：float类型。</p>
</li>
<li><p>浮点型占用的字节数，强调的是存储”小数部分”占用的字节数，并不是强调存储”整数部分”占用的字节数。</p>
<p> <strong>–&gt; float类型存储”整数部分占用8个字节”，存储”小数部分占用4个字节”，总计至少占用12个字节。</strong>【底层（科学计数法）】</p>
</li>
</ul>
</li>
<li><p><strong>布尔型(boolean)</strong></p>
<ul>
<li><p>明确：布尔类型的固定值常量只有true和false，并且true和false都是关键字。</p>
<p>–&gt; true：表示为真或条件成立</p>
<p>–&gt; flase：表示为假或条件不成立</p>
</li>
<li><p>使用场合：常用于条件判断，条件成立则返回true，条件不成立则返回false。</p>
</li>
<li><p><strong>面试题：请问boolean类型占用几个字节？</strong></p>
<p>–&gt; 在java规范中，没有明确boolean类型占用几个字节。我个人觉得boolean类型占用x个字节，并说出理由！</p>
</li>
</ul>
</li>
<li><p><strong>字符型(char，无符号表示)</strong></p>
<ul>
<li>明确：字符型占用2个字节数，表示的数值范围在[0,2^16-1]之间，也就是表示范围在[0,65535]之间。</li>
<li>注意：使用单引号包裹的一个字符串，我们就称之为字符固定值常量。</li>
</ul>
</li>
<li><p><strong>字符串类型？</strong></p>
<ul>
<li><p>明确：字符串类型的名字叫做String类型，并且String类型属于”引用数据类型”。</p>
</li>
<li><p>注意：使用双引号包裹的任意多个字符，我们就称为“字符串固定值常量”。</p>
<p>–&gt; 双引号包裹的0个字符，我们就称之为”空字符串”。</p>
</li>
</ul>
</li>
<li><p>关于”+”的作用</p>
<ul>
<li>表示正数。eg:int num &#x3D; +8;</li>
<li>加法运算，要求两个操作数都必须是数值型。eg:int sum &#x3D; 5 + 8;</li>
<li>连接符，要求其中一个操作数必须是字符串类型。eg:”hello” + true;</li>
<li>结论：字符串的连接符操作，则运算完毕后返回的结果肯定属于String类型。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="字符在内存中的存取（理解）"><a href="#字符在内存中的存取（理解）" class="headerlink" title="字符在内存中的存取（理解）"></a>字符在内存中的存取（理解）</h4><ol>
<li><p>整数在内存中的存取</p>
<ul>
<li>存储：直接把整数转化为二进制，然后存入到内存中即可。</li>
<li>读取：取出内存中的二进制，然后把该二进制转化为十进制。</li>
</ul>
</li>
<li><p>字符在内存中的存取</p>
<ul>
<li><p>明确：制作一个《编码表》，在《编码表》中让每个“字符”都对应一个“正整数”。</p>
</li>
<li><p>存储（编码）：把需要存取的“字符”对照《编码表》，则就得到了一个“正整数”，然后将该“正整数”存入到内存中即可。</p>
</li>
<li><p>读取（解码）：把内存中的二进制转化为：“正整数”，然后把“正整数”对照《编码表》，则就得到了该“正整数”对应的“字符”。</p>
</li>
<li><p>注意：“编码”类似于发电报时的“加密”操作，“解码”类似于收电报时的“解密”操作，而《编码表》就类似于《密码本》。</p>
<p> –&gt; “加密”和“解密”必须对照同一个《密码本》，则“编码”和“解码”必须对照同一个《编码》。</p>
</li>
</ul>
</li>
<li><p>常见编码表的概述</p>
<ul>
<li><p>ASCII：美国信息交换标准代码。</p>
</li>
<li><p>GBK：全称《汉字内码扩展规范》，字库是用来表示中文用的编码。ANSI编码表就是GBK子码表，专门用于表示简码表。</p>
</li>
<li><p>Unicode：又称万国码、同一码，是为了解决传统的编码方案的局限性而产生的，在Unicode编码表中几乎包含了全世界所有的文字。</p>
</li>
<li><p>问题：请问全世界所有的文字有多少个？</p>
<p>–&gt; 答案：肯定不超过65536个文字，因为char类型占用2个字节，能描述65536种可能。</p>
</li>
</ul>
</li>
<li><p>ASCII和Unicode之间的关系？</p>
<p>ASCII编码表的前128位和Unicode编码表一模一样，也就是Unicode编码表中包含了ASCII编码表。</p>
<ul>
<li>‘1’对应的正整数为：49</li>
<li>‘A’对应的正整数为：65</li>
<li>‘a’对应的正整数为：97</li>
</ul>
<p>注意：两个大小写英文字母对应正整数之差为32，则我们就可以通过”小写字母”找到对应的”大写字母”。</p>
</li>
<li><p>int 类型和char类型的关系？</p>
<ul>
<li><p>相同点：</p>
<p> 在内存中存储的都是“整数”，则就有以下重要的结论：</p>
<p> char类型”肯定”都能转化为int类型，int类型”未必”能转化为char类型</p>
</li>
<li><p>不同点：</p>
<p> int类型占用4个字节，而char类型占用2个字节。</p>
<p> int类型采用”有符号”表示，而char类型采用“无符号”表示。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="DAY05"><a href="#DAY05" class="headerlink" title="DAY05"></a>DAY05</h3><h4 id="常见的转义字符-1"><a href="#常见的转义字符-1" class="headerlink" title="常见的转义字符"></a>常见的转义字符</h4><ul>
<li><p>明确：转义字符就是一个特殊的字符，并且每个转义字符都有自己的特殊含义。</p>
</li>
<li><p>\t，制表符，作用：显示多个空格，并且还有对齐的功能。</p>
</li>
<li><p>\n，换行符，作用：具有换行的功能。</p>
</li>
<li><p>\“，编译时，把它当成一个整体，不作为字符串结束的标记；</p>
<p> 运行时，会忽略反斜杠，只会展示出一个双引号。</p>
</li>
<li><p>\‘，编译时会把它当成一个整体，运行时只会展示出一个单引号。</p>
</li>
</ul>
<hr>
<h4 id="关于字符的使用"><a href="#关于字符的使用" class="headerlink" title="关于字符的使用"></a>关于字符的使用</h4><ol>
<li><p>方式一：把字符放在字符串内部使用！</p>
<ul>
<li>System.out.println(“hello\tworld”);</li>
</ul>
</li>
<li><p>方式二：把字符串单独使用，然后再使用+来拼接。</p>
<ul>
<li>System.out.println(“hello” + ‘\t’ + “world”);</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>int类型和char类型做“+”运算，则做的是“加法操作”。</li>
<li>String类型和char类型做“+”运算，则做的是“连接符操作”。</li>
</ul>
</li>
<li><p>关于Unicode值得补充</p>
<ul>
<li>因为java语言默认采用Unicode编码表，因此每个”字符”都对应一个Unicode值，其中一个Unicode值我们必须掌握</li>
<li>‘\u0000’代表的是空格字符</li>
</ul>
</li>
</ol>
<hr>
<h4 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h4><ol>
<li><p>为什么需要学习数据类型的转换?</p>
<ul>
<li>因为java是强类型的语言，因此参与“赋值运算”和“算数运算”的时候，要求参与运算的数据类型必须保持一致，否则就需要做数据类型转换。</li>
</ul>
</li>
<li><p>基本数据类型转换的方式有哪些？</p>
<ul>
<li>隐式类型转换（自动）</li>
<li>强制类型转换（手动）</li>
</ul>
</li>
<li><p>哪些基本数据类型可以相互转换？</p>
<ul>
<li>除了boolean类型外，其余的基本数据类型都可以相互转换。</li>
</ul>
</li>
<li><p>隐式类型转换（自动）</p>
<ul>
<li>原则：低字节向高字节自动提升。</li>
<li>byte –&gt; short –&gt; int –&gt; long –&gt; float –&gt; double</li>
<li>char –&gt; int</li>
</ul>
<p>赋值运算：</p>
<ul>
<li><p>原则：低字节向高字节自动提升。</p>
</li>
<li><p>特例：把int类型的常量，赋值给byte、short和char类型的变量或final修饰的常量时，则就是属于隐式类型转换的特例。只需赋值的数据没有超出其数据类型的表示范围即可。</p>
<p>–&gt; 赋值的数据应该是什么？赋值的数据应该是int类型的常量！</p>
<p>–&gt; 赋值数据的大小是什么？赋值数据的大小不能超出其数据类型的表示范围。</p>
</li>
</ul>
<p>算术运算</p>
<p> 原则：两个操作数做运算，如果其中一个操作数为double类型，则另外一个操作数也会隐式转化为double类型；<strong>否则</strong>，如果其中一个操作数为float类型，则另外一个操作数也会隐式转化为float类型，最终计算结果就是float类型；<strong>否则</strong>，如果其中一个操作数为long类型，则另外一个操作数也会隐式转化为long类型，最终计算结果就是long类型;<strong>否则</strong>，这两个操作数都会隐式转化为int类型，最终计算的结果就是int类型。</p>
</li>
</ol>
<hr>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p><img src="https://cherish779.github.io/images/note_images/%E9%9D%A2%E8%AF%95%E9%A2%9801.png" alt="img"></p>
<hr>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul>
<li><p>当隐式类型转换无法解决问题时，我们要采用强制类型转换。</p>
</li>
<li><p>语法：目标类型 变量 &#x3D; （目标类型） 数据；</p>
<p>eg: int num &#x3D; (int) 3.14; –&gt; 可以用来小数取整。【<strong>一、想要的精度丢失</strong>】</p>
</li>
<li><p><strong>底层：只保留低位字节的二进制，高位字节的二进制就丢弃。</strong></p>
</li>
</ul>
<p><img src="https://cherish779.github.io/images/note_images/%E7%94%BB%E5%9B%BE01.png" alt="img"></p>
<ul>
<li><p>注意：使用强制类型转换的时候，可能就丢失精度，使用的时候切记。【<strong>二、不想要的精度丢失</strong>】</p>
<p>–&gt; int num &#x3D; (int) 3.14; 只保留了整数位，丢失了小数位。</p>
</li>
<li><p><strong>强制类型转换后，被强制转换的变量还是原来的数据类型。</strong></p>
<p>eg: int num; byte num1 &#x3D; (int) num; –&gt; num (int类型)</p>
</li>
<li><p>使用强制类型转换的时候，我们必须明确强制转换数据的范围，否则得到的结果就不准确。</p>
</li>
</ul>
<hr>
<h3 id="DAY06"><a href="#DAY06" class="headerlink" title="DAY06"></a>DAY06</h3><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p> “&#x3D;”，作用：把等号右边表达式的结果赋值给等号左边的变量或final修饰的常量保存。</p>
<hr>
<h4 id="面试题【详细代码见day01–-gt-Exercise02-ChangeNumber】"><a href="#面试题【详细代码见day01–-gt-Exercise02-ChangeNumber】" class="headerlink" title="面试题【详细代码见day01–&gt;Exercise02_ChangeNumber】"></a>面试题【详细代码见day01–&gt;Exercise02_ChangeNumber】</h4><p>用四种方式交换两个数值：</p>
<ol>
<li>创建临时变量temp;</li>
<li>加减法（正整数）；</li>
<li>乘除法；</li>
<li>异或法；</li>
</ol>
<hr>
<h4 id="算法运算符的分类"><a href="#算法运算符的分类" class="headerlink" title="算法运算符的分类"></a>算法运算符的分类</h4><ol>
<li><p>一元运算符（只需要一个操作数参与运算）</p>
<p>包含：++、–</p>
</li>
<li><p>二元运算符（需要两个操作数来参与运算）</p>
<ul>
<li><p>包含：+ 、-、*、&#x2F;、%</p>
</li>
<li><p>+：表示正数，加法运算，连接符操作；</p>
</li>
<li><p>-：表示负数，减法运算；</p>
</li>
<li><p>*：乘法运算</p>
</li>
<li><p>&#x2F;：除法运算</p>
</li>
<li><p>%：取模运算或取余运算</p>
<p>–&gt; 作用：获得两个整数相除的余数</p>
<p>eg：0 % 3 &#x3D; 0 –&gt; <strong>注意：0能被任何数整除。</strong></p>
<p> 1 % 3 &#x3D; 1</p>
<p>注意：”除法运算”是获得两个整数相除的”整数位结果”，”取模运算”是获得两个整数相除的”余数”。</p>
<p>使用场合：</p>
<ul>
<li>判断m能否被n整除，如果m%n的结果为0，则意味着m能被n整除；如果m%n的结果不为0，则意味着m不能被n整除。</li>
<li>“任意数 % m”，则得到的结果肯定在[0,m - 1]之间，例如：”任何数 % 3”，则得到的结果肯定是在[0, 2]之间。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="除法运算符的注意事项"><a href="#除法运算符的注意事项" class="headerlink" title="除法运算符的注意事项"></a>除法运算符的注意事项</h4><ul>
<li>在java语言中，两个整数做除法运算，则得到的结果肯定为整数。</li>
<li>在java语言中，做除法运算的时候，分母不能为0，否则就会抛出算数异常（ArithmeticException）。</li>
</ul>
<hr>
<h4 id="算术运算符之一元运算符"><a href="#算术运算符之一元运算符" class="headerlink" title="算术运算符之一元运算符"></a>算术运算符之一元运算符</h4><p><img src="https://cherish779.github.io/images/note_images/%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="img"></p>
<p><img src="https://cherish779.github.io/images/note_images/%E9%9D%A2%E8%AF%95%E9%A2%9802.png" alt="面试题02"></p>
<p><strong>面试题02</strong></p>
<hr>
<h4 id="比较运算的概述"><a href="#比较运算的概述" class="headerlink" title="比较运算的概述"></a>比较运算的概述</h4><ul>
<li><p>明确：比较运算符返回的结果肯定是boolean类型。</p>
</li>
<li><p>如果条件成立，则返回true；如果条件不成立，则返回false。</p>
</li>
<li><p>包含：&gt; 、&gt;&#x3D;、&lt;&#x3D;、&#x3D;&#x3D;、!&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;（等于），判断左右两边的结果是否相等。</p>
<p>–&gt; 如果左右两边属于“基本数据类型”，则比较左右两边的“数据值”是否相等（掌握）。</p>
<p>–&gt; 如果左右两边属于“引用数据类型”，则比较左右两边的“地址值”是否相等（了解）。</p>
</li>
</ul>
<p><img src="https://cherish779.github.io/images/note_images/%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E7%AD%89%E7%AD%89%E7%9A%84%E4%BD%9C%E7%94%A845552.png" alt="img"></p>
<ul>
<li><p>!&#x3D;（不等于），判断左右两边的结果是否不相等。</p>
<p>–&gt; 如果左右两边属于“基本数据类型”，则比较左右两边的“数据值”是否不想等（掌握）。</p>
<p>–&gt; 如果左右两边属于“引用数据类型”，则比较左右两边的“地址值”是否不相等（了解）。</p>
</li>
<li><p>注意点：</p>
<ol>
<li>比较运算符是一个整体，中间不允许条件空格！</li>
<li>注意区分“&#x3D;”和“&#x3D;&#x3D;”的区别，“&#x3D;”属于赋值运算符，“&#x3D;&#x3D;”属于比较运算符。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="比较运算符的面试题"><a href="#比较运算符的面试题" class="headerlink" title="比较运算符的面试题"></a>比较运算符的面试题</h4><p>问题:<strong>请问以下代码是否有问题？如果没有语法问题，请说出结果是什么？</strong></p>
<p><img src="https://cherish779.github.io/images/note_images/%E9%9D%A2%E8%AF%95%E9%A2%9803.png" alt="面试题03"></p>
<p><strong>面试题03</strong></p>
<hr>
<h4 id="逻辑运算符的概述"><a href="#逻辑运算符的概述" class="headerlink" title="逻辑运算符的概述"></a>逻辑运算符的概述</h4><ul>
<li><p>明确：参与逻辑运算的数据必须是boolean类型，并且逻辑运算符返回的结果肯定是boolean类型。</p>
</li>
<li><p>包含：&amp;、|、^、&amp;&amp;、||、!</p>
</li>
<li><p>&amp;（与运算符），属于二元运算符</p>
<p>–&gt; 结论：只要两边都为true，则结果就是true。</p>
<p> 只要有一边为false，则结果就是false。</p>
<p><strong>辅助记忆</strong>：小明“与”小红来一趟办公室。</p>
</li>
<li><p>|（或运算符），属于二元运算符</p>
<p>–&gt; 结论：只要两边都为false，则结果就是false。</p>
<p> 只要有一边为true，则结果就是true。</p>
<p>辅助记忆：小明“或”小红来一趟办公室。</p>
</li>
<li><p>^：异或运算，相同为false，不同为true。</p>
<p>———————–以上三个开发中不常用，但是结论很重要———————-</p>
<p>———————–以下三个开发中常用，并且结论也很重要———————-</p>
</li>
<li><p>&amp;&amp;（短路与），属于二元运算符</p>
<ol>
<li><p>结论1：&amp;和&amp;&amp;的执行结果一样。</p>
</li>
<li><p>结论2：&amp;&amp;当左侧表达式为false时，右边不执行，结果直接原样返回左侧结果为false。</p>
<p> &amp;&amp;当左侧表达式为true时，右边执行，结果直接原样返回右侧结果。</p>
</li>
</ol>
<p>||（短路或），属于二元运算符</p>
<ol>
<li><p>结论1：|和||的执行结果一模一样；</p>
</li>
<li><p>结论2：如果左侧表达式的结果为true，则右边表达式肯定不会执行，并且原样返回左侧表达式的结果(true)。</p>
<p> 如果左侧表达式的结果为false，则右侧表达式肯定会去执行，并且原样返回右侧表达式的结果(true|false)。</p>
</li>
</ol>
<p>!（非运算），属于一元运算符。</p>
<p><strong>使用场合：</strong></p>
<ul>
<li>如果<strong>两个条件必须成立才能满足需求</strong>，则这两个条件之间使用“&amp;&amp;”来组织关系；</li>
<li>如果<strong>两个条件其中一个成立既能满足需求</strong>，则这两个条件之间使用”||”来组织关系。</li>
</ul>
<hr>
</li>
</ul>
<h4 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h4><p><strong>请问：&amp;和&amp;&amp;的区别和联系</strong></p>
<ul>
<li>共同点：&amp;和&amp;&amp;的执行结果一模一样。</li>
<li>不同点：&amp;&amp;的执行效率高于&amp;，因此开发中我们常用&amp;&amp;。</li>
</ul>
<p><strong>请问：|和||的区别和联系</strong></p>
<ul>
<li>共同点：|和||的执行结果一模一样。</li>
<li>不同点：||的执行效率高于|，因此开发中共我们常用||。</li>
</ul>
<p><strong>问题：在注释中，如何表示区间范围？</strong></p>
<ul>
<li><p>答：[]代表包含，()代表不包含。</p>
<p>eg：[3,5) –&gt; 表示3到5之间的整数，包含3，但不包含5</p>
<p> (3.0，5.0] –&gt; 表示3.0到5.0之间的小数，包含5.0，但不包含3.0</p>
<hr>
</li>
</ul>
<h4 id="位运算（了解，建议掌握）"><a href="#位运算（了解，建议掌握）" class="headerlink" title="位运算（了解，建议掌握）"></a>位运算（了解，建议掌握）</h4><ul>
<li><p>明确：参与位运算的数据应该是整数型，并且位运算返回的结果也是整数。</p>
</li>
<li><p>包含：&amp;、|、^、~、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</p>
</li>
<li><p>&amp;（与位运算），属于二元运算符</p>
<p>结论：位都为1，则结果就是1；位有一个为0，则结果就是0</p>
<p>使用场合：学习HashMap集合的时候，验证为啥底层的数组空间长度必须为2的整数次幂。</p>
</li>
<li><p>|（或为运算），属于二元运算符</p>
<p>结论：位都为0，则结果就是0；位有一个为1，则结果就是1</p>
</li>
<li><p>^（异或位运算），属于二元运算符</p>
<p>结论：位相同，则为0；位不同，则为1</p>
<p>特点：对m连续异或n两次，得到的结果依旧为m</p>
<p> –&gt; m^n ^ n 的结果为m，n^m ^n的结果为m，n ^ n ^ m的结果为m</p>
</li>
</ul>
<p>使用场合：</p>
<ol>
<li>使用异或位运算，我们可以实现对数据的”加密”和”解密”操作。<ul>
<li>加密：对需要加密的数据异或m，则就得到了加密后的结果。</li>
<li>解密：对加密后的数据继续异或m，则就得到了解密后的结果。</li>
</ul>
</li>
<li>使用异或位运算，用于交换两个变量的值。<ul>
<li>优点：效率非常高；</li>
<li>缺点：复杂、不好理解。</li>
</ul>
</li>
</ol>
<p>~（非位运算符），属于一元运算符</p>
<p>结论：二进制位取反的含义。0取反的结果就是1，1取反的结果就是0。</p>
<p>&lt;&lt; （左移位运算）</p>
<ul>
<li><p>结论：对m左移n位，则等效于：m * 2n</p>
<p>–&gt; 此处m可以是正数，也可以是负数！</p>
<p>特点：左移运算之后，则低位永远补0即可。</p>
<p>使用场合：对m做乘以2的操作，则最高效的方式为：m &lt;&lt; 1</p>
<p>(&gt;&gt;右移位运算)</p>
<ul>
<li><p>结论：对m右移n位，则等效于：m&#x2F;2n</p>
<p>–&gt; 此处m必须是正数，不能为负数！</p>
<p>特点：正数右移，则高位补0；负数右移，则高位补1</p>
<p>使用场合：对m做除以2的操作，则最高效的方式为：m&gt;&gt;1</p>
<p>–&gt; 此处m必须有正好，不能为负数！</p>
</li>
</ul>
<p>(&gt;&gt;&gt;无符号右移)</p>
<ul>
<li>无论对正数还是负数做无符号右移的操作，则高位永远补0即可。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><ul>
<li><p>语法：数据类型 变量名 &#x3D; 条件表达式？表达式1 : 表达式2；</p>
</li>
<li><p>执行：如果”条件表达式”的结果为true，则执行”表达式1“，也就是”把表达式1*的结果赋值给等号左边的变量来保存。</p>
<p> 如果”条件表达式“的结果flase，则执行“表达式2”，也就是把“表达式2”的结果赋值给等号左边的变量来保存。</p>
</li>
<li><p>注意：if…else选择结构在某些情况下可以被三目运算符代替，毕竟这两者都是做的“二选一”的操作。</p>
</li>
</ul>
<hr>
<h3 id="DAY07"><a href="#DAY07" class="headerlink" title="DAY07"></a>DAY07</h3><h4 id="idea的使用"><a href="#idea的使用" class="headerlink" title="idea的使用"></a>idea的使用</h4><p><img src="https://cherish779.github.io/images/note_images/idea%E7%9A%84%E4%BD%BF%E7%94%A801.png" alt="img"></p>
<ol>
<li><p>如何使用IDEA来编译源文件？</p>
<ul>
<li><p>明确：IDEA默认已经集成了javac.exe这个可执行程序，也就是使用IDEA就会默认实现对源文件的编译操作。</p>
</li>
<li><p>问题：IDEA项目中的源文件放在哪里的？</p>
<p>–&gt; 源文件放在IDEA项目中的src目录中</p>
</li>
<li><p>问题：IDEA项目中的字节码文件放在哪儿的？</p>
<p>–&gt; 字节码文件放在IDEA项目中的out目录中。</p>
<p>2、如何使用IDEA来执行程序呢？</p>
</li>
</ul>
<p> 明确：IDEA默认已经集成了java.exe这个可执行程序，因此我们直接使用IDEA就可以运行java程序，并且运行程序的方式如下：</p>
<p> 方式一：选中类型或main方法左侧行号附件的运行按钮，然后选中该“run.Xxx.main()”即可。</p>
<p> –&gt; 也可以通过点击“工具栏”中的运行按钮和“控制台”左侧的运行按钮来执行程序。</p>
<p> 方式二：在代码块编辑区域，我们鼠标右键，然后选中“Run Xxx.main()”即可。</p>
<p> 方式三：使用“ctrl + shift + F10”快捷键来运行IDEA程序。</p>
<hr>
</li>
</ol>
<h4 id="IDEA的常用的快捷键"><a href="#IDEA的常用的快捷键" class="headerlink" title="IDEA的常用的快捷键"></a>IDEA的常用的快捷键</h4><p><img src="https://cherish779.github.io/images/note_images/idea%E7%9A%84%E4%BD%BF%E7%94%A802.png" alt="img"></p>
<ul>
<li><strong>Ctrl + Alt + L：代码格式化快捷键</strong></li>
</ul>
<hr>
<h4 id="如何查看idea的代码编译错误"><a href="#如何查看idea的代码编译错误" class="headerlink" title="如何查看idea的代码编译错误"></a>如何查看idea的代码编译错误</h4><ul>
<li>提示1：如果某行代码有语法错误，则该代码文本底部有红色波浪线。</li>
<li>提示2：如果标识符错误，则该标识符的名字就会变为红色字体显示。</li>
</ul>
<p><img src="https://cherish779.github.io/images/note_images/idea%E7%9A%84%E4%BD%BF%E7%94%A803.png" alt="img"></p>
<hr>
<h4 id="代码的执行顺序"><a href="#代码的执行顺序" class="headerlink" title="代码的执行顺序"></a>代码的执行顺序</h4><ol>
<li><p><strong>顺序执行</strong></p>
</li>
<li><p><strong>选择执行</strong></p>
<ol>
<li><p>if选择结构</p>
<ol>
<li><p>if单选结构</p>
<ul>
<li>概述：if(条件表达式){ &#x2F;&#x2F;当“条件表达式”的结果为true，则执行此处的代码。}</li>
<li>注意：<ol>
<li>此处的“条件表达式”返回的结果必须时Boolean型。</li>
<li>if选择结构依旧包含在顺序执行中，也就是顺序执行中包含了选择执行。</li>
</ol>
</li>
</ul>
</li>
<li><p>if双选结构</p>
</li>
<li><p>if多选结构</p>
<ul>
<li>在完整的if多选结构中，有且只能执行一个大括号中的代码（多选一）。</li>
<li>if，最前面，有且只能有一个（1）</li>
<li>else if，中间位置，可以有任意多个（0，1，2，…，n）</li>
<li>else，最后面，最多只能有一个（0或1）</li>
</ul>
</li>
<li><p><strong>if选择结构的总结</strong></p>
<ol>
<li><p>如果if选择结构中只有一行代码，则我们还可以省略大括号！</p>
<p>省略大括号之后，则编译时会默认添加一个大括号，用于包裹if结构中的第一行代码。</p>
<p>建议：对于初学者而言，不建议省略if选择结构中的大括号，省略大括号之后可能会带来额外的问题。</p>
</li>
<li><p>请问以下代码是否有语法问题？如果没有语法问题，请说出执行的结果是什么？–&gt;输出：xixi</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//等效于：if(false){};{}</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"xixi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//会执行</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li><p><strong>switch选择结构</strong></p>
<p><strong>关于switch关键字的注意点：</strong></p>
<ul>
<li>此处“表达式”的结果必须是byte、short、int、char、String和枚举(后面学习)类型 ，别的类型都会编译错误！</li>
<li>“表达式”的结果不能是boolean类型，因此switch选择结构就不能对布尔类型的数据进行匹配！</li>
</ul>
<p><strong>关于case关键字</strong></p>
<ul>
<li><p>case关键字后面必须是“常量”,不能为“变量”，从而保证匹配的安全性！</p>
</li>
<li><p>在switch选择结构中，case后面不允许有多个“相同的”常量值，否则就会编译错误！</p>
</li>
<li><p>在此处“表达式”结果的类型和case后面“常量值”的类型必须保持一致，否则就会编译错误！</p>
<p>–&gt; 此处的数据类型必须“保持一致”，包含了“隐式类型转换”之后能保持一致。</p>
<p>–&gt; 因为“表达式”结果不支持boolean类型，因此case后面就不能为boolean类型的数据，也就是不支持区间判断。</p>
</li>
</ul>
<p><strong>关于break关键字的注意点：</strong></p>
<ul>
<li>一旦执行break关键字，则就会跳出switch选择结构，执行switch选择结构之后代码。</li>
<li>在switch选择结构中，我们可以省略break关键字，省略break关键字之后，则就会发生“穿透”，直到遇到下一个break才会结束“穿透”。</li>
</ul>
<p><strong>关于default关键字的注意点：</strong></p>
<ul>
<li>当switch选择结构中的所有case都无法匹配成功，则那么才会去执行default中的代码，此处的default类似于if选择结构中的else代码块。</li>
<li>在switch选择结构中，虽然可以省略default关键字，但是我们不建议省略，除非case都匹配所有的问题。</li>
</ul>
<p>强调：在某个case中定义的变量，则该变量就只能在当前作用域中使用，不能在别的case中使用！</p>
</li>
</ol>
</li>
<li><p><strong>循环执行</strong></p>
</li>
</ol>
<hr>
<h3 id="DAY08"><a href="#DAY08" class="headerlink" title="DAY08"></a>DAY08</h3><h4 id="什么是代码块？"><a href="#什么是代码块？" class="headerlink" title="什么是代码块？"></a>什么是代码块？</h4><ul>
<li>在java语言中，什么是局部变量呢？在代码块或方法体中定义的变量，我们就称为“局部变量”。</li>
<li>在java语言中，局部变量的生命周期在哪儿？定义变量的时候“出生”，执行到所在大括号的结束位置就“死亡”。</li>
<li>在java语言中，代码块具备什么特点呢？在代码块中定义的变量，则该变量就只能在当前作用域中使用，不能再代码块之外使用。</li>
<li>if选择结构，我们也称之为“带名字的代码块”或“带条件的代码块”，因此在if选择结构中定义的变量，我们不能在if选择结构之外使用。</li>
</ul>
<p><strong>当if单选结构和if多选结构都能解决同一个问题的时候，我们建议使用if多选结构来实现，因为此处使用if多选结构效率高。</strong></p>
<hr>
<h4 id="switch的匹配底层如何实现的呢？"><a href="#switch的匹配底层如何实现的呢？" class="headerlink" title="switch的匹配底层如何实现的呢？"></a>switch的匹配底层如何实现的呢？</h4><ul>
<li><strong>如果匹配的是“基本数据类型”，则使用“&#x3D;&#x3D;”比较运算符实现匹配操作；</strong></li>
<li><strong>如果匹配的是“引用数据类型”，则使用equals()方法来实现匹配。</strong></li>
</ul>
<p><strong>强调</strong>：每个功能完成之后，一定要对各种情况进行测试，从而找到代码中隐藏的问题（bug）。</p>
<hr>
<h4 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h4><ol>
<li>if选择结构的使用场合：<ul>
<li>if选择结构适用于“boolean”类型数据的判断，也就是适用于“区间范围”的判断。</li>
</ul>
</li>
<li>switch选择结构的使用合成：<ul>
<li>switch选择结构适用于对“固定值”的判断，也就是“固定值”的判断必须使用switch来实现。</li>
</ul>
</li>
<li>if选择结构和switch选择结构的总结<ul>
<li>使用switch结构能做的事情，我们使用if选择结构都能实现；</li>
<li>使用if选择结构能做的事情，switch不一定都能实现。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="循环结构的分类"><a href="#循环结构的分类" class="headerlink" title="循环结构的分类"></a>循环结构的分类</h4><ol>
<li><p>for循环</p>
<ul>
<li><p>请问以下代码有没有语法错误？</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>	<span class="token comment" spellcheck="true">//没有语法问题，循环初始化在for循环外，内部可省略</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>for循环结构，我们也称为“带名字的代码块”或“带条件的代码块”，因此在“循环体”中定义的变量不能再循环之外使用。</p>
</li>
<li><p>在循环体定义的变量，每次执行循环体该变量都“出生”，每次循环体执行完毕该变量都“死亡”。</p>
</li>
<li><p>问题：想要在循环体中，每次操作的都是同一个变量，则该变量应该定义在哪里？–&gt; 必须定义在循环之前！</p>
</li>
<li><p>“循环条件表达式”返回的结果必须是boolean类型，但是“循环初始化表达式”和“循环后的操作表达式”没有特殊要求。</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">6</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>同时循环两个变量</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">-=</span> <span class="token number">4</span><span class="token punctuation">,</span> j <span class="token operator">+=</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i = "</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">",j = "</span> <span class="token operator">+</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>while循环</p>
</li>
<li><p>do…while循环</p>
</li>
</ol>
<p><strong>对程序有利的死循环</strong></p>
<ul>
<li><p>使用：当不确定循环执行的次数时，我们就使用死循环来实现。</p>
</li>
<li><p>问题：如何书写简单的while、for死循环？</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//等效于：for(;true;){}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>注意：使用for循环的时候，我们如果省略“循环条件表达式”，则默认值就是true。</p>
</li>
</ul>
<hr>
<h4 id="break与return"><a href="#break与return" class="headerlink" title="break与return"></a>break与return</h4><p><img src="https://cherish779.github.io/images/note_images/break_and_return.png" alt="img"></p>
<hr>
<h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p><img src="https://cherish779.github.io/images/note_images/continue.png" alt="img"></p>
<hr>
<h3 id="DAY08-1"><a href="#DAY08-1" class="headerlink" title="DAY08"></a>DAY08</h3><h4 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h4><p><img src="https://cherish779.github.io/images/note_images/%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF.png" alt="img"></p>
<hr>
<h4 id="方法的声明"><a href="#方法的声明" class="headerlink" title="方法的声明"></a>方法的声明</h4><p><img src="https://cherish779.github.io/images/note_images/%E6%96%B9%E6%B3%95%E7%9A%84%E5%A3%B0%E6%98%8E01.png" alt="img"></p>
<hr>
<h4 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h4><p><img src="https://cherish779.github.io/images/note_images/%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8.png" alt="img"></p>
<hr>
<h4 id="调用方法的内存分析（重点）"><a href="#调用方法的内存分析（重点）" class="headerlink" title="调用方法的内存分析（重点）"></a>调用方法的内存分析（重点）</h4><ol>
<li>栈内存的特点？<ul>
<li>栈内存具备“先进后出，后进先出”的特点，类似于生活中的“子弹夹”。</li>
</ul>
</li>
<li>调用方法的内存分析？<ul>
<li>调用方法的时候，则自动就会在栈内中开辟一个“栈帧”，用于执行该方法体中的代码。–&gt;入栈操作</li>
</ul>
</li>
<li>方法调用完毕的内存分析<ul>
<li>在方法体中一旦执行“return”关键字，则就证明方法调用完毕，那么调用方法时所开辟的“栈帧”就会被摧毁。–&gt; 弹栈操作</li>
</ul>
</li>
<li>问题：调用方法的时候，实参num1和num2与形参num1和num2是否有关系？<ul>
<li>答案：此处的“实参”和”形参”没有任何关系，仅仅是”名字”相同而已。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="方法的使用（重点）"><a href="#方法的使用（重点）" class="headerlink" title="方法的使用（重点）"></a>方法的使用（重点）</h4><ol>
<li><p>方法的使用原则</p>
<ul>
<li>先声明，后调用。</li>
</ul>
</li>
<li><p>方法声明的难点</p>
<ol>
<li>明确1：完成该功能，是否需要返回值。–&gt; 返回值类型</li>
<li>明确2：完成该功能，是否需要外部参数参与方法内部的运算。 –&gt; 形参列表</li>
</ol>
</li>
<li><p><strong>方法的分类</strong></p>
<ol>
<li><p>无参无返回值方法</p>
<ul>
<li><p>需求：在方法中输出“hello world”。</p>
</li>
<li><p>分析：完成该功能，无需返回值，因此返回值类型为void。</p>
<p> 完成该功能，无需外部参数参与方法内部运算，因此没有形参。</p>
</li>
</ul>
</li>
<li><p>无参有返回值方法</p>
<ul>
<li><p>需求：调用方法获得常量3+4的和。</p>
</li>
<li><p>分析：完成该功能，需要返回值，因此返回值类型为int。</p>
<p> 完成该功能，无需外部参数参与方法内部的运算，因此没有参数</p>
</li>
</ul>
</li>
<li><p>有参无返回值方法</p>
<ul>
<li><p>需求：在方法中输出指定两个int数据之和。</p>
</li>
<li><p>分析：完成该功能，无需返回值，因此返回值类型为void。</p>
<p> 完成该功能，需要外部参数参与内部的运算，也就是需要两个int类型的形参。</p>
</li>
</ul>
</li>
<li><p>有参有返回值方法</p>
<ul>
<li><p>需求：调用方法获得指定两个double数据之和。</p>
</li>
<li><p>分析：完成该功能，需要返回值，因此返回值类型为double。</p>
<p> 完成该功能，需要外部参数参与方法内部的运算，也就是需要两个double类型的形参。</p>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<hr>
<h4 id="方法的重载（overload）重点"><a href="#方法的重载（overload）重点" class="headerlink" title="方法的重载（overload）重点"></a>方法的重载（overload）重点</h4><ol>
<li><p>方法重载的定义</p>
<ul>
<li><p>同一个类中，具有相同的方法名，但是参数个数不同或参数类型不同，这就构成了方法的重载！</p>
</li>
<li><p>核心：两同，两不同</p>
<p>–&gt; 两同：同一个类中，具有同名的方法。</p>
<p>–&gt;两不同：参数个数不同，参数个数不同 或 参数类型不同。</p>
</li>
</ul>
</li>
<li><p>方法重载的特点</p>
<ul>
<li>修饰符不同，没有构成方法重载；</li>
<li>形参名字不同，没有构成方法重载；</li>
<li>返回值类型不同，没有构成方法重载。</li>
</ul>
</li>
<li><p>方法重载的好处</p>
<ul>
<li>官方：方法重载的出现，使其同一个类中允许定义多个同名的方法，从而避免了方法名被污染。</li>
<li>通俗：学习方法重载之后，如果同一个类中多个同名的方法发生了编译错误，则首先考虑这些方法是否满足方法重载!</li>
</ul>
</li>
<li><p>重载方法的调用</p>
<ul>
<li>调用重载方法的时候，会根据实参的“个数”和“类型”来选择调用合适的方法。</li>
</ul>
</li>
<li><p>目前已经用过的重载方法有哪些？</p>
<ul>
<li>print()、println()等等</li>
<li>问题：通过IDEA工具，如何查看底层的API源码？</li>
<li>实现：按下Ctrl键，然后鼠标左键单击即可。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="DAY09"><a href="#DAY09" class="headerlink" title="DAY09"></a>DAY09</h3><h4 id="数组（引用数据类型，最常用、最基础的数据结构）"><a href="#数组（引用数据类型，最常用、最基础的数据结构）" class="headerlink" title="数组（引用数据类型，最常用、最基础的数据结构）"></a>数组（引用数据类型，最常用、最基础的数据结构）</h4><ol>
<li><p><strong>数组的定义</strong></p>
<ul>
<li>数组就是一个存储“相同数据类型”的“有序”集合（容器）。</li>
</ul>
<p><img src="https://cherish779.github.io/images/note_images/%E6%95%B0%E7%BB%8401.png" alt="img"></p>
</li>
<li><p><strong>数组的声明</strong></p>
<ul>
<li><p>明确：所谓数组的声明，指的就是给数组取一个名字，类似于变量的声明。</p>
</li>
<li><p>语法1：数据类型[] 数组名;</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1<span class="token punctuation">;</span>
String<span class="token punctuation">[</span><span class="token punctuation">]</span> arr2<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>语法2：数据类型 数组名[];</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> arr1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
String arr2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>注意：开发中，建议使用“语法1”来声明数组，因为“数据类型[]”代表的是“数组类型”。</p>
</li>
</ul>
</li>
<li><p><strong>数组的创建</strong></p>
<ol>
<li><p>明确：所谓数组的创建，指的就是在内存中为数组开辟存储空间。</p>
</li>
<li><p>方式一：动态创建数组（仅仅在内存中开辟存储空间，但没有给数组元素指定赋值）</p>
<p>语法：数据类型[] 数组名 &#x3D; new 数据类型[空间长度];</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
String<span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><img src="https://cherish779.github.io/images/note_images/%E6%95%B0%E7%BB%8403.png" alt="img"></p>
</li>
<li><p>方式二：静态创建数组（不但在内存中开辟存储空间，并且还给数组元素指定赋值）</p>
<p>语法1：数据类型[] 数组名 &#x3D; {数据1,数据2,数据3,…};</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">43</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
String<span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"aa"</span><span class="token punctuation">,</span><span class="token string">"gg"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>语法2：数据类型[] 数组名 &#x3D; new 数据类型[]{数据1,数据2,数据3,…};</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">55</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

String<span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">"ss"</span><span class="token punctuation">,</span><span class="token string">"tr"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cherish779.github.io/images/note_images/%E6%95%B0%E7%BB%8402.png" alt="img"></p>
</li>
</ol>
</li>
</ol>
<hr>
<h4 id="操作数组元素"><a href="#操作数组元素" class="headerlink" title="操作数组元素"></a>操作数组元素</h4><p>明确：想要操作数组元素，则必须通过“索引”来实现，因为通过“索引”就能找到元素对应的存储空间，然后就能做出“赋值”和“取值”的操作。</p>
<ol>
<li><p><strong>数组的注意点</strong></p>
<ul>
<li><p>数组存储的是相同数据类型的元素，则意味着每个元素占用的字节数相同。</p>
</li>
<li><p>数组是一块连续的存储空间，则意味着相邻两个元素的存储空间是紧挨着的。</p>
</li>
<li><p>创建数组的时候，我们必须明确数组的空间长度，并且数组一旦创建成功，则数组的空间长度就不能改变了。</p>
</li>
<li><p>给数组元素赋值的时候，赋值“元素的类型”必须和“声明数组的数据类型”保持一致，否则就会编译错误！</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//没问题</span>
arr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//编译错误</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>声明数组的时候，我们可以使用“基本数据类型”来声明数组，也可以使用“引用数据类型”来声明数组。</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1；    <span class="token comment" spellcheck="true">//基本数据类型</span>
String<span class="token punctuation">[</span><span class="token punctuation">]</span> arr2<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//引用数据类型</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>通过索引来操作数组元素的时候，操作的索引值必须合法，如果索引值不合法就会抛出数组索引越界异常。</p>
<p>明确：数组索引的合法取值范围在[0,数组长度-1]之间，如果索引越界就会抛出数组索引越界异常（ArrayIndexOutOfBoundsException）。</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">pritnln</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//输出11</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//抛出数组索引越界异常</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>通过大括号创建出来的数组，则无法“直接”作为方法的”返回值”和”实参”，因为编译器不认识大括号创建出来的数组。</strong></p>
</li>
</ul>
<hr>
</li>
</ol>
<h4 id="数组的属性"><a href="#数组的属性" class="headerlink" title="数组的属性"></a>数组的属性</h4><ul>
<li>明确：基本数据类型没有属性和方法，但是引用数据类型有属性和方法。</li>
<li>强调：通过数组的“length”属性，我们可以动态的获得数组的空间长度。</li>
</ul>
<hr>
<h4 id="数组元素的默认值"><a href="#数组元素的默认值" class="headerlink" title="数组元素的默认值"></a>数组元素的默认值</h4><p>明确：通过“动态创建数组”的方式，则数组中每个元素都有默认值，并且元素的默认值规则如下：</p>
<ul>
<li>整数型（byte、short、int和long）数组元素的默认值为：0</li>
<li>浮点型（float和double）数组元素的默认值为：0.0</li>
<li>布尔型（boolean）数组元素的默认值为：false</li>
<li>字符型（char）数组元素默认值为：’\u0000’ –&gt; 代表空格字符</li>
<li>引用数据类型（数组、字符串、类和接口）数组元素的默认值为：Null –&gt; 此处是null关键字，代表的是空对象。</li>
</ul>
<hr>
<h4 id="数组元素的遍历"><a href="#数组元素的遍历" class="headerlink" title="数组元素的遍历"></a>数组元素的遍历</h4><ol>
<li><p>使用普通for循环来实现</p>
<ul>
<li>思路：通过普通for循环，获得[0, 数组长度-1]的合法索引取值，然后再通过索引获得数组元素</li>
<li>优势：遍历的过程中，可以获得数组的合法索引值，因此遍历过程中我们可以操作数组中的元素。</li>
<li>劣势：语法复杂，效率较低。</li>
<li>使用场合：遍历数组的过程中，如果想要获得数组的合法索引取值，或者想要在遍历过程中操作数组元素，则“必须”通过普通for循环来实现。</li>
</ul>
</li>
<li><p><strong>使用增强for循环来实现</strong></p>
<ul>
<li><p>语法：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*
for(数据类型 变量名 : 数组或集合){
    //循环体
}
*/</span>

<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//增强for循环</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> element <span class="token operator">:</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span>
   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>优势：语法简洁，效率较高。</p>
</li>
<li><p><strong>劣势：遍历的过程中，不能获得数组的合法索引值，因此遍历过程中我们无法操作数组中的元素。</strong></p>
</li>
<li><p>使用场合：遍历数组的过程中，如果<strong>无需获得数组的合法索引取值</strong>，也就是遍历数组过程中<strong>无需操作数组元素，</strong>则建议通过增强for循环来实现。</p>
</li>
<li><p><strong>快速使用增强for循环来遍历数组：数组名.for + enter</strong></p>
</li>
<li><p><strong>强调：通过length属性获得数组空间长度，则该操作的效率是非常低，因此在循环中切记不要使用length属性来获得数组空间长度。</strong></p>
</li>
<li><p><strong>建议定义一个数组长度变量来循环。</strong></p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="栈内存的概述"><a href="#栈内存的概述" class="headerlink" title="栈内存的概述"></a>栈内存的概述</h4><ul>
<li><p>存储：局部变量</p>
<p>–&gt; “基本数据类型”的局部变量，则在栈内存中存储的是”数据值”。</p>
<p>–&gt; “引用数据类型”的局部变量，则在栈内存中存储的是”地址值”。</p>
<p>特点：</p>
<ul>
<li>栈内存具备”先进后出”或”后进先出”的特点，类似于生活中的”子弹夹”。</li>
<li>栈内存是一块连续的存储空间，由虚拟机分配，效率高！</li>
<li>栈内存由虚拟机来管理，也就是无需程序员来手动管理内存。</li>
<li>虚拟机会为每个线程创建一个栈内存，用于存放该线程执行方法的信息。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="堆内存的概述"><a href="#堆内存的概述" class="headerlink" title="堆内存的概述"></a>堆内存的概述</h4><p>存储：对象（数组）</p>
<p>特点：</p>
<ul>
<li>堆内存不是一块连续的存储空间，分配灵活，但是效率低。</li>
<li>堆内存理论上需要程序员来手动管理，但是实际上交由”垃圾回收机制”来管理。</li>
<li><strong>虚拟机中只有一个堆内存，被所有的线程共享。</strong></li>
</ul>
<hr>
<h4 id="直接输出一个数组，则输出内容是什么？"><a href="#直接输出一个数组，则输出内容是什么？" class="headerlink" title="直接输出一个数组，则输出内容是什么？"></a>直接输出一个数组，则输出内容是什么？</h4><p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//输出：[I@4554617c</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>分析：”[I@4554617c”表示的含义是什么？</p>
<ul>
<li>[ –&gt; 代表数组类型；</li>
<li>I –&gt; 代表数组元素为int类型</li>
<li>@之后 –&gt; 代表哈希编码之后的6进制地址值（简称：地址值）</li>
</ul>
<p>注意：此处 “ [I “ 代表的就是int类型的数组。</p>
<p>问题：<strong>想要输出数组中的所有元素，则该如何实现？</strong></p>
<ul>
<li>必须遍历数组来实现，而不能直接输出该数组（地址值）。</li>
</ul>
<p><img src="https://cherish779.github.io/images/note_images/%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%9801.png" alt="img"></p>
<p>eg1：</p>
<p><img src="https://cherish779.github.io/images/note_images/%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%9802.png" alt="img"></p>
<p>eg2:</p>
<p><img src="https://cherish779.github.io/images/note_images/%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%9803.png" alt="img"></p>
<hr>
<h4 id="目前已经见过的异常有哪些？"><a href="#目前已经见过的异常有哪些？" class="headerlink" title="目前已经见过的异常有哪些？"></a>目前已经见过的异常有哪些？</h4><ol>
<li>算数异常（ArithmeticException）<ul>
<li>原因：做除法操作的时候，如果分母为零，则就会抛出算数异常。</li>
</ul>
</li>
<li>数组索引越界异常（ArrayIndexOutOfBoundsException）<ul>
<li>原因：根据索引操作数组元素的时候，如果操作的索引值越界，则就会抛出数组索引越界异常。</li>
</ul>
</li>
<li>空指针异常（NullPointerException）<ul>
<li>原因：我们对空对象做操作，则就会抛出空指针异常。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="调用方法时，实参传递给形参的过程-超级重点"><a href="#调用方法时，实参传递给形参的过程-超级重点" class="headerlink" title="调用方法时，实参传递给形参的过程(超级重点)"></a>调用方法时，实参传递给形参的过程(超级重点)</h4><ol>
<li><p><strong>调用方法时，基本数据类型的传递</strong></p>
<ul>
<li>结论：”基本数据类型”的传递，属于”数据值”的传递。</li>
<li>解释：”实参”赋值给”形参”之后，则”实参”和”形参”就没有任何联系了，我们在方法中修改”形参”的值，则”实参”的值不会改变。</li>
</ul>
<p><img src="https://cherish779.github.io/images/note_images/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E9%80%92.png" alt="img"></p>
</li>
<li><p><strong>调用方法时，引用数据类型的传递</strong></p>
<ul>
<li><strong>结论：”引用数据类型”的传递，属于”地址值”的传递。</strong></li>
<li>解释：”实参”赋值给”形参”之后，则”实参”和”形参”保存的地址值就相同，也就意味着”实参”和”形参”指向了同一块存储空间，<strong>我们在方法中修改”形参”指向存储空间的数据，则”实参”指向该存储空间的数据也被修改了。</strong></li>
</ul>
<p><img src="https://cherish779.github.io/images/note_images/%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BC%A0%E9%80%92.png" alt="img"></p>
</li>
</ol>
<hr>
<h4 id="数组例题："><a href="#数组例题：" class="headerlink" title="数组例题："></a>数组例题：</h4><p><img src="https://cherish779.github.io/images/note_images/%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC.png" alt="img"></p>
<p><img src="https://cherish779.github.io/images/note_images/%E8%8E%B7%E5%8F%96%E6%8C%87%E5%AE%9A%E5%85%83%E7%B4%A0%E7%B4%A2%E5%BC%95.png" alt="img"></p>
<hr>
<h3 id="DAY10"><a href="#DAY10" class="headerlink" title="DAY10"></a>DAY10</h3><h4 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h4><p>需求：将数组元素反转，原数组{5, 12, 54,7676,9}，反转后为：{9, 676, 54, 12, 5}。</p>
<p>要求：使用两种方式来实现</p>
<ol>
<li><p>方式一：<strong>创建一个新的数组，用于保存反转之后的结果。</strong></p>
<ul>
<li>缺点：<ul>
<li>需要创建新的数组，浪费了存储空间。</li>
<li>需要完整遍历整个数组，浪费了执行时间。</li>
</ul>
</li>
</ul>
</li>
<li><p>方式二：<strong>使用“首尾元素交换位置”的思路来实现。</strong></p>
<ul>
<li><p>优点：</p>
<ul>
<li>无需创建新的数组，节约了存储空间。</li>
<li>只需遍历数组长度的一半，节约了执行时间。</li>
</ul>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>length <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    arr<span class="token punctuation">[</span>length <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">-</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ol>
<p><img src="https://cherish779.github.io/images/note_images/%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%8F%8D%E8%BD%AC.png" alt="img"></p>
<hr>
<h4 id="什么是静态方法"><a href="#什么是静态方法" class="headerlink" title="什么是静态方法"></a>什么是静态方法</h4><ul>
<li>使用static关键字修饰的方法，我们就称之为“静态方法”。</li>
</ul>
<p>静态方法的调用：</p>
<ul>
<li><p>情况一：调用“当前类”的静态方法</p>
<p>–&gt; 语法：方法名（实参列表）；</p>
</li>
<li><p>情况二：调用“别的类”的静态方法</p>
<p>–&gt; 语法：类名.方法名(实参列表);</p>
</li>
</ul>
<hr>
<h4 id="数组工具类"><a href="#数组工具类" class="headerlink" title="数组工具类"></a>数组工具类</h4><ul>
<li>问题：在前面的学习中，我们把操作数组的静态方法放到了不同的类中，因此想要调用这些静态方法的时候，我们首先得明确该方法在那个类中，然后才能通过“类名”来调用这些静态方法，因此调用这些方法的时候非常不方便。</li>
<li>解决：定义一个“数组工具类”，然后把操作数组的静态方法都放到该“数组工具类”中。</li>
</ul>
<ol>
<li><p>Arrays工具类的概述</p>
<ul>
<li>Arrays工具类在”java.util”包中，因此我们使用Arrays工具类的时候，必须通过import关键字导入Arrays类，然后才能使用Arrays工具类。</li>
<li>Arrays工具类我们称之为“数组相关的工具类”，在Arrays类中提供了很多操作数组的“静态方法”，因此我们调用这些方法的时候，直接通过类名.来调用。</li>
</ul>
</li>
<li><p>Arrays工具类的方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> statci String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//作用：把数组转换为字符串并返回，也就是获得数组中的元素，然后把这些元素拼接成字符串并返回。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//作用：数组的填充操作，把arr数组中的所有元素设置为val</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//作用：给数组元素执行“排序”操作，默认为“升序”排序</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>注意：关于数组的排序算法，我们后面会学习(冒泡排序和选择排序)</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//作用：对“指定范围”的数组元素执行“升序”排序</span>
<span class="token comment" spellcheck="true">//范围：从fromIndex索引位置开始（包含），到toIndex索引位置结束（不包含）。</span>
<span class="token comment" spellcheck="true">//注意：fromIndex取值范围在[0,数组长度-1]之间，toIndex取值范围在[0,数组长度]之间，并且必须满足toIndex大于fromIndex</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/*
    作用：二分查找，查询key在arr数组中的索引位置。
    返回值：如果查询元素在数组中存在，则返回该元素在数组中的索引位置；如果查询的元素在数组中不存在，则返回负数即可。
*/</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/*
    作用：对“指定范围”的数组元素执行二分查找操作，此处要求arr数组为升序排序。
    范围；从fromIndex索引位置开始（包含），到toIndex索引位置结束（不包含）。
    注意：fromIndex取值范围在[0, 数组长度-1]，toIndex取值范围在[0,数组长度]之间，并且必须满足toIndex大于fromIndex。
    返回值：如果查询元素在数组中存在，则返回该元素在数组中的索引位置；如果查询的元素在数组中不存在，则返回负数即可。
*/</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> newLength<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/*
    作用：从索引为0的位置开始拷贝，一共拷贝newLength个数组元素并返回。
    注意：此处newLength取值范围在[0,数组长度]之间。
*/</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">Public <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOfRange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> to<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/*
    作用：拷贝指定索引范围的数组元素
    范围：从from索引位置开始（包含），到to索引位置结束（不包含）。
    注意：from取值范围在[0,数组长度 - 1]之间，to取值范围在[0,数组长度]之间，并且必须满足to大于from
*/</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p><img src="https://cherish779.github.io/images/note_images/copyOfRange.png" alt="img"></p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">/*
    作用：判断arr1和arr2两个数组是否相等。
    返回值：如果arr1和arr2的地址值相等或arr1和arr2的数组元素一一对应，则都返回true，否则一律返回false。
*/</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>3.什么是数组拷贝？</p>
<ul>
<li><strong>把A数组中的元素拷贝进入B数组中，则我们修改A数组的元素，那么B数组中的元素不会被修改，这就是数组的拷贝操作。</strong></li>
</ul>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//需求：把arr1数组前3个元素拷贝进入arr2数组中</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">,</span><span class="token number">44</span><span class="token punctuation">,</span><span class="token number">55</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>arr2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//输出：[11,22,33]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>问题：查询某个元素在数组中的索引位置，则实现方案有哪些？</strong></p>
<ul>
<li><p><strong>方式一：顺序查找（线性查找）</strong></p>
<p>–&gt; 优点：对数组元素是否排序没有要求！</p>
<p>–&gt; 缺点：查询效率非常低！</p>
</li>
<li><p><strong>方式二：二分查找（折半查找）</strong></p>
<p>–&gt; 优点：查询效率非常高</p>
<p>–&gt; 缺点：要求数组元素必须排序，默认为升序排序。</p>
</li>
</ul>
<hr>
<h4 id="方法的可变参数（掌握）"><a href="#方法的可变参数（掌握）" class="headerlink" title="方法的可变参数（掌握）"></a>方法的可变参数（掌握）</h4><p>1、可变参数的引入</p>
<ul>
<li><p>需求：定义一个方法，用于获得指定两个int类型数据之和。</p>
</li>
<li><p>实现：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>需求：定义一个方法，用于获得任意多个int类型数据之和（至少有两个int类型的数据）</strong></p>
</li>
<li><p>实现1：使用“方法的重载”来实现。</p>
<p>–&gt; 理论上没有问题，但是实际操作有问题。</p>
</li>
<li><p>实现2：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>–&gt;使用“数组”来实现虽然可行，但是不太符合题意。</p>
</li>
<li><p>实现3：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>–&gt; 使用“方法的可变参数”来实现，该方式是最优的解决方案。</p>
</li>
</ul>
<hr>
<h4 id="可变参数的语法"><a href="#可变参数的语法" class="headerlink" title="可变参数的语法"></a>可变参数的语法</h4><ul>
<li>语法：数据类型 … 可变参数名</li>
<li>eg：int … arr</li>
</ul>
<p><strong>可变参数的注意点</strong></p>
<ul>
<li><p>“可变参数”必须存在于“形参列表”中，并且“可变参数”必须在形参列表“最末尾”。</p>
<p>–&gt; 也就是说，方法的形参列表中最多只能定义一个可变参数（0或1）</p>
</li>
<li><p>在方法体中，我们可以把可变参数当成“数组”来使用，本质上可变参数就是数组的另外一种语法表现形式。</p>
<p>–&gt; eg：调用方法的是，实参为”int类型的数组”，则方法的形参可以为“int类型的可变参数”。</p>
<p>–&gt;调用方法：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>–&gt; 声明方法：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> in <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>eg:在同个类中，以下两个同名的方法发生了编译错误，因为这两个方法没有构成方法的重载！</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>调用拥有可变参数的方法时，则实参和形参的“个数”不必相同，但是实参和形参的“类型”必须相同。</p>
</li>
</ul>
<p><strong>可变参数的使用场合</strong></p>
<ul>
<li>定义一个方法的时候，参数的类型都相同，但是参数的个数不确定时。</li>
</ul>
<hr>
<h4 id="数组的核心特点"><a href="#数组的核心特点" class="headerlink" title="数组的核心特点"></a>数组的核心特点</h4><ul>
<li>数组是一块连续的存储空间，则意味着相邻两个元素的存储空间是紧挨着的。</li>
<li>数组存储的是相同数据类型的元素，则意味着每个元素占用的字节数相同。</li>
<li>常见数组则必须明确数组的空间长度，数组一旦创建成功，则数组的空间长度就不能改变。</li>
</ul>
<ol>
<li><p><strong>根据索引操作【该和查】</strong></p>
<ul>
<li><p>结论：根据索引操作元素效率非常高，甚至是所有数据结构中效率最高的。</p>
</li>
<li><p>依据：数组是一块连续的存储空间，则意味着相邻两个元素的存储空间是紧挨着。</p>
<p>–&gt; 数组存储的是相同数据类型的元素，则意味着每个元素占用的字节数相同。</p>
<p>–&gt; <strong>寻址公式：首地址 + 索引值 * 每个元素占用的字节数</strong></p>
<p><img src="https://cherish779.github.io/images/note_images/%E5%AF%BB%E5%9D%80%E5%85%AC%E5%BC%8F.png" alt="img"></p>
</li>
</ul>
</li>
<li><p><strong>根据索引删除元素【删】</strong></p>
<ul>
<li><p>结论：根据索引删除元素的效率非常低，因为需要大量的挪动数组元素。</p>
</li>
<li><p>依据：数组是一块连续的存储空间，则意味着相邻两个元素的存储空间是紧挨着。</p>
<p>–&gt; 常见数组则必须明确数组的空间长度，数组一旦创建成功，则数组的空间长度就不能改变了。</p>
</li>
</ul>
<p><img src="https://cherish779.github.io/images/note_images/%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0.png" alt="img"></p>
</li>
<li><p><strong>根据索引插入元素【增】</strong></p>
<ul>
<li><p>结论：根据索引插入元素的效率非常低，因为需要大量挪动数组元素+扩容操作。</p>
</li>
<li><p>依据：数组时一块连续的存储空间，则意味着相邻两个元素的存储空间时紧挨着。</p>
<p>–&gt; 常见数组则必须明确数组的空间长度，数组一旦创建成功，则数组的空间长度就不能改变啦。</p>
</li>
</ul>
</li>
</ol>
<p><img src="https://cherish779.github.io/images/note_images/%E6%95%B0%E7%BB%84%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0%E6%A0%88%E4%B8%8E%E5%A0%86%E7%9A%84%E5%8F%98%E5%8C%96.png" alt="img"></p>
<hr>
<h3 id="DAY11"><a href="#DAY11" class="headerlink" title="DAY11"></a>DAY11</h3><h4 id="二维数组（矩阵，很难，了解）"><a href="#二维数组（矩阵，很难，了解）" class="headerlink" title="二维数组（矩阵，很难，了解）"></a>二维数组（矩阵，很难，了解）</h4><ol>
<li><p>二维数组的定义</p>
<ul>
<li><p>数组中的每个元素都是一堆数组，这样的数组我们就称之为“二维数组”。</p>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>二维数组的声明</p>
<ul>
<li><p>明确：所谓二维数组的声明，指的就是给二维数组取一个名字，类似于“变量的声明”。</p>
</li>
<li><p>语法1：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//数据类型[][] 数组名；</span>
<span class="token comment" spellcheck="true">//int[][] arr1;</span>
<span class="token comment" spellcheck="true">//String[][] arr2;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>语法2：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//数据类型[] 数组名[];</span>
<span class="token comment" spellcheck="true">//int[] arr1[]</span>
<span class="token comment" spellcheck="true">//String[] arr2[]</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>注意：实际开发中，我们建议使用”语法1”来声明二维数组，因为“数据类型 [ ] [ ] ”代表的是“二维数组类型”。</p>
</li>
</ul>
</li>
<li><p>二维数组的创建</p>
<ul>
<li><p>明确：所谓二维数组的创建，指的就是在堆内存中为二维数组开辟存储空间。</p>
</li>
<li><p><strong>方式一：创建“等长”的二维数组（动态）</strong></p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//语法：数据类型[][] 数组名 = new 数据类型[m][n];</span>
<span class="token comment" spellcheck="true">// m: 设置二维数组得空间长度</span>
<span class="token comment" spellcheck="true">//n：设置一维数组的空间长度</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cherish779.github.io/images/note_images/%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%AD%89%E9%95%BF%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84.png" alt="img"></p>
</li>
<li><p><strong>方式二：创建“不等长”的二维数组（动态）</strong></p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//语法：数据类型[][] 数组名 = new 数据类型[m][];</span>
<span class="token comment" spellcheck="true">//m:设置二维数组的空间长度</span>
<span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cherish779.github.io/images/note_images/%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%B8%8D%E7%AD%89%E9%95%BF%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84.png" alt="img"></p>
</li>
<li><p><strong>方式三：静态创建的二维数组（静态）(等长|不等长)</strong></p>
<p>–&gt; 语法1：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//数据类型[][] 数组名 = {{数据1,数据2}, {数据3,数据4},...}</span>
          <span class="token comment" spellcheck="true">//int[][] arr1 = {{11,22,33},{55,66,77},{13,56,78}};</span>
<span class="token comment" spellcheck="true">//String[][] arr2 = {{"aa","bb"},{"cc","dd","yt"}};</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>–&gt;语法2：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//数据类型[][] 数组名 = new 数据类型[][]{{数据1,数据2}, {数据3,数据4},...};</span>
          <span class="token comment" spellcheck="true">////int[][] arr1 = new int[][]{{11,22,33},{55,66,77},{13,56,78}};</span>
<span class="token comment" spellcheck="true">//String[][] arr2 = new String[][]{{"aa","bb"},{"cc","dd","yt"}};</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>注意：通过大括号创建出来的二维数组，我们无法直接作为方法的”实参”和”返回值”，因为编译器不认识大括号创建的二维数组。</strong></p>
</li>
</ul>
</li>
</ol>
<p><img src="https://cherish779.github.io/images/note_images/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%8401.png" alt="img"></p>
<hr>
<h4 id="断点调试（debug调试，重点）"><a href="#断点调试（debug调试，重点）" class="headerlink" title="断点调试（debug调试，重点）"></a>断点调试（debug调试，重点）</h4><ol>
<li><p><strong>debug调试的作用</strong></p>
<ul>
<li>查看代码的执行顺序，分析变量值的变化，从而找到问题的并解决问题。</li>
</ul>
</li>
<li><p><strong>debug的调试步骤</strong></p>
<ul>
<li><p>第一步：在代码可能出现问题的位置，我们在该位置打一个断点。</p>
<p>–&gt; 在该代码行号左侧位置，我们单击打一个断点（红色圆圈）</p>
</li>
<li><p>第二步：开启debug调试来执行程序，则代码就会停留在打断点的位置。</p>
<p>–&gt;方式一： 点击类名或main方法左侧绿色按钮，然后选中”Debug Xxx.main()”即可。</p>
<p>–&gt; 方式二：在代码编辑区域，我们鼠标右键然后选中”Debug Xxx.main()”即可。</p>
<p>–&gt; 方式三：已经执行程序后，我们点击工具栏或控制台左侧的”debug按钮”。</p>
</li>
<li><p>明确：开启debug调试之后，则就会出现debug窗口，debug窗口的作用如下：</p>
<p><strong>Debugger</strong></p>
<ul>
<li>Frames：显示代码停留的位置（包、类、方法和行号）</li>
<li>Variables：显示当前方法已经执行过的变量的值</li>
</ul>
<p><strong>Console</strong></p>
<ul>
<li>显示输出的内容或获取输入的内容。</li>
</ul>
</li>
<li><p>第三步：控制代码的执行，也就是通过Debug窗口来控制代码的执行。</p>
<ol>
<li>F8：执行下一行代码。</li>
<li>F7：进入执行方法体中的代码。</li>
<li>shift + F8：结束当前方法，回到方法的调用位置。</li>
<li>Alt + F9：直接执行到下一个断点的位置。</li>
<li>Alt + F8：计算并执行某行未执行代码的运算结果。</li>
</ol>
</li>
<li><p>第四步：结束debug调试。</p>
<p>首先，取消断点（单击取消）；然后，结束程序（点击红色按钮）；最后，关闭debug窗口。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h4><ul>
<li><p>封装（堆功能method的封装）</p>
</li>
<li><p>典型：c语言</p>
</li>
<li><p>特点：以线性的思维来思考解决问题，强调一步一步的实现。</p>
<p>–&gt; 强调程序员是一个“实施者”，类似于公司中的“小职员”。</p>
</li>
<li><p><strong>优点：效率高。</strong></p>
</li>
<li><p><strong>缺点：程序的复用性、可维护性和可扩展性较低</strong>。</p>
</li>
<li><p>使用场合：适用于“小型”的程序，例如：计算器、嵌入式开发等等</p>
</li>
</ul>
<hr>
<h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul>
<li><p>封装（对数据field和功能method做的封装）、继承和多态。</p>
</li>
<li><p>典型：C++、C#、java等。</p>
</li>
<li><p>特点：以非线性的思维来思考解决问题，强调宏观上的把控。</p>
<p>–&gt; 强调程序员是一个“指挥官”，类似于公司中的“小老板”。</p>
</li>
<li><p><strong>优点：程序的复用性、可维护性和可扩展性较高。</strong></p>
</li>
<li><p><strong>缺点：效率低。</strong></p>
</li>
<li><p>使用场合：适用于“大型”的程序，例如：京东、淘宝、微信等等。</p>
</li>
</ul>
<hr>
<h4 id="面向对象编程的特点"><a href="#面向对象编程的特点" class="headerlink" title="面向对象编程的特点"></a>面向对象编程的特点</h4><ul>
<li><strong>宏观</strong>上采用面向对象的思维来把控，<strong>微观</strong>实施上依旧采用的是面向过程，即<strong>：面向对象中包含了面向过程。</strong></li>
</ul>
<hr>
<h4 id="类和对象（理解）"><a href="#类和对象（理解）" class="headerlink" title="类和对象（理解）"></a>类和对象（理解）</h4><ol>
<li><p>对象（instance）</p>
<ul>
<li>从编程的角度来理解：万物皆对象。</li>
<li>eg：教室里面的每个学生、每个凳子、每张椅子。。。</li>
<li><strong>每个对象都是“独一无二”的，类似于每个同学都是“独一无二”的。</strong></li>
</ul>
</li>
<li><p>类（class）</p>
<ul>
<li>从编程的角度来理解：类就是对一类事物的抽象，抽象就是提取这一类事物的共同属性和行为，这样就形成了类。</li>
<li>eg:班上的每个同学都有姓名、年龄和成绩等属性，每个同学都有吃饭、睡觉和学习等行为，则我们对班上的同学进行向上提取，那么就得到了学生类。</li>
</ul>
</li>
<li><p>类和对象</p>
<ul>
<li><p>从编程的角度来分析：我们以类为模板，然后实例化出对象。</p>
<p>–&gt; <strong>先有类，后有对象。</strong></p>
<p>–&gt; <strong>类是对象的模板，对象是类的实例。</strong></p>
<p>eg：我们以小汽车图纸（类）为模板，然后生产出一辆一辆的小汽车（对象）。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="如何定义类"><a href="#如何定义类" class="headerlink" title="如何定义类"></a>如何定义类</h4><p>语法：[修饰类] class类名{ &#x2F;&#x2F;书写的代码 }</p>
<p>注意：</p>
<ul>
<li>使用class关键字修饰的就是类，也就是类必须使用class来修饰。</li>
<li><strong>类名必须满足“标识符”的命名规则，必须满足“大驼峰”的命名规范，并且最好“见名知意”。</strong></li>
<li>使用“public”关键字修饰的类，则类名必须和源文件名字保持一致，否则就会出现编译错误。</li>
</ul>
<hr>
<h4 id="类中的组成"><a href="#类中的组成" class="headerlink" title="类中的组成"></a>类中的组成</h4><ul>
<li>数据（属性），我们使用“变量”来存储类中封装的数据，类中的变量有：<ol>
<li>成员变量：又称之为“实例变量”或“非静态变量”，因为是从属于“对象”的。</li>
<li>静态变量：又称之为“类变量”，从属于“类”的。</li>
</ol>
</li>
<li>功能（行为），我们使用“方法”来封装类中的功能。<ol>
<li>成员方法，又称之为“实例方法”或“非静态方法”，从属于“对象”的。</li>
<li>静态方法，又称之为“类方法”，从属于“类”的。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="成员变量的概述"><a href="#成员变量的概述" class="headerlink" title="成员变量的概述"></a>成员变量的概述</h4><ul>
<li><p><strong>定义位置：在类中，代码块和方法体之外。</strong></p>
</li>
<li><p>定义语法：[修饰符] 数据类型 变量名；</p>
<p>–&gt;定义成员变量的时候，则不允许使用static关键字来修饰。</p>
</li>
<li><p>操作成员变量的语法：对象.成员变量名</p>
<p>–&gt; 通过 “对象.成员变量名” 就能找到该成员变量的存储空间，然后就能对该成员变量取值和赋值的操作。</p>
<p>–&gt; 在成员方法中，想要操作当前类的成员变量，则我们可以直接通过“成员变量名”来操作。</p>
</li>
</ul>
<hr>
<h4 id="成员方法的概述"><a href="#成员方法的概述" class="headerlink" title="成员方法的概述"></a>成员方法的概述</h4><ul>
<li><p>定义位置：在类中，代码块和方法体之外。</p>
</li>
<li><p>定义语法：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token comment" spellcheck="true">//方法体</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>返回值<span class="token punctuation">]</span>；
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>–&gt; 定义成员方法的时候，则不允许使用static关键字来修饰。</p>
<p><strong>调用成员方法的语法：对象.成员变量名(实参列表);</strong></p>
<p> –&gt; 注意：<strong>在成员方法中，想要调用当前类的成员方法，则我们可以直接通过“成员变量名(实参列表);”来实现。</strong></p>
</li>
</ul>
<hr>
<h4 id="实例化对象的概述"><a href="#实例化对象的概述" class="headerlink" title="实例化对象的概述"></a>实例化对象的概述</h4><ul>
<li><p>语法：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">类型 对象 <span class="token operator">=</span> <span class="token keyword">new</span> 类名<span class="token punctuation">(</span>实参列表<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//eg:</span>
Student stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Scanner input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>理解：我们以类为模板，然后实例化对象。</p>
</li>
</ul>
<hr>
<h4 id="成员变量的默认值"><a href="#成员变量的默认值" class="headerlink" title="成员变量的默认值"></a>成员变量的默认值</h4><ul>
<li>明确：“成员变量”和“数组元素”都有默认值，并且默认值规则一样。</li>
<li>整数型（byte、short、int和long）成员变量的默认值为：0；</li>
<li>浮点型（float和double）成员变量的默认值为：0.0;</li>
<li>布尔型（boolean）成员变量的默认值为：false；</li>
<li>字符型（char）成员变量的默认值为：’\u0000’ –&gt; 代表的是空格字符</li>
<li>引用数据类型（数组、字符串、类和接口等等）成员变量的默认值为：null</li>
</ul>
<hr>
<h4 id="成员变量的初始化"><a href="#成员变量的初始化" class="headerlink" title="成员变量的初始化"></a>成员变量的初始化</h4><ul>
<li><strong>最先执行“默认初始化”，然后执行“显示初始化”，最后执行“指定初始化”。</strong></li>
</ul>
<hr>
<h4 id="创建对象时的内存分析"><a href="#创建对象时的内存分析" class="headerlink" title="创建对象时的内存分析"></a>创建对象时的内存分析</h4><ul>
<li><strong>结论：</strong>以类为模板来创建对象，则只需要为类中的成员变量在堆内存中开辟存储空间，<strong>而成员方法是调用的时候自动在栈内存中开辟栈帧。</strong></li>
<li><strong>注意：</strong>每个对象都是“独一无二”的，<strong>因为每次创建对象都会在堆内存中开辟存储空间。</strong></li>
</ul>
<p><img src="https://cherish779.github.io/images/note_images/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png" alt="img"></p>
<hr>
<h4 id="成员变量和局部变量的对比"><a href="#成员变量和局部变量的对比" class="headerlink" title="成员变量和局部变量的对比"></a>成员变量和局部变量的对比</h4><ol>
<li>定义位置区别<ul>
<li>成员变量：在类中，代码块和方法体之外。</li>
<li>局部变量：在类中，代码块或方法体之内。</li>
</ul>
</li>
<li>存储位置区别<ul>
<li>成员变量：存储在“堆内存”中。</li>
<li>局部变量：存储在“栈内存”中。</li>
</ul>
</li>
<li>生命周期区别<ul>
<li>成员变量：随着对象的创建而“出生”，随着对象的销毁而“死亡”。</li>
<li>局部变量：定义变量的时候“出生”，所在作用域执行完毕就“死亡”。</li>
</ul>
</li>
<li>默认值的区别<ul>
<li>成员变量：成员变量有默认值，并且默认值规则和数组元素默认值规则一模一样。</li>
<li>局部变量：局部变量没有默认值，因为只声明未赋值的局部变量，则不能做取值操作。</li>
</ul>
</li>
<li>修饰符的区别<ul>
<li>成员变量：可以被public、protected、private、static、final等修饰符修饰。</li>
<li>局部变量不能被public、protected、private、static修饰，只能被final修饰。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="成员变量和局部变量的使用"><a href="#成员变量和局部变量的使用" class="headerlink" title="成员变量和局部变量的使用"></a>成员变量和局部变量的使用</h4><ul>
<li><p>明确：当成员变量和局部变量同名的时候，则默认采用的是“就近原则”，也就是“谁离的近，就执行谁”。</p>
</li>
<li><p>问题：当成员变量和局部变量同名的时候，我们该如何区分？</p>
</li>
<li><p>解决：局部变量采用“就近原则”来区分，成员变量使用“this”关键字来区分。</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"局部变量："</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"成员变量："</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ul>
<hr>
<h4 id="我们通过new关键字来创建对象，则创建出来的对象分为两种"><a href="#我们通过new关键字来创建对象，则创建出来的对象分为两种" class="headerlink" title="我们通过new关键字来创建对象，则创建出来的对象分为两种"></a>我们通过new关键字来创建对象，则创建出来的对象分为两种</h4><ol>
<li><p>匿名对象，指的就是“没有名字的对象”，例如：new Tiger();</p>
</li>
<li><p>非匿名对象，指的就是“有名字的对象”，例如：Tiger tiger &#x3D; new Tiger();</p>
</li>
<li><p>开发中，匿名对象很少使用，但是以下两种场合建议使用匿名对象来实现。</p>
<ul>
<li><p>创建出来的对象，仅仅只调用一次成员方法，则该对象就建议使用匿名对象来实现。</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">Tiger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token string">"XXX"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>创建出来的对象，仅仅只作为方法的实参，则该对象就建议使用匿名对象来实现。</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token function">show</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Tiger</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
<p><img src="https://cherish779.github.io/images/note_images/%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1.png" alt="img"></p>
</li>
</ol>
<hr>
<h3 id="DAY12"><a href="#DAY12" class="headerlink" title="DAY12"></a>DAY12</h3><h4 id="构造方法（构造器或构造函数）"><a href="#构造方法（构造器或构造函数）" class="headerlink" title="构造方法（构造器或构造函数）"></a>构造方法（构造器或构造函数）</h4><ol>
<li><p>构造方法的引入</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">Student stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Scanner input <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>构造方法得语法</p>
<ul>
<li><p>语法:</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> 类名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//方法体</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>注意：【构造方法的特点】</strong></p>
<ol>
<li><p>构造方法中没有“返回值类型”，因为在构造方法中不允许有“返回值”。</p>
<p>–&gt; 构造方法中没有“返回值”，则构造方法中只有“return;”，那么我们就省略”return;”。</p>
</li>
<li><p>构造方法的名字必须为“类名”，也就是构造方法名采用”大驼峰”来命名。</p>
<p>–&gt; 构造方法名采用“大驼峰”，而成员方法名和静态方法名采用“小驼峰”。</p>
</li>
<li><p>构造方法就是一个“特殊”的方法，并且构造方法应该通过new关键字来调用。</p>
</li>
<li><p><strong>构造方法专门给成员变量做初始化，也就是构造方法不为静态变量做初始化。</strong></p>
</li>
<li><p>构造方法可以没有（默认一个无参构造方法），也可以有多个构造方法，他们之间构成重载关系。</p>
</li>
<li><p>如果定义有参构造方法，则无参构造方法被自动屏蔽。</p>
</li>
<li><p>构造方法不能被继承。</p>
</li>
<li><p>构造方法不能手动调用，在创建类实例的时候自动调用构造方法。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>创建对象的步骤</strong></p>
<p>分析“new Student();”的执行顺序，也就是分析创建对象的执行步骤：</p>
<ol>
<li>创建对象，并给成员变量开辟存储空间；</li>
<li>给成员变量做“默认初始化”；</li>
<li>给成员变量做“显式初始化”；</li>
<li>调用构造方法，给成员变量做“指定初始化”。</li>
</ol>
</li>
<li><p><strong>创建对象的时候，是谁来完成的呢？</strong></p>
<ul>
<li>new关键字负责创建对象，构造方法负责给成员变量做指定初始化操作，创建对象的时候new关键字和构造方法缺一不可。</li>
</ul>
</li>
<li><p><strong>构造方法的作用</strong></p>
<ol>
<li>创建对象的时候new关键字和构造方法缺一不可（了解）。</li>
<li><strong>通过构造方法来给成员变量做指定初始化操作，从而实现代码的复用【核心】。</strong></li>
</ol>
</li>
<li><p><strong>无参构造方法的概述</strong></p>
<ul>
<li>作用：用于给成员变量做初始化操作，例如在无参构造方法中给int类型数组做开辟存储空间的操作。</li>
<li>注意：<strong>如果某个类中没有显式地提供构造方法，则程序编译时会默认为这个类提供一个无参构造方法。</strong></li>
</ul>
</li>
<li><p><strong>有参构造方法的概述</strong></p>
<ul>
<li>作用：用于给成员变量做初始化操作，例如<strong>在有参构造方法中我们将形参的值赋值给成员变量来保存。</strong></li>
<li>注意：<ol>
<li>建议形参的名字和成员变量名保持一致，然后在构造方法中通过this来操作成员变量。</li>
<li>如果一个类显式地提供了构造方法，则程序编译时就不会为该类提供默认的无参构造方法了。</li>
<li>建议每个类都应该提供无参构造方法，避免在继承体系中子类找不到父类的无参构造方法。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>构造方法的重载</strong></p>
<ul>
<li>构造方法依旧可以实现方法的重载，<strong>调用构造方法的时候会根据实参的“个数”和“类型”来选中调用合适的构造方法。</strong></li>
</ul>
</li>
</ol>
<hr>
<h4 id="成员方法和构造方法的对比"><a href="#成员方法和构造方法的对比" class="headerlink" title="成员方法和构造方法的对比"></a>成员方法和构造方法的对比</h4><ol>
<li><p>定义语法区别</p>
<ul>
<li>成员方法：</li>
</ul>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//方法体</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>返回值<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>构造方法：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> 类名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//方法体</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>调用方式区别</p>
<ul>
<li>成员方法：必须通过“对象”来调用；</li>
<li>构造方法：必须通过“new”关键字来调用；</li>
</ul>
</li>
<li><p>调用时期区别</p>
<ul>
<li>成员方法：对象创建完毕后调用。</li>
<li><strong>构造方法：创建对象的时候调用。</strong></li>
</ul>
</li>
<li><p>调用次数区别</p>
<ul>
<li>成员方法：对象创建完毕后，我们可以调用任意多次成员方法（n）。</li>
<li>构造方法：<strong>构造方法只能调用一次，每次创建对象，则都会调用一次构造方法(1)。</strong></li>
</ul>
</li>
</ol>
<hr>
<h4 id="成员方法和构造方法的特点"><a href="#成员方法和构造方法的特点" class="headerlink" title="成员方法和构造方法的特点"></a>成员方法和构造方法的特点</h4><ul>
<li>执行到构造方法中，则此时对象肯定创建完毕，也就意味着构造方法有对象。</li>
<li>也就是说，成员方法和构造方法中都有对象，也就意味着成员方法和构造方法中都有this。</li>
</ul>
<hr>
<h4 id="this关键字（重点）"><a href="#this关键字（重点）" class="headerlink" title="this关键字（重点）"></a>this关键字（重点）</h4><ol>
<li><p><strong>this关键字的概述</strong></p>
<ul>
<li>创建一个对象成功之后，则<strong>虚拟机</strong>就会<strong>动态地创建一个引用</strong>，该引用<strong>指向的就是新创建出来的对象</strong>，并且该引用的名字就是this。</li>
</ul>
</li>
<li><p><strong>this关键字指的是什么？</strong></p>
<ul>
<li><p>在构造方法中，this指的是什么？</p>
<p><strong>在构造方法中，this指的是“新创建出来的对象”。</strong></p>
</li>
<li><p>在成员方法中，this指的是什么？</p>
<p>在成员方法中，this指的是“方法的调用者对象”。</p>
</li>
</ul>
</li>
<li><p><strong>this关键字的作用</strong></p>
<ol>
<li><p><strong>操作成员变量，语法：对象.成员变量名</strong></p>
<ul>
<li>如果成员变量和局部变量的名字相同，则我们必须通过this关键字来操作成员变量，使用就近原则来操作局部变量。</li>
<li>如果成员变量和局部变量的名字不同，则我们可以通过this关键字来操作成员变量，也可以忽略this关键字来操作成员变量。<ul>
<li>–&gt; 忽略this关键字来操作成员变量，则编译时会默认添加this关键字来操作。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>调用成员方法，语法：对象.成员变量名(实参列表);</strong></p>
<ul>
<li><p>调用当前类的别的成员方法时，我们可以通过this关键字来调用，也可以忽略this关键字来调用。</p>
<p>–&gt; 忽略this关键字来调用成员方法，则编译时会默认添加this关键字来操作。</p>
</li>
</ul>
</li>
<li><p><strong>调用构造方法，语法：this(实参列表);</strong></p>
<ul>
<li><p>作用：调用“当前类”的别的构造方法，此处仅仅调用方法并不创建对象，从而实现了代码的复用。</p>
</li>
<li><p>注意：</p>
<ol>
<li><p><strong>“this(实参列表)”只能存在于构造方法中，并且必须在构造方法有效代码的第一行。</strong></p>
<p>–&gt; “this(实参列表)”必须在构造方法有效代码的第一行，则意味着一个构造方法中最多只能有一个“this(实参列表)”。（0或1）</p>
</li>
<li><p><strong>构造方法切记不能“递归”调用，否则就会陷入死循环，从而造成程序编译错误！</strong></p>
<p>–&gt; 在构造方法中，我们不允许通过“this(实参列表)”来自己调用自己，否则就会编译错误！</p>
</li>
<li><p><strong>在一个类中，不可能所有的构造方法中都存在“this(实参列表)”,因为这样肯定会陷入死循环。</strong></p>
<p><strong>–&gt; 一个类中，可以定义多个构造方法，但是至少有一个构造方法中没有“this(实参列表)”。</strong></p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<hr>
<h4 id="静态变量（重点）"><a href="#静态变量（重点）" class="headerlink" title="静态变量（重点）"></a>静态变量（重点）</h4><ol>
<li><p>静态变量的引入</p>
<ul>
<li>需求：班上所有同学的姓名、年龄和成绩等属性，并且所有的学生都共享同一个教室和饮水机。</li>
<li>解决：定义一个Student类，然后在Student类中定义姓名、年龄、成绩、教室和饮水机等成员变量即可。</li>
</ul>
<p><img src="https://cherish779.github.io/images/note_images/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%BC%95%E5%85%A5.png" alt="img"></p>
<ul>
<li><p>问题：一个班有几十个同学，也就意味着需要创建几十个学生对象，每个学生对象都需要为classRoom开辟存储空间，并且每个对象存储的内容都相同，则浪费了存储空间。</p>
</li>
<li><p>解决：把姓名、年龄和成绩使用“成员变量”来保存；把教室和饮水机使用“静态变量”来存储。</p>
<p>–&gt; 如果存储的是“特有数据”，则就使用“成员变量”来存储，例如：姓名、年龄和成绩就属于学生特有数据，那么就使用成员变量来存储。</p>
<p>–&gt; 如果存储的是“共享数据”，则就使用“静态变量”来存储，例如：教室和饮水机就属于学生的共享数据，那么就使用静态变量来存储。</p>
</li>
</ul>
</li>
<li><p>静态变量的概述</p>
<ul>
<li><p>在类中，代码块和方法体之外，使用static关键字修饰的变量，我们就称之为“静态变量”。</p>
<p><img src="https://cherish779.github.io/images/note_images/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E6%A6%82%E8%BF%B0.png" alt="img"></p>
</li>
</ul>
</li>
<li><p><strong>类的加载过程分析</strong></p>
<ul>
<li><p>第一次使用某个类的时候，就会加载该类的信息进入方法区，如果该类中存在静态变量，则还会在方法区中为该静态变量开辟存储空间并设置默认值。</p>
</li>
<li><p><strong>问题1：什么时候执行加载类的操作呢？</strong></p>
<p>–&gt; 第一次使用某个类的时候，则就会执行加载类的操作。</p>
</li>
<li><p><strong>问题2：一个类会加载几次呢？</strong></p>
<p>–&gt; 每个类都只会加载一次，因为第一次使用某个类的时候就执行加载类的操作。</p>
</li>
<li><p><strong>问题3：什么是方法区？方法区存储的内容是什么？？</strong></p>
<p> <strong>–&gt; 方法区就是一块存储空间，并且方法区属于堆内存中的一部分，方法区用于存储类的信息、静态变量等等内容。</strong></p>
</li>
<li><p><strong>问题4：静态变量什么时候开辟存储空间呢？</strong></p>
<p>–&gt; 加载类的时候，则就会把该类中的静态变量在方法区中开辟存储空间，<strong>也就意味着静态变量优先于对象存在。</strong></p>
</li>
<li><p><strong>问题5：一个类中的静态变量，会开辟几次存储空间？</strong></p>
<p>–&gt; 因为类只会加载一次，<strong>因此每个类中的静态变量就只有一份，也就是每个静态变量只会开辟一次存储空间。</strong></p>
</li>
<li><p><strong>问题6：静态变量的默认值是什么？</strong></p>
<p>–&gt; 静态变量和成员变量都有默认值，并且他们的默认值规则一模一样。</p>
</li>
</ul>
</li>
<li><p><strong>静态变量的特点</strong></p>
<ol>
<li><p>静态变量优先于对象存在，随着类的加载就已经存在了。</p>
</li>
<li><p>一个类中，每个静态变量都只有一份，为类和对象所共享。</p>
</li>
<li><p>我们可以通过“类名”来操作静态变量，也可以通过“对象”来操作静态变量。</p>
<p><strong>语法1：类名.静态变量 –&gt; 建议</strong></p>
<p>语法2：对象.静态变量 –&gt; 不建议</p>
</li>
</ol>
</li>
</ol>
<hr>
<h4 id="成员变量和静态变量的对比"><a href="#成员变量和静态变量的对比" class="headerlink" title="成员变量和静态变量的对比"></a>成员变量和静态变量的对比</h4><ol>
<li>存储位置区别<ul>
<li>成员变量：存储在堆内存中。</li>
<li>静态变量：存储在方法区中。</li>
</ul>
</li>
<li>生命周期<ul>
<li>成员变量：随着对象的创建而“出生”，随着对象的销毁而”死亡”。</li>
<li>静态变量：随着类的加载而“出生”，随着程序执行完毕而“死亡”。</li>
</ul>
</li>
<li>创建次数的区别：<ul>
<li>成员变量：对象创建多少次，则成员变量就创建多少次。</li>
<li>静态变量：因为类只会加载一次，因次静态变量就只会创建一次。</li>
</ul>
</li>
<li>调用语法区别<ul>
<li>成员变量：必须通过”对象”来调用。</li>
<li>静态变量：可以通过“类名”来调用，也可以通过“对象”来调用。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="成员变量和静态变量的使用"><a href="#成员变量和静态变量的使用" class="headerlink" title="成员变量和静态变量的使用"></a>成员变量和静态变量的使用</h4><ul>
<li>成员变量：如果存储的是“特有数据”，则就使用成员变量来存储。</li>
<li>静态变量：如果存储的是“共享数据”，则就是用静态变量来存储。</li>
</ul>
<hr>
<h4 id="什么是静态方法-1"><a href="#什么是静态方法-1" class="headerlink" title="什么是静态方法"></a>什么是静态方法</h4><ul>
<li>使用static关键字修饰的方法，我们就称之为“静态方法”。</li>
</ul>
<hr>
<h4 id="静态方法的特点"><a href="#静态方法的特点" class="headerlink" title="静态方法的特点"></a>静态方法的特点</h4><ol>
<li>静态方法优先于对象存在，随着类的加载就已经存在了。</li>
<li>静态方法可以通过“对象”来调用，也可以通过“类名”来调用。<ul>
<li>语法1：类名.静态方法名(实参列表); –&gt; 建议</li>
<li>语法2：对象.静态方法名(实参列表); –&gt; 不建议</li>
</ul>
</li>
</ol>
<hr>
<h4 id="成员方法和静态方法的对比"><a href="#成员方法和静态方法的对比" class="headerlink" title="成员方法和静态方法的对比"></a>成员方法和静态方法的对比</h4><ol>
<li><p>操作变量的区别</p>
<ul>
<li><p>在成员方法和构造方法中，<strong>不但能直接操作当前类的静态变量，还能直接操作当前类的成员变量。</strong></p>
<p>–&gt; 在成员方法中，则意味着对象都创建完毕，也就是意味着肯定加载完毕，那么就能操作当前类的静态变量。</p>
</li>
<li><p><strong>在静态方法中，可以直接去操作当前类的静态变量，但是不能直接操作当前类的成员变量。</strong></p>
<p>–&gt; 在静态方法中，则意味着类已经加载完毕了，但是静态方法中还没有对象。</p>
</li>
</ul>
</li>
<li><p>调用方法的区别</p>
<ul>
<li><p>在成员方法和构造方法中，不但能直接调用当前类的静态方法，还能直接调用当前类的成员方法。</p>
<p>–&gt; 在成员方法中，则意味着对象都创建完毕，也就意味着类肯定加载完毕，那么就能调用当前类的静态方法。</p>
</li>
<li><p>在静态方法中，可以直接调用当前类的静态方法，但是不能直接调用当前类成员的方法。</p>
<p>–&gt; 在静态方法中，则意味着类已经加载完毕，但是静态方法中还没有对象。</p>
</li>
</ul>
</li>
<li><p>操作this的区别</p>
<ul>
<li>在成员方法和构造方法中，我们可以直接操作this关键字。</li>
<li>在静态方法中，我们不能直接操作this关键字。</li>
</ul>
</li>
</ol>
<p><strong>注意：操作“成员内容”的时候，默认省略的是“this”；操作“静态内容”的时候，默认省略的是“类名”。</strong></p>
<hr>
<h4 id="成员方法和静态方法的使用"><a href="#成员方法和静态方法的使用" class="headerlink" title="成员方法和静态方法的使用"></a>成员方法和静态方法的使用</h4><ul>
<li><p>成员方法：如果在方法体中，想要直接操作当前类的成员变量，则该方法就”必须”是成员方法。</p>
</li>
<li><p>静态方法：如果在方法体中，我们无需操作当前类的成员变量，则该方法就”建议”是静态方法。</p>
<p>–&gt; 工具类中的方法都是静态方法，也就是静态方法常用于工具类中，例如：Arrays、Math等。</p>
</li>
</ul>
<hr>
<h3 id="DAY12-1"><a href="#DAY12-1" class="headerlink" title="DAY12"></a>DAY12</h3><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ol>
<li><p><strong>什么是代码块</strong></p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">{</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>代码块的分类</strong></p>
<ul>
<li>局部代码块</li>
<li>静态代码块</li>
<li>构造代码块(非静态代码块)</li>
</ul>
</li>
<li><p><strong>局部代码块的概述</strong></p>
<ul>
<li>定义位置：在类中，代码块或方法体的内部。</li>
<li>定义个数：任意多个。</li>
<li>执行顺序：从上往下，顺序执行。</li>
<li>注意事项：<ol>
<li>在局部代码块中定义的变量，则该变量就只能在当前作用域中使用，不能在代码块之外使用。</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>静态代码块的概述</strong></p>
<ul>
<li><p>定义位置：在类中，代码块和方法体之外（必须使用static来修饰）。</p>
</li>
<li><p>定义个数：任意多个</p>
</li>
<li><p>执行顺序：从上往下，顺序执行</p>
</li>
<li><p>注意事项：a）加载某个类的时候，就会执行该类中的静态代码块，并且静态代码块只会执行一次。</p>
<p> –&gt;执行时间：加载类的时候，就会执行该类中的静态代码块。</p>
<p> –&gt; 执行次数：因为类只会加载一次，因此静态代码块就只会执行一次。</p>
<p> b）在静态代码块中，我们可以直接操作当前类的静态内容，但是不能直接操作当前类的成员内容和this。</p>
<p> –&gt; 原因：加载类的时候，就会执行该类中的静态代码块，则执行静态代码块的时候对象都还未创建。</p>
<p> c）加载类的时候，静态变量和静态代码块属于“从上往下，顺序执行”，建议把静态变量定义在静态代码块之前。</p>
<p> –&gt; 注意：在静态代码块中，我们“未必”能直接操作当前的静态变量。</p>
<p> d）在静态代码块中定义的变量，则该变量就只能在当前作用域中使用，不能再代码块之外使用。</p>
<p>使用场合：<strong>开发中，我们经常再静态代码块中完成对静态变量的初始化操作（常见）。</strong></p>
<p> –&gt;例如：创建工厂、加载数据库初始信息等等。</p>
</li>
</ul>
</li>
<li><p><strong>构造代码块的概述</strong></p>
<ol>
<li>定义位置：在类中，代码块和方法体之外（不能使用static来修饰）</li>
<li>定义个数：任意多个</li>
<li>执行顺序：从上往下，顺序执行。</li>
<li>注意事项：<ul>
<li>创建对象的时候，则就会执行该类中的构造代码块，对象创建了多少次则构造代码块就执行多少次。<ul>
<li>执行时间：创建对象的时候，则就会执行该类中的构造代码块。</li>
<li>执行次数：对象创建了多少次，则该类中的构造代码块就执行多少次。</li>
</ul>
</li>
<li>在构造代码块中，我们不但能直接操作当前类的静态内容，并且还能直接操作当前类的成员内容和this。<ul>
<li>原因：执行代码块的时候，此时对象都已经创建完毕，因此就能操作当前类的成员内容和this。</li>
</ul>
</li>
<li>创建对象的时候，成员变量和构造代码块属于“从上往下，顺序执行”，建议把成员变量定义在构造代码块之前。<ul>
<li>注意：在构造代码块中，我们“未必”能直接操作当前类的成员变量。</li>
</ul>
</li>
<li><strong>在构造代码块中定义的变量，则该变量就只能在当前作用域中使用，不能在代码块之外使用。</strong></li>
<li>使用场合：开发中，我们偶尔会在构造代码块中完成对成员变量的初始化操作。（不常见）<ul>
<li>可以将各个构造方法中公共的代码提取到构造代码块。</li>
<li>匿名内部类不能提供构造方法，此时初始化操作可以放到构造代码块中。</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>问题：静态代码块、构造代码块和构造方法执行顺序？</strong></p>
<p>–&gt; 静态代码块 &gt; 构造代码块 &gt; 构造方法</p>
</li>
</ol>
<hr>
<h4 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h4><ol>
<li><p>包的作用</p>
<ul>
<li>我们使用包来管理类，也就是类应该放在包中。</li>
<li><strong>包的出现，为类提供了多层的命名空间，也即是类的完整名字为”包名.类名”。</strong></li>
<li>注意：不同的包中，我们可以定义同名的类；同一个包中，我们不允许定义同名的类。</li>
</ul>
</li>
<li><p>如何定义包</p>
<ul>
<li><p>包名必须满足“标识符”的命名规则，必须满足<strong>“单词全部小写，多个单词之间以’.’链接，并且做到顶级域名倒着写”</strong>的命名规范。</p>
</li>
<li><p><strong>问题：以下两个包是否存在父子关系？【没有】</strong></p>
<p>–&gt; com.bjpowernode.demo com.bjpowernode.demo.test</p>
</li>
</ul>
</li>
<li><p>如何使用包</p>
<p>–&gt; <strong>在源文件有效代码第一行，使用package关键字来声明当前源文件中的类在那个包中。</strong></p>
<p>注意：通过IDEA新建的源文件，则源文件有效代码的第一行默认就有包声明；<strong>如果通过DOS命令来运行IDEA创建的源文件，则必须删除源文件中的包声明。</strong></p>
</li>
<li><p>java语言提供的包</p>
<ul>
<li><strong>java.lang 包含一些java语言的核心类，如String、Math、System等；</strong></li>
<li>java.awt 包含了构成抽象窗口工具集(abstract window toolkits)的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)；</li>
<li>java.net 包含执行与网络相关的操作的类；</li>
<li>java.io 包含能提供多种输入、输出功能的类；</li>
<li>java.util 包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。</li>
</ul>
</li>
<li><p><strong>类的访问方式</strong></p>
<ul>
<li><p><strong>简化访问</strong></p>
<ul>
<li><p>解释：当我们需要访问“java.lang”或“当前包”中的类时，则就可以直接使用“类名”来实现简化访问。</p>
</li>
<li><p>例如：访问“当前包”中的类</p>
<p>–&gt; Tiger tiger &#x3D; new Tiger(“老虎”, 18);</p>
</li>
<li><p>例如：访问“java.lang”中的类</p>
<p>–&gt; String str &#x3D; “hello world”;</p>
</li>
</ul>
</li>
<li><p><strong>带包名访问</strong></p>
<ul>
<li><p>解释：当我们需要访问“当前包”之外的类时（排除java.lang包中的类），则我们就必须通过“包名.类名”的方式来访问。</p>
</li>
<li><p>例如：访问”p1包”中的类</p>
<p>–&gt; com.bjpowernode.p1.staticblock.student stu &#x3D; new com.bjpowernode.p1.staticblock.student();</p>
</li>
<li><p>例如：访问“java.util”中的类</p>
<p>–&gt; java.util.Scanner input &#x3D; new java.util.Scanner(System.in);</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>import关键字的概述</strong></p>
<ul>
<li><p><strong>解释：当我们需要访问“当前包”之外的类（排除java.lang包中的类），则必须通过“带包名”的方式来访问，则此访问方式太麻烦，想要实现简化访问，则就可以先通过import关键字导入需要访问的类，然后再通过“类名”来实现简化访问。</strong></p>
</li>
<li><p>例如：访问“p1包”中的类</p>
<p>–&gt; import com.bjpowernode.p1.staticblock.student;</p>
<p>–&gt; Student stu &#x3D; new Steudent();</p>
</li>
<li><p>例如：访问”java.util”中的类</p>
<p>–&gt; import java.util.Scanner;</p>
<p>–&gt; Scanner input &#x3D; new Scanner(System.in);</p>
</li>
</ul>
</li>
<li><p><strong>import关键字的注意点</strong></p>
<ul>
<li><p><strong>如果需要使用某个包中的多个类时，则我们可以通过”*”通配符来导入这个包中的所有类。</strong></p>
<p>–&gt; 注意：开发中，不建议使用“*”来导入某个包中的所有类，因此此方式效率非常低。</p>
</li>
<li><p><strong>如果需要使用不同包中的同名类时，则其中一个类必须通过“带包名”的方式来访问。</strong></p>
<p>–&gt; 原因：通过import关键字导入多个不同包的同名类，则在源文件中使用导入的类时，无法区分。</p>
</li>
<li><p><strong>在JDK1.5之后，还新增了静态导入，也就是能导入某个类中的静态属性和静态方法。</strong></p>
<p>–&gt; 例如：导入Math类中的静态属性</p>
<ol>
<li>第一步：import static java.lang.Math.PI;</li>
<li>第二步：System.out.println(PI);</li>
</ol>
<p>–&gt; 例如：导入Math类中的静态属性和静态方法</p>
<ol>
<li>第一步：import static java.lang.Math.*;</li>
<li>第二部：System.out.println(PI);</li>
</ol>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="数组算法-冒泡排序"><a href="#数组算法-冒泡排序" class="headerlink" title="数组算法_冒泡排序"></a>数组算法_冒泡排序</h4><p><img src="https://cherish779.github.io/images/note_images/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.png" alt="img"></p>
<hr>
<h4 id="数组算法-选择排序"><a href="#数组算法-选择排序" class="headerlink" title="数组算法_选择排序"></a>数组算法_选择排序</h4><p><img src="https://cherish779.github.io/images/note_images/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.png" alt="img"></p>
<hr>
<h4 id="数组算法-查找"><a href="#数组算法-查找" class="headerlink" title="数组算法_查找"></a>数组算法_查找</h4><p>需求：查找元素8在数组{0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20}中的索引位置，查找元素在数组中不存在则返回-1。</p>
<ol>
<li>方式一：顺序查找（线性查找）<ul>
<li>优点：对查找的数组元素是否排序没有要求。</li>
<li>缺点：查找效率非常低。</li>
</ul>
</li>
<li>方式二：二分查找（折半查找）<ul>
<li>优点：查询效率非常高。</li>
<li>缺点：<strong>要求查找的数组元素必须排序（升序 | 降序）。</strong></li>
</ul>
</li>
</ol>
<p><img src="https://cherish779.github.io/images/note_images/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95.png" alt="img"></p>
<hr>
<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ol>
<li><p>问题：具备那三大特性的编程语言，我们才称之为面向对象语言？</p>
<p><strong>–&gt; 封装、继承、多态</strong></p>
</li>
<li><p><strong>封装的引入</strong></p>
<ul>
<li><p>问题1：给学生年龄赋值的时候，赋值的年龄不能为负数！</p>
<p>–&gt; 使用“setter和getter”方法来解决</p>
</li>
<li><p>问题2：<strong>相同的代码在不同的包中，可能会发生编译错误！</strong></p>
<p>–&gt; 使用“权限修饰符”来解决</p>
</li>
</ul>
</li>
<li><p><strong>编程中的封装</strong></p>
<ul>
<li><strong>核心：对于使用者而言，只需掌握其公开的访问方式，无需了解内部的具体实现细节。</strong></li>
</ul>
</li>
<li><p><strong>封装的层次</strong></p>
<ul>
<li>面向过程：对功能做的封装，也就是使用方法来完成的封装。</li>
<li><strong>面向对象：对数据和功能做的封装，也就是使用类来完成的封装。</strong></li>
</ul>
</li>
<li><p><strong>封装的好处</strong></p>
<ul>
<li>封装的出现，提高了代码的安全性【了解】。</li>
<li><strong>封装的出现，提高了代码的复用性【核心】。</strong></li>
</ul>
</li>
</ol>
<hr>
<h4 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h4><ol>
<li><p>private，私有的，权限：只能在“<strong>当前类</strong>”中访问，因此我们称之为“类可见性”。</p>
</li>
<li><p>default，<strong>默认的，权限：</strong>只能在“<strong>当前类 + 当前包</strong>”中访问，因此我们称之为“包可见性”。</p>
<p>–&gt; 注意：在权限修饰符中，没有default关键字，省略权限修饰符默认就是包可见性。</p>
</li>
<li><p>protected，受保护的，权限：只能在“<strong>当前类 + 当前包 + 别的包中的子类包</strong>”中访问，因此我们称之为“子类可见性”。</p>
</li>
<li><p>public，公开的，权限：只能在“<strong>当前类 + 当前包 + 加别的包</strong>”中访问，因此我们称之为“项目可见性”。</p>
</li>
</ol>
<ul>
<li><strong>权限大小【由低到高】：private &lt;&lt; default &lt;&lt; protected &lt;&lt; public</strong></li>
</ul>
<hr>
<h4 id="权限修饰符的使用"><a href="#权限修饰符的使用" class="headerlink" title="权限修饰符的使用"></a>权限修饰符的使用</h4><ul>
<li><p><strong>明确：实际开发中，“默认的”和“受保护的”很少使用，但是“私有的”和“公开的”却很常用。</strong></p>
</li>
<li><p><strong>private：default、protected和public都能修饰”成员变量”和“静态变量”。</strong></p>
<p>–&gt; 成员变量：因为存储都是“特殊数据”，因此使用private修饰。</p>
<p>–&gt; 静态变量：因为存储是“共享数据”，因此使用public来修饰。</p>
</li>
<li><p><strong>private：default、protected和public都能修饰”成员方法”和“静态方法”。</strong></p>
<p>–&gt; 如果该方法需要外界访问，则就把该方法使用public来修饰。</p>
<p>–&gt; 如果该方法无需外界访问，也就是只为当前类服务，那么久把该方法使用private来修饰。</p>
</li>
<li><p><strong>private：default、protected和public都能修饰“构造方法”。</strong></p>
<p>–&gt; 如果该类需要被外界实例化，则该类的构造方法就采用public来修饰;</p>
<p>–&gt; 如果该类无需被外界实例化，则该类的构造方法就采用private来修饰。</p>
<p><strong>注意：工具类中只有静态内容，因此工具类就无需被实例化，那么工具类的构造方法都采用了private修饰，eg：Arrays和Math等等。</strong></p>
</li>
<li><p><strong>定义类的时候，类只允许使用public和default，不允许使用private和protected来修饰。</strong></p>
<p>–&gt;使用public修饰的类（公开权限），则该类就能在整个项目中使用。</p>
<p>–&gt; 使用default修饰的类（默认权限），则该类就只能在当前包中使用。</p>
</li>
<li><p><strong>使用权限修饰符，则不允许修饰局部变量、局部代码块、静态代码块和构造代码块。</strong></p>
</li>
</ul>
<hr>
<h4 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h4><ol>
<li><p>setter和getter方法的概述</p>
<ul>
<li>成员变量一律私有化（private），避免外界直接去访问成员变量，然后提供公开的setter和getter方法来操作私有的成员变量。</li>
</ul>
</li>
<li><p><strong>setter方法的概述</strong></p>
<ul>
<li><p>作用：用于给私有的成员变量做<strong>赋值操作</strong>，<strong>并且还能对赋值的数据做检查和处理。</strong></p>
</li>
<li><p>eg：给私有的name成员变量提供setter方法，则实现代码如下：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p><strong>问题：给学生年龄赋值的时候，赋值的年龄不能为负数！【假设年龄在0-130之间】</strong></p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//处理赋值年龄不合法的情况</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>age <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> age <span class="token operator">></span> <span class="token number">130</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//System.out.println("输入年龄不合法");</span>
        <span class="token comment" spellcheck="true">//需求：在此处需要抛出一个参数不合法异常！</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"赋值年龄参数不合法，age"</span> <span class="token operator">+</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//执行到此处，则证明赋值年龄合法，则就执行赋值操作。</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p><strong>getter方法的概述</strong></p>
<ul>
<li><p>作用：<strong>用于获取私有成员变量的值（取值操作），并且还能对获得的数据做统一的处理。</strong></p>
</li>
<li><p>例如：给私有的name成员变量提供getter方法，则实现代码如下：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p><strong>setter和getter的注意点</strong></p>
<ul>
<li>通过构造方法给成员变量赋值，如果赋值的数据需要做检查和处理，则在构造方法中就必须调用setter方法来实现赋值操作。</li>
<li><strong>给boolean类型成员变量提供getter方法的时候，此时getter方法的名字前缀必须是“is”开头，而不是能以“get”来开头。</strong></li>
<li><strong>给类提供“构造方法”和“setter和getter方法”的时候，则建议使用“alt + insert”快捷键来实现，而不建议手动写代码来实现。</strong></li>
</ul>
</li>
</ol>
<hr>
<h3 id="DAY13"><a href="#DAY13" class="headerlink" title="DAY13"></a>DAY13</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ol>
<li><p><strong>继承的引入</strong></p>
<ul>
<li>问题：讲师类和学生类中都有相同的name和age两个成员变量，都有相同的eat()和sleep()两个成员方法，因此需要实现代码的复用。</li>
<li>解决：使用“继承”来实现。</li>
</ul>
</li>
<li><p><strong>继承的本质</strong></p>
<ul>
<li>就是提取一系列类中相同的成员变量和成员方法，这样就得到了一个父类，从而形成了继承关系。</li>
<li>即：<strong>向上提取。</strong></li>
</ul>
</li>
<li><p><strong>继承的语法</strong></p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> 父类<span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> 子类 <span class="token keyword">extends</span> 父类<span class="token punctuation">{</span><span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li>问题：请问extends表达的含义是什么？ –&gt; 扩展的含义</li>
<li>注意：父类又称为“超类”或“基类”，子类又称之为“派生类”。</li>
</ul>
</li>
<li><p><strong>继承的特点</strong></p>
<ul>
<li>子类不但能继承父类的成员变量和成员方法，并且子类还可以有自己特有的成员变量和成员方法。</li>
<li>即：<strong>子类对父类做的扩展。</strong></li>
</ul>
</li>
<li><p><strong>继承的好处</strong></p>
<ul>
<li>继承的出现，提高了代码的复用性，从而提高了开发的效率。</li>
<li>继承的出现，让类与类之间产生了联系，为后面学习“多态”打下了技术铺垫。</li>
<li><strong>强调：继承是一把“双刃剑”，父类代码一旦发生了变化，则就会影响所有的子类，使用继承的时候慎重。【高耦合】</strong></li>
</ul>
</li>
<li><p><strong>哪些内容子类不能继承</strong></p>
<ul>
<li>父类私有的内容，子类不能继承。</li>
<li>父类的构造方法，子类不能继承。</li>
<li><strong>父类静态的内容，虽然子类能够使用，但父类静态内容“不参与”继承。</strong></li>
<li><strong>强调：继承强调的是“对象”之间的关系，因此成员内容能参与继承，但是静态内容不参与继承。</strong></li>
</ul>
</li>
<li><p><strong>继承的注意点</strong></p>
<ul>
<li><p><strong>java语言采用的是“单继承”，C++语言采用的是“多继承”。</strong></p>
<ul>
<li><strong>单继承：</strong>一个子类只能有一个直接父类。</li>
<li><strong>多继承：</strong>一个子类可以有多个直接父类。</li>
</ul>
</li>
<li><p>AA类继承于BB类，BB类继承于CC类，CC类继承于DD类，。。。，从而就形成了“继承链”。</p>
<p>–&gt; 此处BB类，CC类和DD类都是AA类的“父类”，<strong>只有BB类属于AA类的“直接父类”。</strong></p>
</li>
<li><p><strong>java语言中，一个子类只能有一个直接父类，但是一个父类可以有多个直接子类。</strong></p>
</li>
<li><p><strong>如果一个类没有显式地使用extends关键字，则该类就默认继承于”java.lang.Object”类。</strong></p>
<p>–&gt; <strong>所有的java类都可以使用object类提供的方法。【最终继承的都是object类】</strong></p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="方法重写（方法复写，override）"><a href="#方法重写（方法复写，override）" class="headerlink" title="方法重写（方法复写，override）"></a>方法重写（方法复写，override）</h4><ol>
<li><p><strong>方法重写的引入</strong></p>
<ul>
<li>eg：智能机是对功能机做的扩展，也就是应该让“智能机类”继承于“功能机类”，也就意味着“父类”和“子类”中都有show()方法，从而就形成了“方法重写”。</li>
</ul>
</li>
<li><p><strong>什么是方法重写呢？</strong></p>
<ul>
<li>在子类中，我们定义一个和父类“几乎”一模一样的方法，这就形成了“方法重写”。</li>
</ul>
</li>
<li><p><strong>什么时候使用方法重写？</strong></p>
<ul>
<li>当父类提供的方法无法满足子类的需求，则在子类中就可以重写父类提供的方法，从而满足开发的需求。</li>
</ul>
</li>
<li><p><strong>父类的哪些方法子类不能重写？</strong></p>
<ul>
<li>父类的构造方法，子类不能重写。</li>
<li>父类的静态方法，子类不能重写。</li>
<li>父类私有的成员方法，子类不能重写。</li>
</ul>
</li>
<li><p><strong>方法重写的注意点</strong></p>
<ul>
<li><p>通过子类对象来调用重写方法，则默认调用的是子类重写的方法，而不是调用父类被重写的方法。</p>
</li>
<li><p>保证子类的某个方法肯定是重写方法，则可以在该方法声明之前添加“@Override”注解，从而保证该方法肯定是重写方法。</p>
<p>–&gt; 如果某个方法声明之前添加了“@Override”注解，则该方法就必须是重写方法，否则就会编译错误。</p>
</li>
<li><p><strong>在子类重写方法中，如果想要调用父类被重写的方法，则必须通过super关键字来调用（this和super使用类似）</strong></p>
</li>
</ul>
</li>
<li><p><strong>方法重写的具体要求</strong></p>
<ul>
<li><p><strong>&#x3D;&#x3D;，子类重写方法的“方法名”和“形参列表”必须和父类被重写方法的“方法名”和“形参列表”相同。</strong></p>
<p>–&gt; 此处“形参列表”必须相同，指的是“形参个数”和“形参类型”必须相同，<strong>形参名字不同不影响。</strong></p>
</li>
<li><p><strong>“&gt;&#x3D;”，子类重写方法的修饰符权限必须大于等于父类被重写方法的修饰符权限【权限】。</strong></p>
<p>–&gt; 修饰符权限：public &gt; protected &gt; default &gt; private</p>
<p><strong>–&gt; 注意：子类就不能重写父类采用了static或private来修饰的方法。</strong></p>
</li>
<li><p><strong>“&lt;&#x3D;”，子类重写方法的“返回值类型”必须小于等于父类被重写方法的“返回值类型”【辈分】。</strong></p>
<p>–&gt; 如果父类被重写方法的返回值类型为void、基本数据类型和String类型，则子类重写方法的返回值类型必须和父类被重写方法的返回值类型保持一致（&#x3D;&#x3D;）。</p>
<p>–&gt; 如果父类被重写方法的返回值类型为引用数据类型（排除String类型），则子类重写方法的返回值必须小于等于被重写方法的返回值类型。（&lt;&#x3D;，辈分）。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="方法重载和方法重写的区别"><a href="#方法重载和方法重写的区别" class="headerlink" title="方法重载和方法重写的区别"></a>方法重载和方法重写的区别</h4><ol>
<li><p><strong>整体区别</strong></p>
<ul>
<li><p>英文名字区别</p>
<p>方法重载：overload</p>
<p>方法重写：override</p>
</li>
<li><p>使用位置区别</p>
<p>方法重载：同一个类中使用。</p>
<p>方法重写：<strong>必须在继承体系中使用。</strong></p>
</li>
<li><p>具体作用区别</p>
<p>方法重载：允许在同一类中定义多个同名的方法，从而避免了方法名被污染。</p>
<p>方法重写：父类提供的方法如果无法满足子类需求，则子类就可以重写父类提供的方法。</p>
</li>
</ul>
</li>
<li><p><strong>具体区别</strong></p>
<ul>
<li><p>语法：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//方法体</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>返回值<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>修饰符的区别</p>
<p>方法重载：修饰符不同，不构成方法重载。</p>
<p>方法重写：<strong>子类重写方法的“修饰符权限”必须大于等于父类被重写方法的“修饰符权限”【权限】。</strong></p>
</li>
<li><p>返回值类型的区别</p>
<p>方法重载：返回值类型不同。不构成方法重载。</p>
<p>方法重写：<strong>子类重写方法的“返回值类型”必须小于等于父类被重写方法的“返回值类型”【辈分】。</strong></p>
</li>
<li><p>方法名的区别</p>
<p>方法重载：方法名必须相同。</p>
<p>方法重写：方法名必须相同。</p>
</li>
<li><p><strong>形参列表的区别</strong></p>
<p>方法重载：<strong>形参个数不同 或 形参类型不同，形参名字不同不影响。</strong></p>
<p>方法重写：<strong>形参个数 和 形参类型必须相同。</strong></p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="重写toString-方法（理解）"><a href="#重写toString-方法（理解）" class="headerlink" title="重写toString()方法（理解）"></a>重写toString()方法（理解）</h4><ol>
<li><p><strong>请问print()和println()方法的作用</strong></p>
<ul>
<li><strong>通过输出语句，都能把输出的内容转化为字符串类型，然后把转化为字符串类型的结果输出到控制台。</strong></li>
</ul>
</li>
<li><p><strong>请问基本数据类型和引用数据类型在内存中存储的是什么？</strong></p>
<ul>
<li>“基本数据类型”在内存中存储的是“数据值”，“引用数据类型”在内存中存储的是“地址值”。</li>
</ul>
</li>
<li><p><strong>直接输出一个对象，则输出的内容是什么呢？</strong></p>
<p><img src="https://cherish779.github.io/images/note_images/%E7%9B%B4%E6%8E%A5%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1.png" alt="img"></p>
</li>
<li><p><strong>输入一个对象的时候，底层做了什么嘛操作？</strong></p>
<ul>
<li><p><strong>问题： 引用数据类型在内存中存储的是“地址值”，则我们输出一个对象的时候，为什么输出的是“带包名的类@地址值”呢？</strong></p>
<p> –&gt;原因：输出一个对象的时候，则默认就调用toString()这个方法，此时我们Tiger类中没有定义toString()方法，则默认调用的就是Object类中的toString()方法，在Object类提供的toString()方法中，就返回了“带包名的类@地址值”这个字符串，因此输出一个对象就输出了“带包名的类@地址值”。</p>
</li>
<li><p><strong>源码：分析Object类提供toString()方法的底层源码</strong></p>
<p><img src="https://cherish779.github.io/images/note_images/Object%E7%B1%BB%E6%8F%90%E4%BE%9B%E7%9A%84toString%E6%96%B9%E6%B3%95.png" alt="img"></p>
</li>
<li><p><strong>重写Object类提供的toString()方法</strong></p>
<p><strong>问题：</strong>开发中，输出一个对象的时候，则直接输出“带包名的类@地址值”是没有任何意义的，实际开发中，我们输出一个对象的 时候，更多的是想输出该对象中的所有成员变量值，如何实现？</p>
<p><strong>解决：</strong>也就是说Object类提供的toStrig()方法无法满足我们的需求，则我们就可以重写Object类所提供的toString()方法，也就是在 重写toString()方法中返回该对象的所有成员变量值（字符串拼接成员变量后返回即可）。</p>
<p>none</p>
<pre class="line-numbers language-none"><code class="language-none">     
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>实现：</strong>使用“alt + insert”快捷键来重写toString()方法，不要自己手动去重写toString()方法。</p>
<p><img src="https://cherish779.github.io/images/note_images/%E9%87%8D%E5%86%99toString%E6%96%B9%E6%B3%95.png" alt="img"></p>
<p><strong>注意：建议每个类都应该重写Object类中的toString()方法，并且建议用“alt + insert”快捷键来重写toString()方法。</strong></p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="super关键字-重点"><a href="#super关键字-重点" class="headerlink" title="super关键字(重点)"></a>super关键字(重点)</h4><ol>
<li><p><strong>super关键字的概述</strong></p>
<ul>
<li>创建一个对象成功之后，则虚拟机就会动态地创建一个引用，该引用指向的就是“新创建出来的对象”，并且该引用的名字就是this。</li>
<li>创建一个子类对象成功之后，则虚拟机还会动态创建一个引用，该引用指向的就是“当前对象的直接父类对象”，并且该引用的名字就是super。</li>
<li>总结：this指的就是“当前对象”，super指的就是“当前对象的直接父类对象”。并且this可以单独使用，但是super不能单独使用。</li>
</ul>
</li>
<li><p><strong>super关键字的作用</strong></p>
<ul>
<li><strong>强调：this和super指的都是“对象”，并且this和super使用场合是相同的（构造方法、成员方法和构造代码块）。</strong></li>
<li>操作父类的成员变量，语法： super.父类成员变量名</li>
<li>调用父类的成员方法，语法：super.父类成员方法(实参列表);</li>
<li>调用父类的构造方法，语法：super(实参列表);</li>
</ul>
</li>
<li><p><strong>this和super的区别</strong></p>
<ul>
<li>this的特点：先在当前类找，找不到再去父类找。</li>
<li>super的特点：直接去父类找，而不会在当前类找。</li>
</ul>
</li>
<li><p><strong>super关键字的注意点</strong></p>
<ul>
<li><p>在子类重写方法中，如果想要调用父类被重写的方法，则必须通过super关键字来实现。</p>
</li>
<li><p>当局部变量，子类的成员变量和父类的成员变量同名的时候，则该如何去区分呢？</p>
<p><strong>局部变量采用“就近原则”，子类成员变量通过“this”来操作，父类成员变量通过“super”来操作。</strong></p>
</li>
<li><p><strong>父类私有的成员变量，在子类中即使使用super关键字也无法操作，只能通过setter和getter方法来操作父类私有成员变量。</strong></p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="super-实参列表-的概述"><a href="#super-实参列表-的概述" class="headerlink" title="super(实参列表)的概述"></a>super(实参列表)的概述</h4><ul>
<li><strong>在子类构造方法中，如果想要显式地调用父类的某个构造方法，则必须通过“super(实参列表)”来实现，从而实现了代码的复用。</strong></li>
<li><strong>在子类构造方法中，如果没有显式地调用别的构造方法，则默认就会调用父类的无参构造方法，也就是编译时会默认添加“super();”语句。</strong></li>
</ul>
<hr>
<h4 id="super-实参列表-的注意点"><a href="#super-实参列表-的注意点" class="headerlink" title="super(实参列表)的注意点"></a>super(实参列表)的注意点</h4><ul>
<li><strong>“super(实参列表)”只能存在于构造方法中，并且必须在构造方法有效代码的第一行。</strong></li>
<li><strong>建议每个类都应该有自己的无参构造方法，避免在继承体系中子类找不到父类的无参构造方法。</strong></li>
</ul>
<hr>
<h4 id="this-实参列表-和super-实参列表-的区别"><a href="#this-实参列表-和super-实参列表-的区别" class="headerlink" title="this(实参列表)和super(实参列表)的区别"></a>this(实参列表)和super(实参列表)的区别</h4><ul>
<li>this(实参列表)的特点：<strong>调用“当前类”的别的构造方法，并且必须在构造方法有效代码的第一行。</strong></li>
<li>super(实参列表)的特点：<strong>调用“父类”中的某个构造方法，并且必须在构造方法有效代码的第一行。</strong></li>
<li>结论：<strong>因为“this(实参列表)”和“super(实参列表)”都必须在构造方法有效代码的第一行，因此构造方法中不允许同时存在“this(实参列表)”和“super(实参列表)”。</strong></li>
</ul>
<hr>
<h4 id="继承体系下，创建子类对象的步骤分析"><a href="#继承体系下，创建子类对象的步骤分析" class="headerlink" title="继承体系下，创建子类对象的步骤分析"></a>继承体系下，创建子类对象的步骤分析</h4><ol>
<li>第一步：加载类（先加载父类，后加载子类）<ul>
<li>先执行父类的静态代码块，然后执行子类的静态代码块。</li>
</ul>
</li>
<li>第二步：创建对象（先创建父类对象，后创建子类对象）<ul>
<li>首先，执行父类的构造代码块，接着执行父类的构造方法。</li>
<li>然后，执行子类的构造代码块，接着执行子类的构造方法。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="继承体系下，创建子类对象的内存分析"><a href="#继承体系下，创建子类对象的内存分析" class="headerlink" title="继承体系下，创建子类对象的内存分析"></a>继承体系下，创建子类对象的内存分析</h4><ul>
<li><strong>创建一个子类对象，则默认还会创建他的父类对象，并且创建的这些对象之间属于“包含”关系。</strong></li>
<li><strong>也就是说，子类对象中包含了父类对象，那么子类对象和父类对象的“首地址”肯定是相同的。</strong></li>
</ul>
<p><img src="https://cherish779.github.io/images/note_images/%E5%88%9B%E5%BB%BA%E5%AD%90%E7%B1%BB%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90.png" alt="img"></p>
<hr>
<h4 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h4><ol>
<li>组合的引入<ul>
<li>需求：有一台电脑，电脑中包含鼠标、键盘和CPU等。</li>
<li>实现：定义电脑类（Computer），然后再定义鼠标类（Mouse）、键盘类（KeyBoard）和CPU类（CPU），然后把鼠标、键盘和CPU作为电脑类的“成员变量”即可，这就形成了“组合”关系。</li>
</ul>
</li>
<li>继承和组合<ul>
<li>相同点<ul>
<li><strong>都能让类与类之间产生联系，都能实现代码的复用。</strong></li>
</ul>
</li>
<li>不同点<ul>
<li><strong>继承描述的是“is a”的关系</strong>，例如：Tiger is Animal, Student is a Person等等。</li>
<li><strong>组合描述的是“has a”的关系</strong>，例如：Computer has a Mouse,Computer has a keyBoard等等。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="final关键字的概述"><a href="#final关键字的概述" class="headerlink" title="final关键字的概述"></a>final关键字的概述</h4><ol>
<li>final关键字的含义<ul>
<li>最终的、不可变的</li>
</ul>
</li>
<li>final关键字能修饰的内容？<ul>
<li>final关键字能修饰类、变量（局部变量、成员变量和静态变量）和方法（成员方法和静态方法），但是不能修饰构造方法和代码块。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="final关键字的特点"><a href="#final关键字的特点" class="headerlink" title="final关键字的特点"></a>final关键字的特点</h4><ol>
<li><p>使用final关键字修饰的类，</p>
<p>则该类就不能被继承。</p>
<ul>
<li>使用final修饰的类，则改类肯定是一个子类，例如String、Math和System都采用了final修饰。</li>
</ul>
</li>
<li><p>使用final关键字修饰的方法（成员方法和静态方法），则该方法就不能被重写。</p>
<ul>
<li>如果某个成员方法不想被子类重写，则该方法就采用final来修饰即可，例如Object类中的很多方法都采用了final修饰。</li>
</ul>
</li>
<li><p>使用final关键字修饰的变量（局部变量、成员变量和静态变量），则该变量就变为常量了。</p>
<ul>
<li>常量名必须符合“标识符”的命名规则，必须符合“字母全部大写，多个单词之间以下划线连接”的命名规范。</li>
<li>使用final修饰的静态变量，要么做显式初始化，要么在静态代码块中初始化，否则就会编译错误。</li>
<li>使用final修饰的成员变量，要么做显式初始化，要么在构造代码块中初始化，要么在构造方法中初始化，否则就会编译错误。</li>
</ul>
</li>
<li><p><strong>使用final关键字，我们不能修饰构造方法、局部代码块、构造代码块和静态代码块。</strong></p>
</li>
</ol>
<hr>
<h4 id="final修饰引用数据类型变量的特点"><a href="#final修饰引用数据类型变量的特点" class="headerlink" title="final修饰引用数据类型变量的特点"></a>final修饰引用数据类型变量的特点</h4><ul>
<li><strong>引用数据类型的变量采用final修饰后，则该变量就变为常量了，因此常量保持的地址值不能更改，但是该常量指向堆内存中的成员变量值可以更改。</strong></li>
</ul>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 实例化Tiger对象</span>
        <span class="token keyword">final</span> Tiger TIGER <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tiger</span><span class="token punctuation">(</span><span class="token string">"母老虎"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 注意：常量只能赋值一次！</span>
        <span class="token comment" spellcheck="true">// TIGER = null; // 编译错误</span>
        <span class="token comment" spellcheck="true">// 问题：请问是否能修改TIGER指向堆内存中的成员变量值呢？？？</span>
        TIGER<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"公老虎"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        TIGER<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>TIGER<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/*final int MAX_VALUE = 10;
        System.out.println(MAX_VALUE); // 输出：10
        // 注意：常量只能赋值一次！
        MAX_VALUE = 20; // 编译错误*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h4 id="通过javadoc-exe来生成API文档（了解）"><a href="#通过javadoc-exe来生成API文档（了解）" class="headerlink" title="通过javadoc.exe来生成API文档（了解）"></a>通过javadoc.exe来生成API文档（了解）</h4><ol>
<li>注释的分类<ul>
<li>单行注释</li>
<li>多行注释</li>
<li>文档注释</li>
</ul>
</li>
<li>注释的使用<ul>
<li>单行注释用于对代码块或方法体中的某行代码做解释说明，文档注释是用于给类、方法（成员方法、静态方法和构造方法）、成员变量、静态变量、构造代码块和静态代码块做解释说明，而多行注释在实际开发中很少使用。</li>
</ul>
</li>
<li>文档注释的概述<ul>
<li>使用文档注释的时候，我们需要合理的配合“块标记”来使用，常见的块标记如下：<ul>
<li>@version版本号 –&gt; 说明当前类在那个板块中开发或在那个版本中有修改</li>
<li>@author 作者名 –&gt; 说明当前类是那个程序员开发的</li>
<li>@param 形参名 –&gt; 对方法的形参做解释说明</li>
<li>@return –&gt; 对方法的返回值做解释说明</li>
</ul>
</li>
</ul>
</li>
<li>生成项目的API文档<ul>
<li>IDEA默认集成了javadoc.exe这个可执行程序，因此我们通过IDEA就能够直接生成项目的API文档，详情步骤请看预习文档。【第7章】</li>
</ul>
</li>
</ol>
<hr>
<h3 id="DAY14"><a href="#DAY14" class="headerlink" title="DAY14"></a>DAY14</h3><h4 id="Object类的概述"><a href="#Object类的概述" class="headerlink" title="Object类的概述"></a>Object类的概述</h4><ul>
<li>如果一个类没有显式地使用extends关键字，则这个类默认就是继承于java.Object类，也就是说Object类是所有java类的父类。也就意味着所有的java类都能使用Object类提供的方法。</li>
</ul>
<hr>
<h4 id="Object类的方法"><a href="#Object类的方法" class="headerlink" title="Object类的方法"></a>Object类的方法</h4><ol>
<li></li>
</ol>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//作用：把对象转化为字符串并返回。</span>
<span class="token comment" spellcheck="true">//注意：每个类都应该重写Object类的toString()方法，在重写的方法中返回该对象的所有成员变量。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li></li>
</ol>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//作用：判断this和obj这两个对象是否相等。相等则返回true，不相等则返回flse。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ul>
<li><p>回顾：关于比较运算符“&#x3D;&#x3D;”的作用？</p>
<ul>
<li>如果左右两边属于“基本数据类型”，则比较左右两边的“数据值”是否想等。</li>
<li>如果左右两边属于“引用数据类型”，则比较左右两边的“地址值”是否相等。</li>
</ul>
</li>
<li><p>底层：分析Object类提供equals()方法的底层源码</p>
<ul>
<li><p>`&#96;&#96;java</p>
<p>public boolean equals(Object obj){</p>
<p>return(this &#x3D;&#x3D; obj)</p>
<p>}</p>
<p>none</p>
<pre class="line-numbers language-none"><code class="language-none">     - 强调：Object类提供的equals(Object obj)方法，则默认比较两个对象的“地址值”是否相等。

     - **问题：实际开发中，直接比较两个对象的地址值是否相等是没有任何意义的，因为每次创建出来的对象地址值都不一样，开发中我们比较两个对象是否相等，更多的是想比较两个对象的成员变量值是否相等，则该需求如何实现呢？**

     - 解决：Object类提供的equals(Object obj)方法无法满足我们的需求，则我们就就可以重写Object类所提供给的equals(Object obj)方法，然后在重写的equals(Object obj)方法中根据成员变量值来判断两个对象是否相等。

     - 实现：不建议手动去重写equals(Object obj)方法，而是**建议使用“alt + inset”快捷键来重写equals(Object obj)方法。**

     - **注意：java提供的类，则默认重写了Object类中的equals(Object obj)方法；自定义的类，则需要我们自己去重写Object类中的equals(Object obj)方法。**
   
   - **哈希算法（自行了解）**

---

#### hashCode()

1. 
   
   ```java
   public native int hashCode();
   //作用：根据对象来生成一个哈希值，此处的哈希值是一个int类型的整数。
   //底层：Objec类提供的hashCode()方法，则默认是根据对象的地址值来生成的哈希值。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>问题：实际开发中，根据对象的地址值来生成哈希值是没有任何意义的，因为每次创建出来的对象的地址值都不一样。开发中，我们更多的是想根据对象的成员变量来生成哈希值，则该需求如何实现呢？</p>
<ul>
<li><p>解决：Object类提供的hashCode()方法无法满足我们的需求，则我们就可以重写Object类提供的hashCode()方法，并且在重写的hashCode()方法中，根据对象的成员变量值来生成哈希值即可。</p>
</li>
<li><p>实现：不建议手动去重写hashCode()方法，而是建议使用“Alt + insert”快捷键来重写hashCode()方法。</p>
</li>
<li><p>结论：</p>
<ol>
<li><p>两个对象调用equals()方法的结果是true，则这两个对象调用hashCode()方法返回的结果“肯定”相等。</p>
<p>–&gt; 如果都没有重写equals()方法和hashCode()方法，则以上结论“肯定”满足。</p>
<p>–&gt; 如果重写了equals()方法，则hashCode()方法也必须重写，从而保证以上结论“肯定”相等。</p>
<p>–&gt; 强调：要么都不重写equals()和hashCode()方法，要么都重写equals()和hashCode()方法，从而保证以上结论“肯定”满足。</p>
</li>
<li><p><strong>两个对象调用hashCode()方法返回的结果相同，则这两个对象调用equals()方法的结果“未必”为true。</strong></p>
<p>–&gt; 不同的两个对象（两个对象调用equals()方法的结果为false），则调用hashCode()方法返回的结果可能相同。</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 实例化两个Tiger对象</span>
        Tiger tiger1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tiger</span><span class="token punctuation">(</span><span class="token string">"母老虎"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Tiger tiger2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tiger</span><span class="token punctuation">(</span><span class="token string">"母老虎"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 判断两个对象是否相等</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>tiger1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>tiger2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 获得两个对象的哈希值</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>tiger1<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：854700057</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>tiger2<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：854700057</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>–&gt; 设计哈希算法的时候，则必须遵守的原则为：不同的两个对象，则生成的哈希值要尽可能不相同。</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<p><img src="https://cherish779.github.io/images/note_images/hashCode.png" alt="img"></p>
<hr>
<h4 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h4><ol>
<li><p><strong>设计哈希算法的时候，为啥偏偏要使用31来做乘法运算呢？</strong></p>
<ul>
<li><p>原因1：因为31是一个质数，而<strong>质数做乘法运算得到相同结果的概率非常低。</strong></p>
<p>–&gt; 例如：31 * 5，则结果为：155，那么得到155的乘法组合有：31 * 5、1 * 155</p>
<p>–&gt; 例如：30 * 5，则结果为：150，那么得到150的乘法组合有：30 * 5、1 * 150、25 * 6、50 * 3、15 * 10等等</p>
</li>
<li><p>原因2：因为31是一个质数，而<strong>使用质数做乘法运算的效率非常高（位运算）</strong>。</p>
<p>–&gt; 使用31来做乘法运算的公式，例如把“31*i”的操作换算为位运算的公式为：(i &lt;&lt; 5) - i</p>
<p>–&gt; 例如：31*5的结果为155，则计算公式“(5 &lt;&lt; 5) - 5”，那么得到的结果就是155</p>
<p>–&gt; 例如：31*3的结果为93，则计算公式“(3 &lt;&lt; 5) - 3”，那么得到的结果就是93</p>
<hr>
</li>
</ul>
</li>
<li><p><strong>质数千千万，为啥偏偏要使用31来做乘法运算呢？</strong></p>
<ul>
<li>假设：使用7来做乘法运算，因为7是一个质数，因此做乘法运算得到相同结果的概率较低，并且使用7来做乘法运算的效率还非常高。</li>
<li>公式：实现“7*i”的操作，则可以通过“(i &lt;&lt; 3) - i”来实现。</li>
<li>例如：7*5，则套用公式为“(5 &lt;&lt; 3) - 5”，则得到的结果为：35</li>
<li>答案：为什么要使用31来做乘法运算，因为这是数学家让我们这么做的。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="本地方法"><a href="#本地方法" class="headerlink" title="本地方法"></a>本地方法</h4><ol>
<li>什么是本地方法？<ul>
<li><strong>使用native关键字修饰的方法，我们就称之为“本地方法”。</strong></li>
</ul>
</li>
<li>本地方法的特点？<ul>
<li>本地方法只有方法声明，没有方法内部的具体实现，也就是没有方法体。</li>
</ul>
</li>
<li>为什么会有本地方法？<ul>
<li>因为java语言无法直接操作硬件，因此需要调用别的编程语言来操作硬件，而本地方法体就是调用了别的编程语言，考虑到java程序员可能不认识别的编程语言，因此本次发就省略了方法体。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="基本数据类型的转换"><a href="#基本数据类型的转换" class="headerlink" title="基本数据类型的转换"></a>基本数据类型的转换</h4><ol>
<li><p>隐式类型转换（自动）</p>
<ul>
<li><p>`&#96;&#96;java</p>
<p>double num &#x3D; 123;</p>
<p>none</p>
<pre class="line-numbers language-none"><code class="language-none">2. 强制类型转换（手动）

   - ```java
     int num = (int)3.14
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="引用数据类型的转换"><a href="#引用数据类型的转换" class="headerlink" title="引用数据类型的转换"></a>引用数据类型的转换</h4><ol>
<li><p><strong>向上转型（自动）</strong></p>
<ul>
<li><p>解释：父类引用指向子类对象。</p>
</li>
<li><p><strong>语法：父类类型 对象 &#x3D; 子类对象;</strong></p>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">Animal animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>优势：隐藏了子类特有内容，从而提高了代码的扩展性（多态）。</strong></p>
</li>
<li><p><strong>劣势：只能使用父类共有的内容，不能使用子类特有的内容。</strong></p>
</li>
<li><p>使用场合：<strong>使用“多态”的时候，则我们就必须使用“向上转型”，从而提高了代码的扩展性。</strong></p>
</li>
</ul>
</li>
<li><p><strong>向下转型（手动）</strong></p>
<ul>
<li><p>解释：子类引用指向父类对象。</p>
</li>
<li><p><strong>语法：子类类型 对象 &#x3D; (子类类型) 父类对象;</strong></p>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">Dog dog <span class="token operator">=</span> <span class="token punctuation">(</span>Dog<span class="token punctuation">)</span>animal<span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p><strong>优势：不但能使用父类共有的内容，并且还能使用子类特有的内容。</strong></p>
</li>
<li><p>劣势：使用向下转型的时候，<strong>可能会抛出“类型转换异常（ClassCastException）”。</strong></p>
</li>
<li><p>使用场合：使用多态提高代码的扩展性后，<strong>如果需要使用对象实际类型中的内容，则那么就必须做向下转型的操作。</strong></p>
</li>
</ul>
</li>
<li><p>eg1：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 向上转型（自动）</span>
        Animal animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 向下转型（手动）</span>
        <span class="token comment" spellcheck="true">// 原因：因为animal对象本质上属于Dog类型，因此就无法将animal对象强转为Tiger类型</span>
        Tiger tiger <span class="token operator">=</span> <span class="token punctuation">(</span>Tiger<span class="token punctuation">)</span> animal<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 类型转换异常</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 向上转型（自动）</span>
        Animal animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 向下转型（手动）</span>
        Dog dog <span class="token operator">=</span> <span class="token punctuation">(</span>Dog<span class="token punctuation">)</span> animal<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 优势：不但能使用父类共有的内容，并且还能使用子类特有的内容。</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        dog<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dog<span class="token punctuation">.</span>color<span class="token punctuation">)</span><span class="token punctuation">;</span>
        dog<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 向上转型（自动）</span>
        Animal animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 劣势：只能使用父类共有的内容，不能使用子类特有的内容。</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>animal<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        animal<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// System.out.println(animal.color); // 编译错误</span>
        <span class="token comment" spellcheck="true">// animal.show(); // 编译错误</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>eg2：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 需求：调用一个方法，传入一个字符串类型的类名，则就返回该类名所对应的对象。
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 父类引用指向子类对象（多态）</span>
        Animal dog <span class="token operator">=</span> <span class="token function">getAnimalInstance</span><span class="token punctuation">(</span><span class="token string">"Dog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 父类引用指向子类对象（多态）</span>
        Animal tiger <span class="token operator">=</span> <span class="token function">getAnimalInstance</span><span class="token punctuation">(</span><span class="token string">"Tiger"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 场合二：返回值类型为父类类型，则返回值就可以是该父类的任意子类对象。
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Animal <span class="token function">getAnimalInstance</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">case</span> <span class="token string">"Dog"</span><span class="token operator">:</span>
                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">"Cat"</span><span class="token operator">:</span>
                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">"Pig"</span><span class="token operator">:</span>
                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Pig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">"Bird"</span><span class="token operator">:</span>
                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Bird</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">case</span> <span class="token string">"Tiger"</span><span class="token operator">:</span>
                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Tiger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">default</span><span class="token operator">:</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"参数不合法异常，name："</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="多态的引入"><a href="#多态的引入" class="headerlink" title="多态的引入"></a>多态的引入</h4><ol>
<li><p>需求：在动物园中，管理员专门给动物们喂食。</p>
<ul>
<li><p>实现：定义管理员类（Admin），然后再定义动物类（Dog、Cat、Pig、Bird和Tiger），接着给每个动物提供eat()方法，最后再管理员类中给每个动物提供喂食的方法，例如给Dog提供的喂食方法为：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">feedDog</span><span class="token punctuation">(</span>Dog dog<span class="token punctuation">)</span><span class="token punctuation">{</span> 
    dog<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>问题：</p>
<ul>
<li>a)动物园中有无穷无尽的动物，则在管理员类中就需要提供无穷无尽的喂食方法。</li>
<li>b)当动物园引进一只新的动物，则在管理员类中就需要为它提供喂食的方法，这样不利于程序的维护性。</li>
</ul>
</li>
<li><p>解决：使用“多态”来解决。</p>
</li>
</ul>
</li>
<li><p>修改代码的步骤？</p>
<ul>
<li>第一步：定义一个Animal类，然后再Animal类中提供eat()方法。</li>
<li><strong>第二步：让所有的动物类都继承于Animal类，并重写Animal类的eat()方法。</strong></li>
<li>第三步：在Admin类中，我们只提供一个喂食的方法，也就是专门给所有的动物们喂食。</li>
<li>第四步：在测试类中，我们调用Admin类的feedAnimal()方法，用于给所有动物们喂食。</li>
</ul>
</li>
<li><p><strong>使用多态的前提？</strong></p>
<ul>
<li><p><strong>前提1：继承是实现多态的前提。</strong></p>
<p>–&gt; 让所有的动物类都继承于Animal类，也就是Animal类是所有动物类的父类！</p>
</li>
<li><p><strong>前提2：子类必须重写父类方法。</strong></p>
<p>–&gt; 所有的动物类都重写了Animal类的eat()方法，毕竟每个动物吃的东西都不同。</p>
</li>
<li><p><strong>前提3：父类引用指向子类对象。</strong></p>
<p>–&gt; Admin类中的feedAnimal()方法的形参为“Animal”类型，调用该方法时的实参为“Animal类的子类对象”，此处就用到了“父类引用指向子类对象”。</p>
<p>–&gt; 调用feedAnimal()方法的代码为“admin.feedAnimal(new Dog());”，则实现赋值给形参的操作就等效于：Animal animal &#x3D; new Dog();</p>
</li>
</ul>
</li>
<li><p><strong>使用多态的场合</strong></p>
<ul>
<li><p><strong>场合一：方法的形参为父类类型，则实参就可以是该父类的任意子类对象。</strong></p>
<p>–&gt; 例如：管理员给动物们喂食的案例</p>
</li>
<li><p><strong>场合二：返回值类型为父类类型，则返回值就可以是该父类的任意子类对象。</strong></p>
<p>–&gt; 例如：简单工厂模式的案例</p>
</li>
</ul>
</li>
<li><p>目前的学习中，我们在哪些地方遇到多态呢？</p>
<ul>
<li>在Object类中，提供的equals(Object obj)方法就使用了多态。</li>
</ul>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 实例化管理员对象</span>
        Admin admin <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Admin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 实例化动物对象</span>
        Dog dog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Pig pig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Pig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Cat cat <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Bird bird <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bird</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Tiger tiger <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tiger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Panda panda <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Panda</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 管理员给动物们喂食</span>
        admin<span class="token punctuation">.</span><span class="token function">feedAnimal</span><span class="token punctuation">(</span>dog<span class="token punctuation">)</span><span class="token punctuation">;</span>
        admin<span class="token punctuation">.</span><span class="token function">feedAnimal</span><span class="token punctuation">(</span>cat<span class="token punctuation">)</span><span class="token punctuation">;</span>
        admin<span class="token punctuation">.</span><span class="token function">feedAnimal</span><span class="token punctuation">(</span>pig<span class="token punctuation">)</span><span class="token punctuation">;</span>
        admin<span class="token punctuation">.</span><span class="token function">feedAnimal</span><span class="token punctuation">(</span>bird<span class="token punctuation">)</span><span class="token punctuation">;</span>
        admin<span class="token punctuation">.</span><span class="token function">feedAnimal</span><span class="token punctuation">(</span>tiger<span class="token punctuation">)</span><span class="token punctuation">;</span>
        admin<span class="token punctuation">.</span><span class="token function">feedAnimal</span><span class="token punctuation">(</span>panda<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="多态情况下，操作成员变量的特点"><a href="#多态情况下，操作成员变量的特点" class="headerlink" title="多态情况下，操作成员变量的特点"></a>多态情况下，操作成员变量的特点</h4><ol>
<li>编译时：检查“编译时类型”，也就是检查编译时类型中是否有该成员变量。</li>
<li>运行时：检查“编译时类型”，也就是操作了编译时类型中的成员变量。</li>
<li><strong>总结：多态情况下操作成员变量，则编译和运行都检查“编译时类型”。</strong></li>
</ol>
<hr>
<h4 id="多态情况下，调用成员方法的特点？"><a href="#多态情况下，调用成员方法的特点？" class="headerlink" title="多态情况下，调用成员方法的特点？"></a>多态情况下，调用成员方法的特点？</h4><ol>
<li><p>编译时：检查“编译时类型”，也就是检查编译时类型中是否有该成员方法。</p>
</li>
<li><p>运行时：检查“运行时类型”，也就是调用了运行时类型中的成员方法。</p>
</li>
<li><p><strong>总结：编译时检查“编译时类型”，运行时检查“运行时类型”。</strong></p>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Animal animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tiger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        animal<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 父类引用指向子类对象（多态）</span>
        <span class="token comment" spellcheck="true">// animal对象的编译时类型为“Animal”类，animal对象的运行时类型为“Tiger”类。</span>
        Animal animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tiger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 运行时：检查“运行时类型”，也就是调用了运行时类型中的成员方法。</span>
        animal<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 编译时：检查“编译时类型”，也就是检查编译时类型中是否有该成员方法。</span>
        <span class="token comment" spellcheck="true">/*animal.eat();
        animal.sleep(); // 编译错误*/</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 父类引用指向子类对象（多态）</span>
        <span class="token comment" spellcheck="true">// animal对象的编译时类型为“Animal”类，animal对象的运行时类型为“Tiger”类。</span>
        Animal animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Tiger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 运行时：检查“编译时类型”，也就是操作了编译时类型中的成员变量。</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>animal<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 编译时：检查“编译时类型”，也就是检查编译时类型中是否有该成员变量。</span>
        <span class="token comment" spellcheck="true">/*System.out.println(animal.name);
        System.out.println(animal.color); // 编译错误*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="instanceof二元运算符的概述"><a href="#instanceof二元运算符的概述" class="headerlink" title="instanceof二元运算符的概述"></a>instanceof二元运算符的概述</h4><ol>
<li><p>语法：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">boolean</span> result <span class="token operator">=</span> obj <span class="token keyword">instanceof</span> <span class="token class-name">class</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>注意：</p>
<ul>
<li>此处obj可以是一个对象，也可以为null。</li>
<li>此处class可以是一个类，也可以是一个接口。</li>
<li>此处instanceof二元运算符返回的结果肯定是boolean类型。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="instanceof二元运算符的作用"><a href="#instanceof二元运算符的作用" class="headerlink" title="instanceof二元运算符的作用"></a>instanceof二元运算符的作用</h4><ol>
<li>官方：判断左边的“对象”是否为右边“类或接口”的实例，如果“对象”属于“类或接口”的实例，则返回true，否则一律返回false。</li>
<li>通俗：如果强转的“对象”属于强转“类或接口”的实例，则就可以把该“对象”强转为该“类或接口”的类型，否则就会出现类型转换异常。</li>
</ol>
<hr>
<h4 id="编译时类型和运行时类型的概述"><a href="#编译时类型和运行时类型的概述" class="headerlink" title="编译时类型和运行时类型的概述"></a>编译时类型和运行时类型的概述</h4><ol>
<li><p><strong>编译时类型：指的就是声明对象的类型，也就是等号左边的类型。</strong></p>
</li>
<li><p><strong>运行时类型：指的就是对象的实际类型，也就是等号右边的类型。</strong></p>
</li>
<li><p>eg：没有使用多态之前，则编译时类型和运行时类型如下：</p>
<p>- </p>
<p>  <code>Dog dog = new Dog(); none   - 此处dog对象的编译时类型为”Dog“类，dog对象的运行时类型为”Dog“类。 4. eg：学习使用多态之后，则编译时类型和运行时类型如下：    - ```java     Animal animal = new Dog(); </code></p>
<ul>
<li>此处animal对象的编译时类型为“Animal”类，animal对象的运行时类型为“Dog”类。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="instanceof二元运算符编译的特点"><a href="#instanceof二元运算符编译的特点" class="headerlink" title="instanceof二元运算符编译的特点"></a>instanceof二元运算符编译的特点</h4><ol>
<li>情况一：当obj存储的内容就是null的情况<ul>
<li>当obj的存储的内容为null，则无论右侧的类或接口属于哪种类型，那么都编译都通过。</li>
</ul>
</li>
<li>情况二：当obj存储的内容不是null的情况<ul>
<li>当右边的“类或接口”属于左边“对象”编译时类型的父类、本身类和子类时，则编译通过，否则一律编译错误。</li>
<li><strong>注意：此处参照左边“对象”的“编译时类型”，并且此处的“本身类”指的也就是对象的“编译时类型”。</strong></li>
</ul>
</li>
</ol>
<hr>
<h4 id="instanceof二元运算符运行的特点"><a href="#instanceof二元运算符运行的特点" class="headerlink" title="instanceof二元运算符运行的特点"></a>instanceof二元运算符运行的特点</h4><ol>
<li><p><strong>情况一：当obj存储的内容就是null的情况</strong></p>
<ul>
<li>当obj存储的内容为null，则无论右侧的类或接口属于哪种类型，那么返回的结果都是false。</li>
<li><strong>结论：null不是任何类或接口的实例。</strong></li>
</ul>
</li>
<li><p><strong>情况二：当obj存储的内容不是null的情况</strong></p>
<ul>
<li><strong>当右侧的“类或接口”属于左边“对象”运行时类型的父类和本身类时，则一律返回true；</strong></li>
<li>当右侧的“类或接口”属于左边“对象”运行时类型的子类和兄弟类时，则一律返回false。</li>
<li><strong>注意：此处参照左边“对象”的“运行时类型”，并且此处的“本身类”指的也就是对象的“运行时类型”。</strong></li>
</ul>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 父类引用指向子类对象（多态）</span>
        <span class="token comment" spellcheck="true">// animal对象的编译时类型为“Animal”类，animal对象的运行时类型为“Dog”类</span>
        Animal animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 编译时：父类      运行时：父类</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>animal <span class="token keyword">instanceof</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 输出：true</span>
        <span class="token comment" spellcheck="true">// 编译时：本身类    运行时：父类</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>animal <span class="token keyword">instanceof</span> <span class="token class-name">Animal</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 输出：true</span>
        <span class="token comment" spellcheck="true">// 编译时：子类      运行时：本身类</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>animal <span class="token keyword">instanceof</span> <span class="token class-name">Dog</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 输出：true</span>
        <span class="token comment" spellcheck="true">// 编译时：子类      运行时：兄弟类</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>animal <span class="token keyword">instanceof</span> <span class="token class-name">Tiger</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 输出：false</span>
        <span class="token comment" spellcheck="true">// 编译时：子类      运行时：子类</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>animal <span class="token keyword">instanceof</span> <span class="token class-name">SmallDog</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：false</span>
        <span class="token comment" spellcheck="true">// 编译时：没有关系</span>
        <span class="token comment" spellcheck="true">// System.out.println(animal instanceof String);</span>
        <span class="token comment" spellcheck="true">// 编译时：没有关系</span>
        <span class="token comment" spellcheck="true">// System.out.println(animal instanceof Test01);</span>


        <span class="token comment" spellcheck="true">/*System.out.println(null instanceof Object);   // 输出：false
        System.out.println(null instanceof Animal);   // 输出：false
        System.out.println(null instanceof Dog);      // 输出：false
        System.out.println(null instanceof Tiger);    // 输出：false
        System.out.println(null instanceof SmallDog); // 输出：false
        System.out.println(null instanceof String);   // 输出：false
        System.out.println(null instanceof Test01);   // 输出：false*/</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 父类引用指向子类对象（多态）</span>
        Animal animal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 需求：把animal对象强转为Dog类型</span>
        <span class="token comment" spellcheck="true">// 1.判断animal对象是否为Dog类的实例</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>animal <span class="token keyword">instanceof</span> <span class="token class-name">Dog</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 2.把animal对象强转为Dog类型</span>
            Dog dog <span class="token operator">=</span> <span class="token punctuation">(</span>Dog<span class="token punctuation">)</span> animal<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"把animal对象强转为Dog类型"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 需求：把animal对象强转为Tiger类型</span>
        <span class="token comment" spellcheck="true">// 1.判断animal对象是否为Tiger类的实例</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>animal <span class="token keyword">instanceof</span> <span class="token class-name">Tiger</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 2.把animal对象强转为Tiger类型</span>
            Tiger tiger <span class="token operator">=</span> <span class="token punctuation">(</span>Tiger<span class="token punctuation">)</span> animal<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"把animal对象强转为Tiger类型"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">// 需求：把animal对象强转为SmallDog类型</span>
        <span class="token comment" spellcheck="true">// 1.判断animal对象是否为SmallDog类的实例</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>animal <span class="token keyword">instanceof</span> <span class="token class-name">SmallDog</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 2.把animal对象强转为SmallDog类型</span>
            SmallDog smallDog <span class="token operator">=</span> <span class="token punctuation">(</span>SmallDog<span class="token punctuation">)</span> animal<span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"把animal对象强转为SmallDog类型"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="abstract的引入"><a href="#abstract的引入" class="headerlink" title="abstract的引入"></a>abstract的引入</h4><ol>
<li>需求：在动力节点中，有讲师和助教两个工种，他们都具备工作的能力。</li>
<li>实现：定义讲师类（Teacher）和助教类（Assistant），然后分别提供work()的方法。</li>
<li>问题：讲师类和助教类都有work()方法，也就是讲师类和助教类都有相同的代码，因此我们需要实现代码的复用。</li>
<li>解决：使用“继承”来实现。定义一个员工类（Employee），并且给员工类提供work()方法，然后让讲师类和助教类继承于员工类，并重写员工类中的work()方法。</li>
<li>问题1：世界上没有任何一个工种就叫做员工，因此员工类不应该被实例化！<ul>
<li>–&gt; 使用“抽象类”来解决，也就是把员工类设置为抽象类即可。</li>
</ul>
</li>
<li>问题2：为了避免讲师和助教偷懒，因为要求讲师类和助教类必须重写员工类的work()方法！<ul>
<li>–&gt; 使用“抽象方法”来解决，也就是把员工类的work()方法设置为抽象方法。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ol>
<li><p>什么是抽象类</p>
<ul>
<li><strong>使用abstract关键字修饰的类，则我们就称之为“抽象类”。</strong></li>
</ul>
</li>
<li><p><strong>抽象类的组成</strong></p>
<ul>
<li>a)在抽象类中，依旧可以拥有成员变量和静态变量。</li>
<li>b)在抽象类中，依旧可以拥有成员方法和静态方法，<strong>并且还可以有任意多个抽象方法。</strong></li>
<li>c)在抽象类中，依旧可以拥有构造方法，该构造方法用于给抽象类中的成员变量做指定初始化操作。</li>
<li>d)在抽象类中，依旧可以拥有构造代码块和静态代码块。</li>
<li><strong>总结：抽象类就是一个特殊的类，抽象类对比普通类新增了任意多个抽象方法。</strong></li>
</ul>
</li>
<li><p><strong>抽象类的特点</strong></p>
<ul>
<li><p><strong>a)抽象类不能被实例化，因为抽象类中包含了抽象方法。</strong></p>
</li>
<li><p>b)抽象类肯定是一个父类，<strong>只有实现类“实现”了抽象类中的所有抽象方法，则该实现类才能被实例化，否则该实现类就是一个抽象类。</strong></p>
<p><strong>实现：子类重写父类的抽象方法，我们就称之为“实现”。</strong></p>
<p>重写：子类重写父类的普通方法，我们就称之为“重写”。</p>
</li>
<li><p><strong>c)抽象类可以作为方法的“形参类别”和“返回值类型”，也就是抽象类也可以实现多态。</strong></p>
</li>
<li><p><strong>d)实现类与抽象类之间属于“extends”的关系，并且属于“单继承”。</strong></p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><ol>
<li><p>什么是抽象方法？</p>
<ul>
<li><strong>使用abstract关键字修饰的方法，我们就称之为“抽象方法”。</strong></li>
</ul>
</li>
<li><p>抽象方法的特点</p>
<ul>
<li>a)抽象方法<strong>只有方法声明</strong>，没有方法内部的具体实现，也就是<strong>没有方法体。</strong></li>
<li><strong>b)抽象方法只能存在于“抽象类”和“接口”中，不能存在于“普通类”中。</strong></li>
</ul>
</li>
<li><p>关于abstract关键字的补充？</p>
<ul>
<li>a)<strong>请问abstract关键字和哪一个关键字是反义词？</strong>？？final</li>
<li>b)<strong>请问abstract关键字不能和哪些关键字共存呢？</strong>？？final、private、static</li>
</ul>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// Employee employee = new Employee();</span>
        <span class="token comment" spellcheck="true">// 父类引用指向子类对象（多态）</span>
        Employee employee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 实例化Teacher对象</span>
        Teacher teacher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Teacher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        teacher<span class="token punctuation">.</span><span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 实例化Assistant对象</span>
        Assistant assistant <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Assistant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        assistant<span class="token punctuation">.</span><span class="token function">work</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h3 id="DAY15"><a href="#DAY15" class="headerlink" title="DAY15"></a>DAY15</h3><h4 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h4><ol>
<li>接口的引入<ul>
<li>需求：让飞机、炮弹、小鸟和超人进行飞行表演！</li>
<li>实现：定义飞机类（Plane）、炮弹类（Peng）、小鸟类（Bird）和超人类（SuperMan），然后为每个类提供showFly()的方法。</li>
<li>问题：飞机类、炮弹类、小鸟类和超人类都有showFly()方法，也就是这些类中有相同的代码，那么我们就需要实现代码的复用，如何实现？</li>
<li>解决：使用“继承”来解决。定义一个Flyable类，然后给Flyable类提供showFly()的方法，接着让飞机类、炮弹类、小鸟类和超人类“继承”于Flyable类，并重写Flyable类中的showFly()方法。</li>
<li>问题：继承描述的是“is a”的关系，也就是描述“相同体系”的基本行为，此处飞机、炮弹、小鸟和超人属于不同体系，因此使用继承不合适</li>
<li>解决：使用“接口”来解决。定义一个Flyable接口，然后给Flyable接口提供showFly()方法，接着让飞机类、炮弹类、小鸟类和超人类“实现”于Flyable接口，并实现Flyable接口中的showFly()方法。</li>
<li><strong>总结：接口描述的是“is like a”的关系，也就是描述“不同体系”的相同行为，此处飞机、炮弹、小鸟和超人属于不同体系，因此使用接口很合适。</strong></li>
</ul>
</li>
</ol>
<hr>
<h4 id="接口的概述"><a href="#接口的概述" class="headerlink" title="接口的概述"></a>接口的概述</h4><ol>
<li><p>接口的定义</p>
<ul>
<li><p><strong>明确：接口使用interface关键字来修饰，并且interface和class属于平级的，因此interface和class不能共存！</strong></p>
</li>
<li><p>语法：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token keyword">interface</span> 接口 <span class="token keyword">extends</span> 父接口<span class="token number">1</span><span class="token punctuation">,</span> 父接口<span class="token number">2</span><span class="token punctuation">,</span> 父接口<span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">{</span>
     <span class="token comment" spellcheck="true">// 全局静态常量和全局抽象方法</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>接口的组成</p>
<ul>
<li><p>a)接口中的<strong>属性</strong>，<strong>默认全部是“全局静态常量”，也就是默认使用了“public static final”来修饰。</strong></p>
</li>
<li><p>b)接口中的<strong>方法，默认全部是“全局抽象方法”，也就是默认使用了“public abstract”来修饰。</strong></p>
<p><strong>在JDK1.8之后，接口中还新增了“全局静态方法”和“default修饰的全局默认方法”。</strong></p>
</li>
<li><p>c)<strong>在接口中，不允许存在构造方法，因为接口中都没有成员变量，因此就无需存在构造方法。</strong></p>
</li>
<li><p><strong>d)在接口中，不允许存在静态代码块和构造代码块。</strong></p>
</li>
</ul>
</li>
<li><p>接口的特点</p>
<ul>
<li>a)<strong>接口不能被实例化，因为接口中存在抽象方法，并且接口中没有构造方法。</strong></li>
<li>b)<strong>接口可以作为方法的“形参类型”和“返回值类型”</strong>，也就是<strong>接口能够实现多态。</strong></li>
<li>c)接口与接口之间属于“extends”的关系，并且<strong>接口还属于“多继承”。</strong></li>
<li>d)<strong>抽象方法只能存在于“抽象类”和“接口”中，不能存在于“普通类”中。</strong></li>
</ul>
</li>
</ol>
<hr>
<h4 id="实现类的概述"><a href="#实现类的概述" class="headerlink" title="实现类的概述"></a>实现类的概述</h4><ol>
<li><p>实现类的定义</p>
<ul>
<li><p>明确：<strong>实现类和接口之间属于“implements”的关系，而不是属于“extends”的关系。</strong></p>
</li>
<li><p>语法：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> 实现类 <span class="token keyword">extends</span> 父类 <span class="token keyword">implements</span> 接口<span class="token number">1</span><span class="token punctuation">,</span> 接口<span class="token number">2</span><span class="token punctuation">,</span> 接口<span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 实现类中书写的代码</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>实现类的特点</p>
<ul>
<li>a)<strong>实现类只有“实现”了接口中的所有抽象方法，则该实现类才能被实例化，否则该实现类就是一个抽象类。</strong></li>
<li>b)<strong>实现类可以先继承一个父类，然后再去实现多个接口，实现多个接口的操作我们就称之为“接口的多实现”。</strong></li>
</ul>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 接口
 */</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Flyable</span> <span class="token keyword">extends</span> <span class="token class-name">Runable</span><span class="token punctuation">,</span> Sleepable<span class="token punctuation">,</span> Eatable <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// a)接口中的属性，默认全部是“全局静态常量”，也就是默认使用了“public static final”来修饰。</span>
    <span class="token comment" spellcheck="true">/*public static final*/</span> String CLASS_ROOM <span class="token operator">=</span> <span class="token string">"教室四"</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// d)在接口中，不允许存在静态代码块和构造代码块。</span>
    <span class="token comment" spellcheck="true">// {}</span>
    <span class="token comment" spellcheck="true">// static {}</span>

    <span class="token comment" spellcheck="true">// c)在接口中，不允许存在构造方法，因为接口中都没有成员变量，因此就无需存在构造方法。</span>
    <span class="token comment" spellcheck="true">// public Flyable() {}</span>

    <span class="token comment" spellcheck="true">// b)接口中的方法，默认全部是“全局抽象方法”，也就是默认使用了“public abstract”来修饰。</span>
    <span class="token comment" spellcheck="true">/*public abstract*/</span> <span class="token keyword">void</span> <span class="token function">showFly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">// 在JDK1.8之后，接口中还新增了“全局静态方法”。</span>
    <span class="token comment" spellcheck="true">/*public*/</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">staticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"static method ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 在JDK1.8之后，接口中还新增了“default修饰的全局默认方法”。</span>
    <span class="token comment" spellcheck="true">/*public*/</span> <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"default method ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Flyable<span class="token punctuation">.</span>CLASS_ROOM<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Flyable<span class="token punctuation">.</span><span class="token function">staticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 父类引用指向子类对象（多态）</span>
        <span class="token comment" spellcheck="true">// bird对象的编译时类型为“Flyable”接口，bird对象的运行时类型为“Bird”类。</span>
        Flyable bird <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bird</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 编译时：检查“编译时类型”，也就是检查Flyable接口中是否有showFly()方法。</span>
        <span class="token comment" spellcheck="true">// 运行时：检查“运行时类型”，也就是调用了Bird类中的showFly()方法</span>
        bird<span class="token punctuation">.</span><span class="token function">showFly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        bird<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="抽象类和接口的总结"><a href="#抽象类和接口的总结" class="headerlink" title="抽象类和接口的总结"></a>抽象类和接口的总结</h4><ol>
<li><p>普通类、抽象类和接口的特点</p>
<ul>
<li><strong>接口的抽象程度最高，抽象类的抽象程度次之，普通类的抽象程度最低。</strong></li>
</ul>
</li>
<li><p>抽象类和接口的对比</p>
<ul>
<li><p>相同点</p>
<ol>
<li>都是向上提取的结果，因此都不能被实例化。</li>
<li>都是向上提取的结果，因此都包含了抽象方法。</li>
</ol>
</li>
<li><p>不同点</p>
<ol>
<li><p>接口与接口之间属于“extends”的关系，并且属于“多继承”。</p>
<p>抽象类与抽象类之间属于“extends”的关系，并且属于“单继承”。</p>
</li>
<li><p>实现类与接口之间属于“implements”的关系，并且属于“多实现”。</p>
<p>实现类与抽象类之间属于“extends”的关系，并且属于“单继承”。</p>
</li>
<li><p>接口描述的是“is like a”的关系，也就是描述“不同体系”的相同行为。</p>
<p>抽象类描述的是“is a”的关系，也就是描述“相同体系”的基本行为。</p>
</li>
<li><p>接口中只有“全局静态常量”和“全局抽象方法”，JDK1.8之后新增了“全局静态方法”和“default修饰的全局默认方法”。</p>
<p>抽象类就是一个特殊类，抽象类对比普通类新增了任意多个抽象方法。</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="单继承和多继承的概述？"><a href="#单继承和多继承的概述？" class="headerlink" title="单继承和多继承的概述？"></a>单继承和多继承的概述？</h4><ol>
<li>单继承：java、C#等等<ul>
<li>解释：一个子类只能有一个直接父类，类似于一个儿子只有一个亲爹。</li>
<li>优势：简单、安全。</li>
<li>劣势：只能继承一个父类的内容，则子类功能不够强大。</li>
</ul>
</li>
<li>多继承：C++<ul>
<li>解释：一个子类可以有多个直接父类，类似于一个儿子可以有多个亲爹。</li>
<li>优势：可以继承多个父类的内容，则子类功能非常强大。</li>
<li>劣势：复杂、不安全。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="接口的多实现的概述"><a href="#接口的多实现的概述" class="headerlink" title="接口的多实现的概述"></a>接口的多实现的概述</h4><ol>
<li>需求：要求子类不但简单又安全，同时还要求子类功能非常强大，如何实现？<ul>
<li>不但要集合单继承和多继承的优势，并且还要摒弃单继承和多继承的劣势。</li>
<li><strong>实现：先让子类继承于某个父类，然后再让该子类实现多个接口，实现多个接口的操作就称之为“接口的多实现”。</strong></li>
<li>通过以上的实现方式，我们就模拟了C++的多继承操作，并且还摒弃了C++多继承的劣势。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="内部类的概述"><a href="#内部类的概述" class="headerlink" title="内部类的概述"></a>内部类的概述</h4><ol>
<li><p>什么是内部类</p>
<ul>
<li><strong>在OutClass类的内部，我们再定义InnerClass类就是内部类。</strong></li>
</ul>
</li>
<li><p>内部类的定义位置？</p>
<ul>
<li>位置一：在类中，代码块或方法体的内部。</li>
<li>位置二：在类中，代码块和方法体的外部。</li>
</ul>
</li>
<li><p>什么时候使用内部类？</p>
<ul>
<li>描述一个事物的时候，我们发现该事物内部还有别的事物，此时就可以使用内部类来实现。</li>
<li>例如：描述小汽车的时候，我们发现小汽车内部还有发动机，此时的发动机就是一个内部类。</li>
</ul>
</li>
<li><p>内部类的分类？</p>
<ul>
<li><strong>成员内部类（掌握）</strong>、<strong>静态内部类（掌握）</strong>、局部内部类（了解）和<strong>匿名内部类（重点）</strong>。</li>
</ul>
</li>
<li><p>内部类编译的特点？</p>
<ul>
<li><p>在OuterClass类的内部，我们再定义InnerClass类，此时我们对程序进行编译，<strong>则就会获得两个字节码文件</strong></p>
<p>–&gt; <strong>OuterClass.class</strong> 外部类的字节码文件，也就是OuterClass类的字节码文件</p>
<p>–&gt; <strong>OuterClass$InnerClass.class</strong> 内部类的字节码文件，也就是InnerClass类的字节码文件</p>
</li>
</ul>
</li>
<li><p>操作内部类的特点？</p>
<ul>
<li>想要操作内部类，则必须通过外部类来实现，也就是内部类是依附于外部类的。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="成员内部类（掌握）"><a href="#成员内部类（掌握）" class="headerlink" title="成员内部类（掌握）"></a>成员内部类（掌握）</h4><p>明确：学习成员内部类的时候，我们建议<strong>把“成员内部类”当成“成员变量”来理解。</strong></p>
<ol>
<li><p>定义位置</p>
<ul>
<li>在类中，代码块和方法体之外。</li>
</ul>
</li>
<li><p>定义语法</p>
<ul>
<li><p>`&#96;&#96;java</p>
<p>[修饰符] class 外部类{</p>
<p>&#x2F;&#x2F;成员内部类</p>
<p>[修饰符] class 内部类{</p>
<p>&#x2F;&#x2F;内部类中的代码</p>
<p>}</p>
<p>}</p>
<p>none</p>
<pre class="line-numbers language-none"><code class="language-none">3. 注意事项

   - a)**定义成员内部类的时候**，我们可以使用private、protected、public、final和abstract来修饰，但是**不能使用static来修饰。**

   - b)**在成员内部类中**，我们只能定义成员变量、成员方法、构造方法和构造代码块，但是**不能定义静态变量、静态方法和静态代码块。**

   - c)想要操作成员内部类，则我们必须通过外部类对象来操作，也就是**成员内部类是依附于外部类对象的**，此处联想“成员变量”来理解。

     **在外部类的成员位置，我们可以直接操作当前类的成员内部类；但是在外部类的静态位置，我们不能直接操作当前类的成员内部类。**

   - d)在成员内部类中，我们不但能直接操作外部类的成员变量和成员方法，并且还能直接操作外部类的静态变量和静态方法。

     代码执行到成员内部类中，则意味着外部类对象肯定已经创建完毕，因此就能操作外部类的成员内容和静态内容。

   - e)在成员内部类中，当局部变量、成员内部类的成员变量和外部类的成员变量同名的时候，则如何区分呢？

     - ```java
       System.out.println{"局部变量：" + name}
       System.out.println("内部类的成员变量：" + this.name);
       System.out.println("外部类的成员变量：" + OuterClass.this.name);
       
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>成员内部类的实例化方式？</p>
<ul>
<li><p>情况一：<strong>在外部类的内部，我们实例化成员内部类对象（掌握）</strong></p>
<p>–&gt; 语法：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">内部类 对象 <span class="token operator">=</span> <span class="token keyword">new</span> 内部类<span class="token punctuation">(</span>实参列表<span class="token punctuation">)</span><span class="token punctuation">;</span>  
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>情况二：<strong>在外部类的外部，我们实例化成员内部类对象。（了解）</strong></p>
<p>–&gt; 语法：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">外部类<span class="token punctuation">.</span>内部类 对象 <span class="token operator">=</span> <span class="token keyword">new</span> 外部类<span class="token punctuation">(</span>实参列表<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">new</span> 内部类<span class="token punctuation">(</span>实参列表<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 外部类</span>
<span class="token keyword">class</span> <span class="token class-name">OuterClass</span> <span class="token punctuation">{</span>
    String name <span class="token operator">=</span> <span class="token string">"OuterClass"</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">static</span> String classRoom<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 成员内部类</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">{</span>
        String name <span class="token operator">=</span> <span class="token string">"InnerClass"</span><span class="token punctuation">;</span>
        <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token function">InnerClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 在成员内部类中，当局部变量、成员内部类的成员变量和外部类的成员变量同名的时候，则如何区分呢？？？</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"局部变量："</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"内部类的成员变量："</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"外部类的成员变量："</span> <span class="token operator">+</span> OuterClass<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment" spellcheck="true">/*System.out.println(age); // 没问题
            System.out.println(classRoom);  // 没问题
            System.out.println("show ...");*/</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 情况一：在外部类的内部，我们实例化成员内部类。
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        InnerClass innerClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InnerClass</span><span class="token punctuation">(</span><span class="token string">"小花"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        innerClass<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token string">"局部变量"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// new OuterClass().method();</span>
        <span class="token comment" spellcheck="true">// 情况二：在外部类的外部，我们实例化成员内部类对象</span>
        OuterClass<span class="token punctuation">.</span>InnerClass innerClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OuterClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">InnerClass</span><span class="token punctuation">(</span><span class="token string">"小花"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        innerClass<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token string">"局部变量"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="静态内部类-掌握"><a href="#静态内部类-掌握" class="headerlink" title="静态内部类(掌握)"></a>静态内部类(掌握)</h4><p>明确：学习静态内部类的时候，我们把“静态内部类”当成“静态变量”来理解。</p>
<ol>
<li><p>定义位置</p>
<ul>
<li>在类中，代码块和方法之外。</li>
</ul>
</li>
<li><p>定义语法</p>
<p>-</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> 外部类<span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//静态内部类</span>
    <span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token keyword">static</span> <span class="token keyword">class</span> 内部类<span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//书写静态内部类的代码</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>注意事项</p>
<ul>
<li><p>a)定义静态内部类的时候，我们可以使用private、protected、public、final和abstract来修饰，并且还<strong>必须使用static来修饰</strong></p>
</li>
<li><p>b)在静态内部类中，我们不但能定义成员变量、成员方法、构造方法和构造代码块，并且还<strong>能定义静态变量、静态方法和静态代码块。</strong></p>
</li>
<li><p>c)<strong>想要操作静态内部类，则直接通过外部类名来操作即可</strong>，因为静态内部类是依附于外部类的，此处联想“静态变量”来理解即可。</p>
<p><strong>在外部类的成员位置，我们可以直接操作当前类中的静态内部类；在外部类的静态位置，我们可以直接操作当前类中的静态内部类。</strong></p>
</li>
<li><p>d)<strong>在静态内部类中，我们可以直接操作外部类的静态变量和静态方法，但是不能直接操作外部类的成员变量和成员方法。</strong></p>
<p>静态内部类是依附于外部类的，也就是<strong>只要外部类加载完毕，则就能操作当前类中静态内部类。</strong></p>
</li>
<li><p>e)想要操作静态内部类中的静态变量和静态方法，则我们还可以通过以下方式来直接操作：</p>
<ol>
<li><strong>操作静态变量</strong>：外部类.静态内部类.静态变量名；</li>
<li><strong>操作静态方法</strong>：外部类.静态内部类.静态方法名(实参列表);</li>
</ol>
</li>
</ul>
</li>
<li><p><strong>静态内部类的实例化方式？</strong></p>
<ul>
<li><p><strong>情况一：在外部类的内部，我们实例化静态内部类对象（掌握）</strong></p>
<p>–&gt; 语法：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">内部类 对象 <span class="token operator">=</span> <span class="token keyword">new</span> 内部类<span class="token punctuation">(</span>实现列表<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>情况二：在外部类的外部，我们实例化静态内部类对象（了解）</p>
<p>–&gt; 语法：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">外部类<span class="token punctuation">.</span>内部类 对象 <span class="token operator">=</span> <span class="token keyword">new</span> 外部类<span class="token punctuation">.</span>内部类<span class="token punctuation">(</span>实参列表<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p><strong>成员内部类和静态内部类的总结</strong></p>
<ul>
<li><strong>成员内部类：如果内部类需要依附于外部类对象，则该内部类就必须为成员内部类。</strong></li>
<li><strong>静态内部类：如果内部类只需依附于外部类即可，并且需要在该内部类中定义静态内容，则该内部类就必须定义为静态内部类。</strong></li>
</ul>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 外部类</span>
<span class="token keyword">class</span> <span class="token class-name">OuterClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">static</span> String userName<span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">// 静态内部类</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">{</span>
        String name<span class="token punctuation">;</span>
        <span class="token keyword">static</span> String classRoom<span class="token punctuation">;</span>
        <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">static</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token function">InnerClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">/*System.out.println(age); // 编译错误
            System.out.println(userName); // 没问题*/</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"show ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"method ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 情况一：在外部类的内部，我们实例化静态内部类对象
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        InnerClass innerClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InnerClass</span><span class="token punctuation">(</span><span class="token string">"小花"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        innerClass<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 操作静态方法：外部类.静态内部类.静态方法名(实参列表);</span>
        OuterClass<span class="token punctuation">.</span>InnerClass<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 操作静态变量：外部类.静态内部类.静态变量名</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>OuterClass<span class="token punctuation">.</span>InnerClass<span class="token punctuation">.</span>classRoom<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// OuterClass.method();</span>
        <span class="token comment" spellcheck="true">// 情况二：在外部类的外部，我们实例化静态内部类对象</span>
        OuterClass<span class="token punctuation">.</span>InnerClass innerClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OuterClass<span class="token punctuation">.</span>InnerClass</span><span class="token punctuation">(</span><span class="token string">"小花"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        innerClass<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="局部内部类（了解）"><a href="#局部内部类（了解）" class="headerlink" title="局部内部类（了解）"></a>局部内部类（了解）</h4><p>明确：学习局部内部类，则我们把“局部内部类”当成“局部变量”来理解。</p>
<ol>
<li><p>定义位置</p>
<ul>
<li>在类中，代码块或方法体的内部。</li>
</ul>
</li>
<li><p>定义语法</p>
<p>-</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> 外部类<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//位置一：定义在代码块中</span>
        <span class="token keyword">class</span>内部类<span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//书写局部内部类中的代码</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//位置二：定义在方法体中</span>
        <span class="token keyword">class</span> 内部类<span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//书写局部内部类中的代码</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>注意事项</p>
<ul>
<li><p>a)定义局部内部类的时候，我们不能使用private、protected、public和static修饰，但是<strong>可以使用final和abstract来修饰。</strong></p>
</li>
<li><p>b)在局部内部类中，我们<strong>只能定义成员变量、成员方法、构造方法和构造代码块</strong>，但是<strong>不能定义静态变量、静态方法和静态代码块。</strong></p>
</li>
<li><p>c)局部内部类只能在“当前作用域”中使用，不能在代码块或方法体之外使用，此处我们可以联想局部变量的“生命周期”来理解。</p>
</li>
<li><p>d)<strong>在局部内部类中，我们“肯定”能操作外部类的静态变量和静态方法，但是“未必”能操作外部类的成员变量和成员方法。</strong></p>
<p>在局部内部类中，是否能操作外部类的成员变量和成员方法，<strong>关键是看该局部内部类在哪个位置中定义的。</strong></p>
</li>
<li><p>e)<strong>在局部内部类中，想要操作外部的局部变量，则该局部变量必须采用final来修饰，从而保证数据的安全性。</strong></p>
<p><strong>在局部内部类中，如果操作了外部的局部变量，则该局部变量的生命周期就延长了，也就是该局部变量的生命周期和局部内部类对象的生命周期保持一致了。</strong></p>
</li>
<li><p><strong>补充：在JDK1.8之后，如果在局部内部类中使用了外部的局部变量，则该局部变量默认就会采用final来修饰，从而保证数据的安全性。</strong></p>
</li>
<li><p>eg1：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 外部类</span>
<span class="token keyword">class</span> <span class="token class-name">OuterClass</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> age<span class="token punctuation">;</span>
    <span class="token keyword">static</span> String classRoom<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 外部的局部变量</span>
        <span class="token comment" spellcheck="true">/*final*/</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// num出生</span>
        <span class="token comment" spellcheck="true">// 局部内部类</span>
        <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">InnerClass</span> <span class="token punctuation">{</span>
            String name<span class="token punctuation">;</span>
            <span class="token punctuation">{</span><span class="token punctuation">}</span>
            <span class="token keyword">public</span> <span class="token function">InnerClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment" spellcheck="true">// num = 20; --> 编译错误</span>
                <span class="token comment" spellcheck="true">/*System.out.println(age); // 未必
                System.out.println(classRoom); // 没问题*/</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"show ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 实例化InnerClass对象</span>
        InnerClass innerClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InnerClass</span><span class="token punctuation">(</span><span class="token string">"小花"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 调用show()方法</span>
        innerClass<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 如果在局部内部类中，我们没有使用外部的局部变量num，则该变量num就在此处死亡</span>
      <span class="token comment" spellcheck="true">// 如果在局部内部类中，我们使用了外部的局部变量num，则该num就和局部内部类对象的生命周期保持一致啦。</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        OuterClass<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>eg2：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>bjpowernode<span class="token punctuation">.</span>p5<span class="token punctuation">.</span>innerclass<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 需求：调用一个方法，则就返回某个抽象类的实现类对象，并且该实现类必须是一个局部内部类。
 */</span>
<span class="token comment" spellcheck="true">// 抽象类</span>
<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 外部类</span>
<span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 返回Animal的实现类对象</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Animal <span class="token function">getAnimalInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 外部的局部变量</span>
        <span class="token comment" spellcheck="true">/*final*/</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// num出生</span>
        <span class="token comment" spellcheck="true">// 定义一个继承于Animal类的局部内部类</span>
        <span class="token keyword">class</span> <span class="token class-name">Bird</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">/**
             * 此处就是我写的方法，在该eat()方法中我们需要使用num的值，也就是需要使用num的初始值10即可
             */</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小鸟在吃虫子..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token comment" spellcheck="true">/**
             * 这个是同事写的方法，在该方法中需要定义一个变量来保存数据20，如果使用num来保存20，则数据就不安全啦
             */</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// num = 20; --> 编译错误</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 实例化Bird对象（多态）</span>
        Animal bird <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bird</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 返回该局部内部类对象</span>
        <span class="token comment" spellcheck="true">// 因为在局部内部类中，我们没有使用外部的局部变量num，则局部变量num就在此处“死亡”。</span>
        <span class="token comment" spellcheck="true">// 因为在局部内部类中，我们使用了外部的局部变量num，则该局部变量num就和局部内部类对象的生命周期保持一致啦</span>
        <span class="token keyword">return</span> bird<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 获得Animal抽象类的实现类对象</span>
        <span class="token comment" spellcheck="true">// 父类引用指向子类对象（多态）</span>
        <span class="token comment" spellcheck="true">// bird对象的编译时类型为“Animal”，bird对象的运行时类型为“Bird”</span>
        Animal bird <span class="token operator">=</span> Outer<span class="token punctuation">.</span><span class="token function">getAnimalInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 调用eat()方法，涉及到多态情况下调用成员方法的特点</span>
        <span class="token comment" spellcheck="true">// 编译时：检查“编译时类型”，也就是检查Animal类中是否有eat()方法</span>
        <span class="token comment" spellcheck="true">// 运行时：检查“运行时类型”，也就是调用Bird类中的eat()方法。、</span>
        bird<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 执行到此处，则意味着bird对象被销毁，那么则局部变量num也在此处“死亡”</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h4><ol>
<li><p>匿名内部类的引入</p>
<ul>
<li><p>需求1：定义一个方法，在该方法体中定义一个继承于某个抽象类的局部内部类，然后再创建该局部内部类对象并调用方法。</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 需求1：定义一个方法，在该方法体中定义一个继承于某个抽象类的局部内部类，然后再创建该局部内部类对象并调用方法。</span>
<span class="token comment" spellcheck="true">// 抽象类</span>
<span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 外部类</span>
<span class="token keyword">class</span> <span class="token class-name">OuterClass01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 需求：定义继承于Animal类的局部内部类，并且创建该局部内部类对象。</span>
        <span class="token comment" spellcheck="true">// 方式一：使用“局部内部类”来实现</span>
        <span class="token comment" spellcheck="true">/*// 定义一个继承于Animal的局部内部类
        class Bird extends Animal {
            @Override
            public void eat() {
                System.out.println("小鸟在吃虫子...");
            }
        }
        // 实例化Bird对象（多态）
        // bird对象的编译时类型为“Animal”，bird对象的运行时类型为“Bird”
        Animal bird = new Bird();
        // 调用eat()方法，设计到多态情况下调用成员方法的特点
        // 编译时：检查“编译时类型”，也就是检查Animal类中是否有eat()方法
        // 运行时：检查“运行时类型”，也就是调用Bird类中的eat()方法
        bird.eat();*/</span>

        <span class="token comment" spellcheck="true">// 方式二：使用“匿名内部类”来实现</span>
        <span class="token comment" spellcheck="true">// 父类引用指向子类对象（多态）</span>
        <span class="token comment" spellcheck="true">// bird对象的编译时类型为“Animal”，bird对象的运行时类型为“继承于Animal类的实现类”</span>
        Animal bird <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            String name<span class="token punctuation">;</span>

            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"show ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小鸟在吃虫子..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 调用eat()方法，设计到多态情况下调用成员方法的特点</span>
        <span class="token comment" spellcheck="true">// 编译时：检查“编译时类型”，也就是检查Animal类中是否有eat()方法</span>
        <span class="token comment" spellcheck="true">// 运行时：检查“运行时类型”，也就是调用“继承于Animal类的实现类”中的eat()方法</span>
        bird<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 需求：操作匿名内部类中特有的成员变量</span>
        <span class="token comment" spellcheck="true">// 问题：多态情况下，操作成员变量的特点？？？</span>
        <span class="token comment" spellcheck="true">// 编译时：检查“编译时类型”，也就是检查Animal类中是否有name成员变量。</span>
        <span class="token comment" spellcheck="true">// 运行时：检查“编译时类型”</span>
        <span class="token comment" spellcheck="true">// System.out.println(bird.name); // 编译错误</span>

        <span class="token comment" spellcheck="true">// 需求：调用匿名内部类中特有的成员方法</span>
        <span class="token comment" spellcheck="true">// 问题：多态情况下，调用成员方法的特点？？？</span>
        <span class="token comment" spellcheck="true">// 编译时：检查“编译时类型”，也就是检查Animal类中是否有show()方法。</span>
        <span class="token comment" spellcheck="true">// 运行时：检查“运行时类型”</span>
        <span class="token comment" spellcheck="true">// bird.show(); // 编译错误</span>

        <span class="token comment" spellcheck="true">// 方式三：使用“匿名对象+匿名内部类”来实现</span>
        <span class="token comment" spellcheck="true">/*new Animal() {
            @Override
            public void eat() {
                System.out.println("小鸟在吃虫子...");
            }
        }.eat();*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        OuterClass01<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>需求2：定义一个方法，在该方法体中定义一个实现于某个接口的局部内部类，然后再创建该局部内部类对象并调用方法。</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 需求2：定义一个方法，在该方法体中定义一个实现于某个接口的局部内部类，然后再创建该局部内部类对象并调用方法。</span>
<span class="token comment" spellcheck="true">// 接口</span>
<span class="token keyword">interface</span> <span class="token class-name">Flyable</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">showFly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 外部类</span>
<span class="token keyword">class</span> <span class="token class-name">OuterClass02</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 需求：定义一个实现于Flyable接口的局部内部类，然后再创建该局部内部类对象。</span>
        <span class="token comment" spellcheck="true">// 方式一：使用“局部内部类”来实现</span>
        <span class="token comment" spellcheck="true">/*// 定义一个实现于Flyable接口的局部内部类
        class Bird implements Flyable {
            @Override
            public void showFly() {
                System.out.println("小鸟自由自在的飞翔...");
            }
        }
        // 实例化Bird对象（多态）
        // bird对象的编译时类型为“Flyable”，bird对象的运行时类型为“Bird”
        Flyable bird = new Bird();
        // 调用showFly()方法，涉及到多态情况下调用成员方法的特点
        // 编译时：检查“编译时类型”，也就是检查Flyable接口中是否有showFly()方法
        // 运行时：检查“运行时类型”，也就是执行Bird类中的showFly()方法
        bird.showFly();*/</span>

        <span class="token comment" spellcheck="true">// 方式二：使用“匿名内部类”来实现</span>
        <span class="token comment" spellcheck="true">/*// 父类引用指向子类对象（多态）
        // bird对象的编译时类型为“Flyable”，bird对象的运行时类型为“实现于Flyable接口的实现类”
        Flyable bird = new Flyable() {
            @Override
            public void showFly() {
                System.out.println("小鸟自由自在的飞翔...");
            }
        };
        // 调用showFly()方法，涉及到多态情况下调用成员方法的特点
        // 编译时：检查“编译时类型”，也就是检查Flyable接口中是否有showFly()方法
        // 运行时：检查“运行时类型”，也就是执行“实现于Flyable接口的实现类”中的showFly()方法
        bird.showFly();*/</span>

        <span class="token comment" spellcheck="true">// 方式三：使用“匿名对象+匿名内部类”来实现</span>
        <span class="token keyword">new</span> <span class="token class-name">Flyable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showFly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小鸟自由自在的飞翔..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">showFly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        OuterClass02<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>匿名内部类的概述</p>
<ul>
<li><strong>匿名内部类本质就是一个“局部内部类”，也就是一个“没有名字”的局部内部类，也就是一个特殊的局部内部类。</strong></li>
</ul>
</li>
<li><p>匿名内部类的语法</p>
<p>-</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token keyword">class</span> 外部类 <span class="token punctuation">{</span>
       <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 位置一：创建一个继承于某个父类的局部内部类对象，该局部内部类没有名字。</span>
            <span class="token comment" spellcheck="true">// 第一步：定义了一个继承于某个父类的局部内部类，并且该局部内部类没有名字。</span>
            <span class="token comment" spellcheck="true">// 第二步：创建该局部内部类对象，也就是常见了一个没有名字的局部内部类对象。</span>
            <span class="token keyword">new</span> 父类名<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token comment" spellcheck="true">// 书写匿名内部类中的代码</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
        <span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 位置二：创建一个实现于某个接口的局部内部类对象，该局部内部类没有名字。</span>
           <span class="token comment" spellcheck="true">// 第一步：定义一个实现于某个接口的局部内部类，并且该局部内部类没有名字</span>
           <span class="token comment" spellcheck="true">// 第二步：创建该局部内部类对象，也就是常见了一个没有名字的局部内部类对象</span>
            <span class="token keyword">new</span> 接口名<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 书写匿名内部类中的代码</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>匿名内部类的注意点</p>
<ul>
<li>a)匿名内部类就是一个特殊的局部内部类，因此局部内部类的要求对于匿名内部类依旧生效。</li>
<li>b)<strong>在匿名内部类中，我们不能定义构造方法，因为匿名内部类都没有类名，而构造方法名必须为类名。</strong></li>
<li>c)<strong>在匿名内部类中，我们不建议定义自己“特有”的成员变量和成员方法，因为这样不方便我们去操作。</strong></li>
<li><strong>注意：在匿名内部类中，我们一般用于重写父类或接口中的抽象方法。</strong></li>
</ul>
</li>
</ol>
<hr>
<h3 id="DAY16"><a href="#DAY16" class="headerlink" title="DAY16"></a>DAY16</h3><h4 id="异常的概述"><a href="#异常的概述" class="headerlink" title="异常的概述"></a>异常的概述</h4><ol>
<li><p>什么是异常？</p>
<ul>
<li>程序在执行过程中，发生的各种不正常情况，我们就称之为“异常”。</li>
<li>例如：算数异常、数组索引越界异常、空指针异常和类型转换异常等等</li>
</ul>
</li>
<li><p>什么是异常类？</p>
<ul>
<li>用于封装和描述各种不正常情况的类，我们就称之为“异常类”。</li>
<li>例如：ArithmeticException、ArrayIndexOutOfBoundsException、NullPointerException和ClassCastException等等。</li>
</ul>
</li>
<li><p>学习异常的好处？</p>
<ul>
<li><strong>a)学习异常之后，就能够实现把“正常逻辑代码”和“错误逻辑代码”相分离。</strong></li>
<li>b)没有学习异常，则某些情况下无论我们如何处理，则都可能无法满足需求。</li>
</ul>
</li>
<li><p><strong>异常的处理机制？</strong></p>
<ul>
<li>在java语言中，使用面向对象的思想来处理异常。在可能出现问题的位置，我们创建并抛出一个异常对象，该异常对象中封装了异常的详细描述信息（异常类名、异常位置和异常原因），从而实现“正常逻辑代码”和“错误逻辑代码”相分离。</li>
</ul>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 根据索引获得数组元素的值</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果index的取值不合法，则抛出一个异常即可</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">>=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"数组索引越界，index："</span> <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 执行到此处，则证明index取值合法，则返回索引对应的元素值</span>
        <span class="token keyword">int</span> value <span class="token operator">=</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="异常的体系"><a href="#异常的体系" class="headerlink" title="异常的体系"></a>异常的体系</h4><ol>
<li><p>异常体系的引入</p>
<ul>
<li>在程序执行的过程中，可能会发生各种各样的不正常情况，因此我们就需要很多的异常类来封装和描述这些不正常情况，我们对这些异常类进行“向上提取”，那么就得到了异常的继承体系。</li>
</ul>
</li>
<li><p>异常体系的概述</p>
<ul>
<li><p><strong>所有Java类的老祖宗为Object类，所有不正常情况类的老祖宗就是Throwable类，那么Throwable类的继承体系如下：</strong></p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*
Throwable            --> 所有不正常情况类的老祖宗
 |-- Error         --> 所有错误类的老祖宗
 |-- Exception     --> 所有异常类的老祖宗
 */</span>

<span class="token comment" spellcheck="true">//注意：a)如何查看某个类的继承体系呢？？？选中该类，然后使用“ctrl + h”来查看继承体系。</span>
    <span class="token comment" spellcheck="true">// b)所有错误类的后缀都以“Error”来结尾，所有异常类的后缀都以“Exception”来结尾。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>Throwable的概述</p>
<ul>
<li><p><strong>Throwable类是所有不正常情况类的老祖宗，Error类和Exception类都属于Throwable的子类，因此Error类和Exception类都能使用Throwable提供的方法。</strong></p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
      <span class="token comment" spellcheck="true">//作用：返回异常出现的原因。</span>
<span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
      <span class="token comment" spellcheck="true">//作用：返回异常的类名+异常的原因。</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
      <span class="token comment" spellcheck="true">//作用：把异常的类名、异常的位置和异常的原因在控制台输出。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>Error类的概述</p>
<ul>
<li><p><strong>Error类是所有“错误类”的老祖宗，并且Error类继承于Throwable类，因此Error类能使用Throwable类提供的所有方法。</strong></p>
</li>
<li><p><strong>Error描述的是“资源耗尽”或“虚拟机内部错误”等不正常情况，因此开发中遇到这样的不正常情况，我们程序员是无法解决的（不结束程序的前提来解决），也就是程序员只能先结束程序，然后再去重新修改代码来搞定这种不正常情况</strong>，例如：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//案例1：栈内存溢出错误（StackOverflowError）</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">main</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">//案例2：堆内存溢出错误（OutOfMemoryError）</span>
<span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">long</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token operator">*</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 创建数组占用的堆内存为：8GB</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>Exception类的概述</p>
<ul>
<li>Exception类是所有“异常类”的老祖宗，并且Exception类继承于Throwable类，因此Exception类能使用Throwable类提供的所有方法。</li>
<li><strong>Exception类描述的是“程序员能够解决”的不正常情况，开发中我们遇到了Exception异常，则需要拼尽全力去解决该异常（不结束程序的前提来解决）。</strong></li>
<li><strong>Error属于程序员无法解决的不正常情况，而Exception属于程序员能够解决的不正常情况。</strong></li>
</ul>
</li>
<li><p><strong>Error与Exception的区别</strong></p>
<ul>
<li>我开着车走在路上，一头猪冲在路中间，我刹车，这叫一个异常。</li>
<li>我开着车在路上，发动机坏了，我停车，这叫错误。</li>
<li>发动机什么时候坏？我们普通司机能管吗？不能。发动机什么时候坏是汽车厂发动机制造商的事。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="自定义异常类（掌握）"><a href="#自定义异常类（掌握）" class="headerlink" title="自定义异常类（掌握）"></a>自定义异常类（掌握）</h4><ol>
<li><p>自定义异常类的引入</p>
<ul>
<li>问题：给学生年龄复制的时候，则赋值的年龄不能为负数。</li>
<li>解决：如果赋值的年龄为负数，则无论我们给年龄赋值任何数据都不合理，那么最好的方案就是如果年龄不合法就抛出异常。</li>
<li>问题：如果赋值的年龄不合法，则应该抛出“学生年龄不合法异常”，该如何实现？？？</li>
<li><strong>解决：使用“自定义异常类”来解决。</strong></li>
</ul>
</li>
<li><p>什么时候使用自定义异常类</p>
<ul>
<li>当Java语言提供的异常类无法满足我们的需求，则我们就可以使用“自定义异常类”来满足需求。</li>
</ul>
</li>
<li><p>自定义异常类的要求</p>
<ul>
<li><p><strong>要求1：自定义异常类必须继承于异常体系中的类，一般继承于Exception类或RuntimeException类。</strong></p>
<p>–&gt; <strong>只有继承于异常体系的中的类，该类才具备可抛型，也就是才能使用throw和throws关键字。</strong></p>
</li>
<li><p>要求2：自定义异常类必须提供两个构造方法，其中一个为无参构造方法，<strong>另外一个为字符串参数的有参构造方法。</strong></p>
<p> –&gt; <strong>使用字符串参数的有参构造方法，我们可以用于封装和保存异常出现的原因，从而传递给父类的异常来保存。</strong></p>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/**
 * 学生年龄越界异常类
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StudentAgeOutOfBoundsException</span> <span class="token keyword">extends</span> <span class="token class-name">RuntimeException</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/**
     * 无参构造方法
     */</span>
    <span class="token keyword">public</span> <span class="token function">StudentAgeOutOfBoundsException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 有参构造方法
     * @param message 用于保存异常产生的原因
     */</span>
    <span class="token keyword">public</span> <span class="token function">StudentAgeOutOfBoundsException</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>bjpowernode<span class="token punctuation">.</span>p2<span class="token punctuation">.</span>exception<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token function">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token function">Student</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
        <span class="token function">setAge</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">// 假设：学习年龄的合法取值范围在[0, 130]之间</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 1.如果赋值的年龄不合法，则抛出一个异常</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>age <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> age <span class="token operator">>=</span> <span class="token number">130</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 问题：此处我们应该抛出什么异常呢？？？抛出“学生年龄越界异常”</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">StudentAgeOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"赋值的年龄不合法，age："</span> <span class="token operator">+</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 2.执行到此处，则意味着赋值年龄合法，那么就执行赋值操作</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">"Student{"</span> <span class="token operator">+</span>
                <span class="token string">"name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>
                <span class="token string">", age="</span> <span class="token operator">+</span> age <span class="token operator">+</span>
                <span class="token string">'}'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<hr>
</li>
</ol>
<h4 id="异常产生的过程？"><a href="#异常产生的过程？" class="headerlink" title="异常产生的过程？"></a>异常产生的过程？</h4><pre><code>  1.    如果在方法体中抛出了异常，而我们在方法体中又没有处理该异常，则就会把该异常继续抛给方法的上层调用者，也就是抛给方法的上层调用者来处理。
  2.    如果方法的上层调用者依旧没有处理该异常，那么就会继续把该异常抛给方法的上层调用者来处理，以此类推，如果方法的上层调用者都没有处理该异常，那么最终就把该异常抛给了main方法的调用者（虚拟机），而虚拟机也不会处理该异常，那么程序就终止啦。
</code></pre>
<p><img src="https://cherish779.github.io/images/note_images/%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="img"></p>
<hr>
<h4 id="手动抛出异常（throw）"><a href="#手动抛出异常（throw）" class="headerlink" title="手动抛出异常（throw）"></a>手动抛出异常（throw）</h4><ol>
<li><p>在可能出现异常的位置，我们创建并抛出一个异常对象，该异常对象中包含了异常的详细描述信息（异常类名、异常位置和异常原因），从而实现了“正常逻辑代码”和“错误逻辑代码”相分离。</p>
</li>
<li><p>注意：throw关键字只能在方法体中使用，也就是我们只能在方法体中来手动抛出一个异常。</p>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果index的取值不合法，则就抛出数组索引越界异常</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">></span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"数组索引越界异常，index："</span> <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 执行到此处，则意味着index取值合法，那么就返回数组元素</span>
        <span class="token keyword">int</span> value <span class="token operator">=</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="异常的分类（重点）"><a href="#异常的分类（重点）" class="headerlink" title="异常的分类（重点）"></a>异常的分类（重点）</h4><ol>
<li><p>异常的分类的引入？</p>
<ul>
<li><p>问题：“学生年龄越界异常类”继承于Exception类和RuntimeException类的区别?</p>
</li>
<li><p>答案：“学生年龄越界异常类”继承于Exception类，则抛出“学生年龄越界异常”就会出现<strong>编译错误。</strong></p>
<p> “学生年龄越界异常类”继承于RuntimeException类，则抛出 “学生年龄越界异常”就<strong>不会出现编译错误。</strong></p>
</li>
</ul>
</li>
<li><p>异常的分类的概述</p>
<ul>
<li><p><strong>运行时异常</strong></p>
<p>–&gt; 包含：RuntimeException类及其所有子类。</p>
<p>–&gt; 特点：程序编译时，不强制我们对抛出的异常进行处理（可以处理，也可以不处理）</p>
</li>
<li><p>编译时异常</p>
<p>–&gt;包含：Exception类及其所有子类（排除运行时异常）。</p>
<p>–&gt;特点：程序编译时，强制我们对抛出的异常进行处理（必须处理，否则就会编译错误）。</p>
</li>
</ul>
</li>
<li><p>异常的处理的方式</p>
<ul>
<li><p><strong>声明异常（throws）</strong></p>
<p>–&gt; 属于“消极”的处理方式，本质上并没有处理该异常。</p>
</li>
<li><p><strong>捕捉异常（try…catch…finally）</strong></p>
<p>–&gt;属于“积极”的处理方式，本质上已经解决了该异常。</p>
</li>
</ul>
</li>
<li><p>不正常情况的分类补充</p>
<ul>
<li><p><strong>可检查异常（CheckedException）</strong></p>
<p>–&gt;包含：编译时异常</p>
<p>–&gt;特点：<strong>程序在编译时期，能够检查出程序中出现的不正常情况。</strong></p>
</li>
<li><p><strong>不可检查异常（UnCheckedException）</strong></p>
<p>–&gt;包含：Error和运行时异常</p>
<p>–&gt;特点：<strong>程序在编译时期，不能够检查出程序中出现的不正常情况。</strong></p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="面试题【请问throw和throws关键字的区别？】"><a href="#面试题【请问throw和throws关键字的区别？】" class="headerlink" title="面试题【请问throw和throws关键字的区别？】"></a>面试题【请问throw和throws关键字的区别？】</h4><ol>
<li>使用位置区别<ul>
<li>throw：必须在“方法体”中使用。</li>
<li>throws：必须在“方法声明”末尾使用。</li>
</ul>
</li>
<li>操作内容区别<ul>
<li>throw：操作是“异常对象”，只能操作一个异常对象。</li>
<li>throws：操作是“异常类”，可以操作任意多个异常类。</li>
</ul>
</li>
<li>具体作用区别<ul>
<li>throw：抛出异常，如果执行了throw关键字，则肯定会出现异常。</li>
<li>throws：声明异常，如果使用了throws关键字，则未必会出现异常。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="声明异常（throws）"><a href="#声明异常（throws）" class="headerlink" title="声明异常（throws）"></a>声明异常（throws）</h4><ol>
<li><p>声明异常的概述</p>
<ul>
<li>声明异常属于“消极”的处理方式，本质上并没有解决该异常。</li>
<li>程序中出现了异常，此时我们又无法处理该异常，那么就使用声明异常来处理。</li>
</ul>
</li>
<li><p>声明异常的使用？</p>
<ul>
<li>当方法中“可能”会出现异常，此时我们又无法处理该异常，那么就可以使用“声明异常”来处理。也就是在方法声明的末尾，使用throws关键字将方法体中可能抛出的异常声明出来，然后报告给方法的调用者，交给方法的调用者来处理。</li>
</ul>
</li>
<li><p>声明异常的语法？</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> 返回值类型 方法名<span class="token punctuation">(</span>形参列表<span class="token punctuation">)</span> <span class="token keyword">throws</span> 异常类<span class="token number">1</span><span class="token punctuation">,</span> 异常类<span class="token number">2</span><span class="token punctuation">,</span> 异常类<span class="token number">3</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 方法体</span>
     <span class="token keyword">return</span> <span class="token punctuation">[</span>返回值<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token keyword">throws</span> NullPointerException<span class="token punctuation">,</span> ArrayIndexOutOfBoundsException <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果arr的值为null，则就抛出空指针异常</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"空指针异常，arr："</span> <span class="token operator">+</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 如果index的取值不合法，则就抛出数组索引越界异常</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">></span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"数组索引越界异常，index："</span> <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 执行到此处，则意味着index取值合法，那么就返回数组元素</span>
        <span class="token keyword">int</span> value <span class="token operator">=</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> StudentAgeOutOfBoundsException <span class="token punctuation">{</span>
        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/*// 注意：此处我们可以处理该异常，因此应该使用“捕捉异常”来处理。
        Student stu = new Student("卧龙", -18);
        System.out.println(stu);*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="捕捉异常类（try…catch…finally）"><a href="#捕捉异常类（try…catch…finally）" class="headerlink" title="捕捉异常类（try…catch…finally）"></a>捕捉异常类（try…catch…finally）</h4><ol>
<li><p>捕捉异常的概述</p>
<ul>
<li>捕捉异常属于“积极”的处理方式，本质上就已经处理了该异常。</li>
<li>当程序中可能出现异常，此时我们恰好能解决该异常，则就使用捕捉异常来处理。</li>
</ul>
</li>
<li><p>try…catch组合</p>
<ul>
<li><p>语法：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//书写可能出现异常的代码</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类 对象<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//用于处理捕获到的异常。</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>执行：如果try代码块中没有出现异常，则try代码块中的代码正常执行完毕，然后就直接执行try…catch之后的代码。 <strong>如果try代码块中出现了异常，则catch代码块就会立刻捕获到该异常，然后就执行catch代码中的代码，最后再执行try…catch之后的代码。</strong></p>
</li>
</ul>
</li>
<li><p>try…多catch组合</p>
<ul>
<li>语法：</li>
</ul>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">try</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//书写可能出现异常的代码</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类 对象<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//用于处理捕获到的异常</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类 对象<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">//用于处理捕获到的异常</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><p>作用：<strong>使用try…多catch组合，我们可以实现对try代码块中出现的异常进行“针对性”的处理。</strong></p>
</li>
<li><p>注意：</p>
<ol>
<li><p><strong>使用捕捉异常的时候，建议使用“Ctrl + Alt + T”快捷键来生成try…catch…finally代码。</strong></p>
<ul>
<li>选择中可能出现异常的代码，然后使用使用“Ctrl + Alt + T”快捷键来捕捉异常的代码。</li>
</ul>
</li>
<li><p>在JDK1.8之后，则我们还以可以这样来处理：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NullPointerException</span> <span class="token operator">|</span> ArrayIndexOutOfBoundsExceptionexception<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ul>
<li><strong>以上操作不建议使用，因为使用以上操作无法实现对try代码块中出现的异常进行针对性的处理。</strong></li>
</ul>
</li>
<li><p>使用try…多catch组合的时候，建议把子类异常catch放在前面，把父类异常catch放在后面，否则就会编译错误。</p>
<ul>
<li><strong>捕获异常的时候，属于“从上往下”来顺序匹配，如果父类异常catch放前面，则后面的子类异常catch将永远无法执行。</strong></li>
</ul>
</li>
<li><p>try…多catch…finally组合</p>
<ul>
<li><p>语法：</p>
</li>
<li><p>`&#96;&#96;java<br>try{<br>&#x2F;&#x2F;书写可能出现异常的代码<br>}catch(异常类 对象){<br>&#x2F;&#x2F; 用于处理捕获到的异常<br>}<br>catch(异常类 对象){<br>&#x2F;&#x2F; 用于处理捕获到的异常<br>}<br>…<br>finally{<br>&#x2F;&#x2F; 无论是否出现异常，则都会执行finally中代码<br>}</p>
<p>none</p>
<pre class="line-numbers language-none"><code class="language-none">     注意：

   - a)即使在try或catch代码块中执行了return操作，则finally代码块中的代码也依旧会执行。当在try或catch中执行“关闭虚拟机”的操作，那么此时finally代码块中的代码才不会执行。

     -->  **System.exit(0); --> 关闭虚拟机，也就是结束程序，当实参的值为0的时候，代表整除结束程序。**

   - b)实际开发中，我们经常在finally代码块中完成关闭“资源的操作”，例如：关闭IO流、关闭数据库链接。

   - 生活中，打开一个水龙头（打开资源），然后执行洗手的过程中，无论是否出现不正常情况（异常），则我们最终都需要关闭水龙头（关闭资源）。

5. eg：

   ```java
   public class Test03 {
       public static void main(String[] args) {
           try {
               Student stu = new Student("卧龙", -18);
               System.out.println(stu);
               System.exit(0); // 关闭虚拟机，也就是结束程序
           }
           catch (StudentAgeOutOfBoundsException exception) {
               exception.printStackTrace();
               System.exit(0); // 关闭虚拟机，也就是结束程序
           }
           finally {
               // 注意：在此处，以下输出语句不会执行！
               System.out.println("finally");
           }
           // 注意：在此处，以下输出语句不会执行！
           System.out.println("over");
   
           /*try {
               Student stu = new Student("卧龙", -18);
               System.out.println(stu);
               // return; // 先执行完毕finally中的代码，然后才会结束main方法
           }
           catch (StudentAgeOutOfBoundsException exception) {
               exception.printStackTrace();
               return; // 先执行完毕finally中的代码，然后才会结束main方法
           }
           finally {
               // 注意：在此处，无论try中是否发生异常，则都执行并输出了“finally”
               System.out.println("finally");
           }
           // 注意：此处的代码“未必”会执行
           System.out.println("over");*/
   
           /*try {
               Student stu = new Student("卧龙", 18);
               System.out.println(stu);
           }
           catch (StudentAgeOutOfBoundsException exception) {
               exception.printStackTrace();
           }
           finally {
               // 注意：在此处，无论try中是否发生异常，则都执行并输出了“finally”
               System.out.println("finally");
           }
           // 注意：在此处，无论try中是否发生异常，则都执行并输出了“over”
           System.out.println("over");*/
       }
   }
   
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token keyword">throws</span> NullPointerException<span class="token punctuation">,</span> ArrayIndexOutOfBoundsException <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 如果arr的值为null，则就抛出空指针异常</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"空指针异常，arr："</span> <span class="token operator">+</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 如果index的取值不合法，则就抛出数组索引越界异常</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">></span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ArrayIndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"数组索引越界异常，index："</span> <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 执行到此处，则意味着index取值合法，那么就返回数组元素</span>
        <span class="token keyword">int</span> value <span class="token operator">=</span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">22</span><span class="token punctuation">,</span> <span class="token number">33</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NullPointerException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            exception<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            exception<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/*try {
            int[] arr = null; // {11, 22, 33, 44, 55};
            int value = getValue(arr, 12);
            System.out.println(value);
        }
        // 专门对空指针异常和数组索引越界异常进行处理
        catch (NullPointerException | ArrayIndexOutOfBoundsException exception) {
            exception.printStackTrace();
        }*/</span>

        <span class="token comment" spellcheck="true">/*try {
            int[] arr = null; // {11, 22, 33, 44, 55};
            int value = getValue(arr, 12);
            System.out.println(value);
        }
        // 专门处理空指针异常
        catch (NullPointerException exception) {
            exception.printStackTrace();
        }
        // 专门处理数组索引越界异常
        catch (ArrayIndexOutOfBoundsException exception) {
            exception.printStackTrace();
        }
        System.out.println("over");*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//try...finally组合？？？</span>
  语法：<span class="token keyword">try</span> <span class="token punctuation">{</span>
          <span class="token comment" spellcheck="true">// 书写可能出现异常的代码</span>
        <span class="token punctuation">}</span>
       <span class="token keyword">finally</span> <span class="token punctuation">{</span>
<span class="token operator">*</span>           <span class="token comment" spellcheck="true">// 无论是否出现异常，则都会执行finally中代码</span>
<span class="token operator">*</span>        <span class="token punctuation">}</span>
<span class="token operator">*</span>   使用前提：
<span class="token operator">*</span>     前提<span class="token number">1</span>：当<span class="token keyword">try</span>代码块中出现了异常，此时我们又无法处理该异常，因此就必须省略<span class="token keyword">catch</span>代码块，而是使用声明异常来处理。
<span class="token operator">*</span>     前提<span class="token number">2</span>：无论<span class="token keyword">try</span>代码块中是否出现异常，则我们都需要做“关闭资源”的操作，也就是在<span class="token keyword">finally</span>中关闭资源，因此就必须存在<span class="token keyword">finally</span>代码块。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="方法重写之异常（掌握）"><a href="#方法重写之异常（掌握）" class="headerlink" title="方法重写之异常（掌握）"></a>方法重写之异常（掌握）</h4><ol>
<li><p>原则：子类重写方法声明的异常类型必须小于等于父类被重写方法声明的异常类型【辈分】。</p>
<p>–&gt;此处说的异常，指的是编译时异常，而运行时异常不用管！</p>
</li>
<li><p>要求：a)如果父类被重写方法没有声明异常，则子类重写方法也不能声明异常。</p>
<p>b)如果父类被重写方法声明了异常，则子类重写方法声明的异常类型必须小于等于父类被重写方法声明的异常类型（辈分）。</p>
</li>
<li><p>eg</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">AAException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">BBException</span> <span class="token keyword">extends</span> <span class="token class-name">AAException</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> AAException <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Parent show ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token comment" spellcheck="true">// public void show() throws AAException { // 没问题</span>
    <span class="token comment" spellcheck="true">// public void show() throws BBException { // 没问题</span>
    <span class="token comment" spellcheck="true">// public void show() throws Exception { // 编译错误</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> AAException<span class="token punctuation">,</span> BBException <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 没问题</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Child show ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
</li>
</ul>
</li>
</ol>
<h4 id="异常链（了解）"><a href="#异常链（了解）" class="headerlink" title="异常链（了解）"></a>异常链（了解）</h4><ol>
<li><p>解释：在catch代码块中，我们抛出一个描述更加详细的异常，这就是异常链。</p>
<ol>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 分母为零异常类</span>
<span class="token keyword">class</span> <span class="token class-name">DenominatorZeroException</span> <span class="token keyword">extends</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token function">DenominatorZeroException</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token function">DenominatorZeroException</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test03</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">/**
     * 功能：获得两个数相除的结果
     * 问题：a)除法运算，如果分母为0，则不应该返回任何结果，而此处却返回了结果为0。
     *      b)除法运算，如果分母为0，则抛出算数异常，那么意味着异常描述不够清晰。
     * 解决：使用“异常链”来解决。
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">division</span><span class="token punctuation">(</span><span class="token keyword">int</span> fenZi<span class="token punctuation">,</span> <span class="token keyword">int</span> fenMu<span class="token punctuation">)</span> <span class="token keyword">throws</span> DenominatorZeroException <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 1.定义一个变量，用于保存运算的结果</span>
        <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 2.执行除法运算，并处理了可能出现的算数异常</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            result <span class="token operator">=</span> fenZi <span class="token operator">/</span> fenMu<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ArithmeticException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 需求：在此处，我们需要抛出一个描述更加详细的异常</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">DenominatorZeroException</span><span class="token punctuation">(</span><span class="token string">"分母为零异常，fenMu："</span> <span class="token operator">+</span> fenMu<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 3.返回除法运算的结果</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">division</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">DenominatorZeroException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"over"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
</li>
</ol>
<hr>
<h4 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h4><p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>bjpowernode<span class="token punctuation">.</span>p7<span class="token punctuation">.</span>exception<span class="token punctuation">;</span>

<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileInputStream<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>FileNotFoundException<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">/**
 * 1.try-with-resource的引入？？？
 *   在JDK1.8之前，想要实现关闭资源的操作，则必须在finally代码块中完成，这样的操作非常麻烦。
 *   在JDK1.8之后，想要实现关闭资源的操作，则就可以通过try-with-resource来自动关闭资源，也就是无需再finally代码块关闭资源。
 * 2.try-with-resource的语法？？？
 *   try (用于实例化需要关闭资源的对象) {
 *       // 用于书写可能出现异常的代码
 *   }
 *   catch (异常类1 对象) {
 *       // 用于处理捕获到的异常
 *   }
 *   catch (异常类2 对象) {
 *       // 用于处理捕获到的异常
 *   }
 *   ......
 * 3.try-with-resource的概述？？？
 *   只要是AutoCloseable接口的实现类，则都可以使用try-with-resource来自动关闭资源，也就是自动会调用实现于AutoCloseable接口的close()方法。
 */</span>
<span class="token keyword">class</span> <span class="token class-name">AutoCloseableImpl01</span> <span class="token keyword">implements</span> <span class="token class-name">AutoCloseable</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"AutoCloseableImpl01 show ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">"空指针异常"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"AutoCloseableImpl01 close ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">AutoCloseableImpl02</span> <span class="token keyword">implements</span> <span class="token class-name">AutoCloseable</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"AutoCloseableImpl02 show ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"AutoCloseableImpl02 close ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 案例：需要处理两个关闭资源的对象</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span>AutoCloseableImpl01 impl01 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AutoCloseableImpl01</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             AutoCloseableImpl02 impl02 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AutoCloseableImpl02</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            impl01<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            impl02<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            exception<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment" spellcheck="true">/*// 案例：只需要一个关闭资源的对象
        try (AutoCloseableImpl01 impl01 = new AutoCloseableImpl01()) {
            impl01.show();
        } catch (Exception exception) {
            exception.printStackTrace();
        }*/</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 需求：读取demo.txt文件中的内容，然后再控制台输出。</span>
        <span class="token comment" spellcheck="true">// 方式二：使用JDK1.8之后的方案</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span>FileInputStream fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"demo.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 执行读取数据的操作，此代码块无需掌握</span>
            <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                String str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> exception<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            exception<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 方式一：使用JDK1.8之前的方案</span>
        FileInputStream fis <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">// 创建字节输入流，注意：“demo.txt”文件在项目中不存在，则抛出异常</span>
            fis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"demo.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 执行读取数据的操作，此代码块无需掌握</span>
            <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> fis<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                String str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>fis <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment" spellcheck="true">// 关闭流</span>
                    fis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><ol>
<li><p>包装类的引入</p>
<ul>
<li><strong>世界上没有任何一门语言是完全面向对象的，因为面向对象语言中都包含了“基本数据类型”，为了方便“基本数据类型”和“引用数据类型”之间的转换，因此就诞生了“包装类”。</strong></li>
</ul>
</li>
<li><p>包装类的概述？</p>
<ul>
<li><p>明确：每一种基本数据类型都对应一个包装类，因此Java语言中提供的包装类至少有8种。</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">byte</span>	        Byte
<span class="token keyword">short</span>	        Short
<span class="token keyword">int</span>	      	    Integer
<span class="token keyword">long</span>	        Long
<span class="token keyword">float</span>	        Float
<span class="token keyword">double</span>	        Double
<span class="token keyword">char</span>	        Character
<span class="token keyword">boolean</span>	    Boolean
<span class="token comment" spellcheck="true">//注意：除了int类型和char类型之外，其余基本数据类型对应的包装类名都是“首字母大写”即可。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>Number类的概述</p>
<ul>
<li><p>java.lang.Number属于一个抽象类，所有的“数值型包装类”都属于Number的实现类，也就意味着所有的数值型包装类都能使用Number抽象类所提供的方法，并且Number抽象类常见的方法如下：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">byte</span> <span class="token function">byteValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>       <span class="token operator">--</span><span class="token operator">></span> 把数值型包装类对象转化为<span class="token keyword">byte</span>类型
<span class="token keyword">public</span> <span class="token keyword">short</span> <span class="token function">shortValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>     <span class="token operator">--</span><span class="token operator">></span> 把数值型包装类对象转化为<span class="token keyword">short</span>类型
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">int</span> <span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token operator">--</span><span class="token operator">></span> 把数值型包装类对象转化为<span class="token keyword">int</span>类型
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">long</span> <span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">--</span><span class="token operator">></span> 把数值型包装类对象转化为<span class="token keyword">long</span>类型
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">float</span> <span class="token function">floatValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token operator">--</span><span class="token operator">></span> 把数值型包装类对象转化为<span class="token keyword">float</span>类型
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">double</span> <span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">--</span><span class="token operator">></span> 把数值型包装类对象转化为<span class="token keyword">double</span>类型
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>包装类的作用</p>
<ul>
<li><p>作为和基本数据类型对应的类型存在，方便涉及到对象的操作，如Object[]、集合等的操作。</p>
</li>
<li><p>包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法(这些操作方法的作用是在基本数据类型、包装类对象、字符串之间提供相互之间的转化)。</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"int类型表示的最大值："</span> <span class="token operator">+</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"int类型表示的最小值："</span> <span class="token operator">+</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"byte类型表示的最大值："</span> <span class="token operator">+</span> Byte<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"byte类型表示的最小值："</span> <span class="token operator">+</span> Byte<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/*// 问题：数组的定义？？？数组就是一个存储“相同数据类型”的“有序”集合（容器）。
        // 涉及到的技术：向上转型+自动装箱
        Object[] arr = {123, 3.14, true, 'a', "abc", new Test01()};
        System.out.println(Arrays.toString(arr));*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="基本数据类型和包装类之间的转换"><a href="#基本数据类型和包装类之间的转换" class="headerlink" title="基本数据类型和包装类之间的转换"></a>基本数据类型和包装类之间的转换</h4><ol>
<li><p>包装类的底层</p>
<ul>
<li><strong>所谓的包装类，则底层中定义了一个对应基本数据类型的“私有常量”来保存数据，包装类其实就是对基本数据类型的数据执行封装的操作。</strong></li>
<li>例如：在Integer包装类中，其底层定义了一个int类型的“私有常量”来保存数据，也就是Integer包装类就是对int类型数据执行的封装操作。</li>
</ul>
</li>
<li><p>基本数据类型转化为包装类</p>
<ul>
<li><p>方式一：通过构造方法来实现</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token function">Integer</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//作用：把基本数据类型转化为包装类对象。</span>
<span class="token keyword">public</span> <span class="token function">Integer</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token keyword">throws</span> NumberFormatException <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
          <span class="token comment" spellcheck="true">//作用：把字符串的内容转化为包装类对象。</span>
          <span class="token comment" spellcheck="true">//注意：当字符串存储的内容和对应的基本数据类型的数据格式不匹配的时候，则就会抛出“数值格式化异常”</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>方式二：通过valueOf()静态方法来实现</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
          <span class="token comment" spellcheck="true">//作用：把基本数据类型转化为包装类对象。</span>
       <span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token keyword">throws</span> NumberFormatException <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
          <span class="token comment" spellcheck="true">//作用：把字符串的内容转化为包装类对象。</span>
          <span class="token comment" spellcheck="true">//注意：当字符串存储的内容和对应的基本数据类型的数据格式不匹配的时候，则就会抛出“数值格式化异常”。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>注意事项</strong></p>
<ul>
<li>1、<strong>针对Character类型，字符串不能转化为Character类型的包装类对象，因为Character类没有提供字符串参数的构造方法和字符串参数的valueOf()方法。</strong></li>
<li>2、针对Boolean类型，只有字符串为“true”（不区分大小写）的时候，转化为包装对象的值才为true，否则一律都为false。</li>
<li>3、<strong>数值型的包装类中（不包含Character和Boolean），形参字符串的内容为必须为数值型，否则抛出NumberFormatException异常。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>包装类转化为基本数据类型？</strong></p>
<ul>
<li><p><strong>情况一：数值型包装类</strong></p>
<p>–&gt; 数值型包装类都是Number抽象类的实现类，因此数值型包装类使用Number抽象类提供的方法，我们就可以实现把“数值型包装类对象”转化为“数值型”。</p>
</li>
<li><p><strong>情况二：非数值型包装类</strong></p>
<p>–&gt; 针对Character类型，我们可以使用Character类中提供的charValue()方法，从而将“Character对象”转化为对应的“char类型”。</p>
<p>–&gt; 针对Boolean类型，我们可以使用Boolean类中提供的booleanValue()方法，从而将“Boolean对象”转化为对应的“boolean类型”。</p>
</li>
</ul>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Boolean aBoolean <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Boolean</span><span class="token punctuation">(</span><span class="token string">"TrUe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> flag <span class="token operator">=</span> aBoolean<span class="token punctuation">.</span><span class="token function">booleanValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：true</span>

        <span class="token comment" spellcheck="true">/*Character character = new Character('a');
        char ch = character.charValue();
        System.out.println(ch); // 输出：a*/</span>

        <span class="token comment" spellcheck="true">/*Double aDouble02 = Double.valueOf("5.12");
        int num1 = aDouble02.intValue();
        double num2 = aDouble02.doubleValue();
        long num3 = aDouble02.longValue();*/</span>

        <span class="token comment" spellcheck="true">/*Integer integer = Integer.valueOf(123);
        int num1 = integer.intValue();
        double num2 = integer.doubleValue();
        long num3 = integer.longValue();*/</span>

        <span class="token comment" spellcheck="true">/*Boolean aBoolean01 = new Boolean("TrUe");
        System.out.println(aBoolean01); // 输出：true

        Boolean aBoolean02 = Boolean.valueOf("abc");
        System.out.println(aBoolean02); // 输出：false*/</span>

        <span class="token comment" spellcheck="true">/*// 方式二：通过valueOf()静态方法来实现
        Integer integer01 = Integer.valueOf(123);
        System.out.println(integer01); // 输出：123
        Integer integer02 = Integer.valueOf("520");
        System.out.println(integer02); // 输出：520

        Double aDouble01 = Double.valueOf(3.14);
        System.out.println(aDouble01); // 输出：3.14
        Double aDouble02 = Double.valueOf("5.12");
        System.out.println(aDouble02); // 输出：5.12*/</span>

        <span class="token comment" spellcheck="true">/*// 方式一：通过构造方法来实现
        Integer integer01 = new Integer(123);
        System.out.println(integer01); // 输出：123
        Integer integer02 = new Integer("520");
        System.out.println(integer02); // 输出：520

        Double aDouble01 = new Double(3.14);
        System.out.println(aDouble01); // 输出：3.14
        Double aDouble02 = new Double("5.12");
        System.out.println(aDouble02); // 输出：5.12*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h3 id="DAY17"><a href="#DAY17" class="headerlink" title="DAY17"></a>DAY17</h3><h4 id="自动装箱和自动拆箱（超级重点）"><a href="#自动装箱和自动拆箱（超级重点）" class="headerlink" title="自动装箱和自动拆箱（超级重点）"></a>自动装箱和自动拆箱（超级重点）</h4><ol>
<li><p><strong>自动装箱和自动拆箱的概述</strong></p>
<ul>
<li>在JDK1.5之前，想要实现“基本数据类型”和“包装类”之间的转换，则必须通过调用包装类的方法来手动完成，此操作比较麻烦。</li>
<li>在JDK1.5之后，想要实现“基本数据类型”和“包装类”之间的转换，则我们可以通过自动装箱和自动拆箱来完成，此操作非常简单。</li>
</ul>
</li>
<li><p><strong>自动装箱机制的概述？</strong></p>
<ul>
<li><p>解释：当基本数据类型处于需要对象的环境中，则就会触发自动装箱机制，也就是自动会把基本数据类型转化为对应的包装类对象。</p>
</li>
<li><p>底层：当触发自动装箱机制的时候，则默认就会调用包装类的valueOf(xxx x)静态方法，从而将基本数据类型转化为包装类对象。</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//例如：Integer integer = 123;  --底层--> Integer integer = Integer.valueOf(123);</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p><strong>自动拆箱机制的概述？</strong></p>
<ul>
<li>解释：当包装类对象处于需要基本数据类型的环境中，则就会触发自动拆箱机制，也就是自动会把包装类对象转化为对应的基本数据类型。</li>
<li>底层：当触发自动拆箱机制的时候，则默认就会调用包装类的xxxValue()成员方法，从而将包装类对象转化为对应的基本数据类型。</li>
<li>例如：int num &#x3D; new Integer(123); –底层–&gt; int num &#x3D; new Integer(123).intValue();</li>
</ul>
</li>
<li><p><strong>自动装箱的缓存问题？</strong></p>
<ul>
<li><p>解释：当“整数型”的数据取值范围在[-128, 127]之间的时候，如果触发了自动装箱机制，则就会从“缓存池”中取出一个包装类对象并返回，也就是不会创建新的包装类对象并返回。</p>
</li>
<li><p>当“整数型”的数据取值范围在[-128, 127]之外的时候，如果触发了自动装箱机制，则就会直接创建一个新的包装类对象并返回，也就是不会从缓存池中取出包装类对象来返回。</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">底层：<span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">// 如果i的取值在[-128, 127]之间，则直接从“缓存池”中取出一个Integer对象并返回</span>
         <span class="token comment" spellcheck="true">// 备注：此处IntegerCache属于一个Integer类中的“私有静态内部类”。</span>
         <span class="token comment" spellcheck="true">// IntegerCache.low：此处low属于int类型的静态常量，并且默认值为：-128</span>
         <span class="token comment" spellcheck="true">// IntegerCache.high：此处high属于int类型的静态常量，并且默认值为：127</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>
             <span class="token comment" spellcheck="true">// IntegerCache.cache：此处cache属于Integer数组类型的静态常量，数组中存储的元素依次为[-128, 127]之间的Integer对象</span>
             <span class="token comment" spellcheck="true">// IntegerCache.cache[i + (-IntegerCache.low)]：返回整数i所对应的Integer对象，例如i的值为127，则就返回127的Integer对象，也就是返回cache数组中的最后一个元素</span>
             <span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
         <span class="token comment" spellcheck="true">// 如果i的取值在[-128, 127]之外，则创建一个新的Integer对象并返回</span>
         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p><strong>自动拆箱的空指针问题？</strong></p>
<ul>
<li><p>解释：<strong>当触发自动拆箱机制的时候，则默认就会调用包装类的xxxValue()成员方法，如果该包装对象为null，那么触发自动拆箱机制就会抛出空指针异常。</strong></p>
<p>–&gt; <strong>例如：Integer integer &#x3D; null; int num &#x3D; integer; &#x2F;&#x2F; 等效于： int num &#x3D; integer.intValue();</strong></p>
</li>
</ul>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Integer integer <span class="token operator">=</span> null<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 此处Integer对象处于需要int类型的环境中，那么就会触发自动拆箱机制</span>
        <span class="token keyword">int</span> num <span class="token operator">=</span> integer<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 等效于： int num = integer.intValue();</span>


        <span class="token comment" spellcheck="true">/*Integer integer01 = 128;
        Integer integer02 = 128;
        System.out.println(integer01 == integer02);      // 输出：false
        System.out.println(integer01.equals(integer02)); // 输出：true*/</span>

        <span class="token comment" spellcheck="true">/*Integer integer01 = 123;
        Integer integer02 = 123;
        System.out.println(integer01 == integer02);      // 输出：true
        System.out.println(integer01.equals(integer02)); // 输出：true*/</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment" spellcheck="true">/*// 此处3.14出于需要Double对象的环境中，则就会触发自动装箱机制，也就是会把3.14从double类型转化为Double对象，然后再赋值
        Double num = 3.14;
        // 此处123出于需要Integer对象的环境中，则就会触发自动装箱机制，也就是会把123从int类型转化为Integer对象，然后再赋值
        Integer integer = method01(123);
        System.out.println(integer);*/</span>

        <span class="token comment" spellcheck="true">/*// 此处Double对象处于需要基本数据类型的环境中，则就会触发自动拆箱机制，也就是会把Double对象转化为double类型，然后再赋值
        double num1 = Double.valueOf(3.14);
        // 此处Integer对象处于需要基本数据类型的环境中，则就会触发自动拆箱机制，也就是会把Integer对象转化为int类型，然后再赋值
        int num2 = method02(new Integer(123));
        System.out.println(num2);*/</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">method02</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 此处Integer对象处于需要基本数据类型的环境中，则就会触发自动拆箱机制，也就是会把Integer对象转化为int类型，然后再作为返回值</span>
        <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">method01</span><span class="token punctuation">(</span>Integer integer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 此处456出于需要Integer对象的环境中，则就会触发自动装箱机制，也就是会把456从int类型转化为Integer对象，然后再作为返回值</span>
        <span class="token keyword">return</span> <span class="token number">456</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="十进制和别的进制之间的转换"><a href="#十进制和别的进制之间的转换" class="headerlink" title="十进制和别的进制之间的转换"></a>十进制和别的进制之间的转换</h4><ol>
<li><p>十进制转化为别的进制？</p>
<ul>
<li><p>明确：把十进制转化为别的进制，则我们需要使用integer包装类提供的静态方法来实现。</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 作用：把十进制转化为二进制</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">toBinaryString</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 作用：把十进制转化为八进制，返回的结果没有添加前缀“0”</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">toOctalString</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 作用：把十进制转化为十六进制，返回的结果没有添加前缀“0x”。</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">toHexString</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>别的进制转化为十进制？</p>
<ul>
<li><p>明确：把别的进制转化为十进制，则我们需要使用Integer包装类提供的“int parseInt(String str, int radix)”静态方法来实现。</p>
<p>–&gt; 参数：str用于保存需要转化为数据，此处str保存的数据可以为“二进制”、“八进制”和“十六进制”的数据。 radix用于保存str属于何种进制，例如str保存的数据为二进制，则radix赋值的内容就是2。</p>
</li>
<li><p><strong>注意：八进制转化为十进制的时候，则str保存的八进制可以添加前缀“0”；十六进制转化为十进制的时候，则str保存的十六进制不能添加前缀“0x”</strong></p>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test03</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 需求：把二进制转化为十进制</span>
        <span class="token keyword">int</span> num1 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"10111"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：23</span>

        <span class="token comment" spellcheck="true">// 需求：把八进制转化为十进制</span>
        <span class="token keyword">int</span> num2 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"054"</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：44</span>

        <span class="token comment" spellcheck="true">// 需求：把十六进制转化为十进制</span>
        <span class="token keyword">int</span> num3 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token string">"2B"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：43</span>

        <span class="token comment" spellcheck="true">/*// 需求：把十进制转化为二进制
        String bitStr1 = Integer.toBinaryString(23);
        System.out.println(bitStr1); // 输出：10111

        // 需求：把十进制转化为八进制
        String bitStr2 = Integer.toOctalString(44);
        System.out.println(bitStr2); // 输出：54

        // 需求：把十进制转化为十六进制
        String bitStr3 = Integer.toHexString(43);
        System.out.println(bitStr3); // 输出：2B*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="基本数据类型和字符串之间的转换"><a href="#基本数据类型和字符串之间的转换" class="headerlink" title="基本数据类型和字符串之间的转换"></a>基本数据类型和字符串之间的转换</h4><ol>
<li><p><strong>字符串转化为基本数据类型（重要）</strong></p>
<ul>
<li><p>明确：<strong>使用包装类提供的parseXxx(String str)的静态方法来实现。</strong></p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">Byte	    <span class="token keyword">static</span> <span class="token keyword">byte</span> <span class="token function">parseByte</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>	        <span class="token comment" spellcheck="true">//将字符串参数解析为带符号的十进制byte 。</span>
Short	    <span class="token keyword">static</span> <span class="token keyword">short</span> <span class="token function">parseShort</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>	    <span class="token comment" spellcheck="true">//将字符串参数解析为带符号的十进制short 。</span>
Integer	<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>	        <span class="token comment" spellcheck="true">//将字符串参数解析为带符号的十进制int。</span>
Long	    <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">parseLong</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> 	    <span class="token comment" spellcheck="true">//将字符串参数解析为带符号的十进制long。</span>
Float	    <span class="token keyword">static</span> <span class="token keyword">float</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>	    <span class="token comment" spellcheck="true">//返回一个新 float值，该值被初始化为用指定字符串表示的值。</span>
Double	    <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">parseDouble</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>	    <span class="token comment" spellcheck="true">//返回一个新 double值，该值被初始化为用指定字符串表示的值。</span>
 Boolean	<span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">parseBoolean</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>	<span class="token comment" spellcheck="true">//将字符串参数解析为boolean值。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>注意事项：</p>
<ul>
<li>1.<strong>不能把字符串转化为char类型，因为Character包装类中没有提供parseChar(String value)方法。</strong></li>
<li>2.针对Boolean类型，只有字符串为“true”的时候（不区分大小写），转化为基本类型的值才为true，否则都为false。</li>
<li>3.<strong>整数型包装类，字符串中的内容必须是十进制整数；浮点型包装类中，字符串中的内容必须为十进制整数或浮点数，否则抛出NumberFormatException异常。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>基本数据类型转化为字符串（了解）</p>
<ul>
<li><p>明确：<strong>把基本数据类型转换为字符串，我们可以使用“+”连接符来实现，也可以使用包装类提供的方法来实现。</strong></p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">所有包装类	String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	                返回对象的字符串表示形式。
Byte	    <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">byte</span> b<span class="token punctuation">)</span>	    把<span class="token keyword">byte</span>类型转化为字符串返回。
Short	    <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">short</span> s<span class="token punctuation">)</span>	    把<span class="token keyword">short</span>类型转化为字符串返回。
Integer	<span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>	    把<span class="token keyword">int</span>类型转化为字符串返回。
Long	    <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">long</span> i<span class="token punctuation">)</span>	    把<span class="token keyword">long</span>类型转化为字符串返回。
Float	    <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">float</span> f<span class="token punctuation">)</span>	    把<span class="token keyword">float</span>类型转化为字符串返回。
Double	    <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">)</span>	把<span class="token keyword">double</span>类型转化为字符串返回。
Boolean	<span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> b<span class="token punctuation">)</span>	把<span class="token keyword">boolean</span>类型转化为字符串返回。
Character	<span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span>	    把<span class="token keyword">char</span>类型转化为字符串返回。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 需求：把int类型的数据转化为字符串类型</span>
        String str1 <span class="token operator">=</span> <span class="token number">123</span> <span class="token operator">+</span> <span class="token string">""</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：123</span>

        String str2 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：123</span>

        <span class="token comment" spellcheck="true">/*boolean flag1 = Boolean.parseBoolean("TrUe");
        System.out.println(flag1); // 输出：true

        boolean flag2 = Boolean.parseBoolean("abc");
        System.out.println(flag2); // 输出：false*/</span>

        <span class="token comment" spellcheck="true">/*// 把字符串转化为基本数据类型
        int num1 = Integer.parseInt("123");
        System.out.println(num1); // 输出：123
        double num2 = Double.parseDouble("3.14");
        System.out.println(num2); // 输出：3.14
        boolean flag = Boolean.parseBoolean("true");
        System.out.println(flag);*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="字符串的创建方式"><a href="#字符串的创建方式" class="headerlink" title="字符串的创建方式"></a>字符串的创建方式</h4><ol>
<li><p>方式一：通过双引号来创建字符串</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">String str <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>方式二：通过new+构造方法来创建字符串</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">String str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
</ol>
<p><img src="https://cherish779.github.io/images/note_images/%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E5%BC%8F.png" alt="img"></p>
<hr>
<h4 id="字符串常量池的概述"><a href="#字符串常量池的概述" class="headerlink" title="字符串常量池的概述"></a>字符串常量池的概述</h4><ul>
<li><p><strong>加载类的时候</strong>，如果该类中有双引号创建的字符串，则就<strong>把该字符串在常量池中开辟存储空间并存储，并且常量池中存储的字符串都是唯一的。</strong></p>
</li>
<li><p><strong>执行程序的时候</strong>，如果遇到了双引号创建的字符串，则<strong>直接去常量池中取出该字符串并使用即可，也就是不会再次去创建一个新的字符串。</strong></p>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 通过双引号创建字符串</span>
        String str1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 通过构造方法创建字符串</span>
        String str2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 比较地址</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：false</span>
        <span class="token comment" spellcheck="true">// equals方法比较字符串内容</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：true</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String str1 <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
        String str2 <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 输出：true</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：true</span>

        <span class="token comment" spellcheck="true">/*String str1 = new String("hello world");
        String str2 = new String("hello world");
        System.out.println(str1 == str2);      // 输出：false
        System.out.println(str1.equals(str2)); // 输出：true*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<hr>
<h4 id="字符类（String）"><a href="#字符类（String）" class="headerlink" title="字符类（String）"></a>字符类（String）</h4><ol>
<li><p>String类的概述</p>
<ul>
<li>在字符串中，存储的是任意多个字符，这些字符以char类型的数组来存储的。<strong>在String类中，char类型的数组默认采用了final来修饰</strong>，也就意味着<strong>char类型的数组不能扩容</strong>，也就是<strong>字符串中存储的字符内容不可改变，因此我们称String为“不可变的Unicode编码序列”，简称“不可变字符串”。</strong>并且，<strong>String类还采用了final修饰，则意味着String类不能被继承。</strong></li>
</ul>
</li>
<li><p>String类的构造方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	                <span class="token comment" spellcheck="true">//初始化新创建的String对象，使其表示空字符序列（不会使用）。</span>
<span class="token function">String</span><span class="token punctuation">(</span>String original<span class="token punctuation">)</span>	<span class="token comment" spellcheck="true">//初始化新创建的String对象，新创建的字符串是参数字符串的副本。</span>
<span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes<span class="token punctuation">)</span>	    <span class="token comment" spellcheck="true">//通过使用平台的默认字符集解码指定的字节数组来构造新的String。</span>
<span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">)</span>	    <span class="token comment" spellcheck="true">//分配一个新的String，以便它表示当前包含在字符数组参数中的字符序列。</span>
<span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">byte</span> bytes<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//从bytes数组索引为offset位置开始截取length个元素并组成一个字符串。</span>
<span class="token function">String</span><span class="token punctuation">(</span><span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//从value数组索引为offset位置开始截取count个元素并组成一个字符串。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 需求：从value数组索引为offset位置开始截取count个元素并组成一个字符串。</span>
        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        String str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：cdefg</span>

        <span class="token comment" spellcheck="true">/*// 需求：从bytes数组索引为offset位置开始截取length个元素并组成一个字符串。
        byte[] bytes = {97, 98, 99, 100, 101, 102, 103};
        String str = new String(bytes, 1, 4);
        System.out.println(str); // 输出：bcde*/</span>

        <span class="token comment" spellcheck="true">/*//  需求：创建一个字符串，要求字符串内容为字符数组来指定，并且底层的char类型数组空间长度有“字符数组的空间长度”来决定
        char[] chars = {'a', 'b', 'c', 'd'};
        String str = new String(chars);
        System.out.println(str); // 输出：abcd*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：创建一个字符串，要求字符串内容为字节数组来指定，并且底层的char类型数组空间长度有“字节数组的空间长度”来决定
        byte[] bytes = {97, 98, 99, 100};
        String str = new String(bytes);
        System.out.println(str); // 输出：abcd*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：创建一个字符串，要求字符串中存储指定内容，并且底层的char类型数组空间长度为：指定字符串的空间长度
        String str = new String("abc");
        System.out.println(str); // 输出：abc*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：创建一个字符串，要求字符串中没有存储任何内容，并且底层的char类型数组空间长度为0
        String str = new String();
        System.out.println(str); // 输出：*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="String类-的查找方法"><a href="#String类-的查找方法" class="headerlink" title="String类 的查找方法"></a>String类 的查找方法</h4><ol>
<li><p>length()方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//作用：获得字符串的长度，也就是获得底层char类型数组的空间长度。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>charAt()方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">char</span> <span class="token function">charAt</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//作用：根据索引获得字符串中的字符。</span>
<span class="token comment" spellcheck="true">//注意：index取值范围在[0, 字符串长度-1]之间，超出范围则就会抛出StringIndexOutOfBoundsException异常</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>indexOf()方法</p>
<ul>
<li><p>明确：“从前往后”查找某个“字符”或“子串”在“主串”中的索引位置，如果查找的“字符”或“字串”不存在，则返回-1</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">)</span>	                <span class="token comment" spellcheck="true">//返回指定字符第一次出现在字符串内的索引。</span>
<span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">)</span>	    <span class="token comment" spellcheck="true">//返回指定字符第一次出现在字符串内的索引，以指定的索引开始搜索。</span>
<span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span>	            <span class="token comment" spellcheck="true">//返回指定子字符串第一次出现在字符串内的索引。</span>
<span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">)</span>	<span class="token comment" spellcheck="true">//返回指定子串的第一次出现在字符串中的索引，从指定的索引开始搜索。</span>
<span class="token comment" spellcheck="true">//注意：此处indexOf()方法的底层使用“字符串匹配算法”来实现，常见的字符串匹配算法有：BF算法和KMP算法。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>lastIndexOf()方法</p>
<ul>
<li><p>明确：“从后往前”查找某个“字符”或“子串”在“主串”中的索引位置，如果查找的“字符”或“字串”不存在，则返回-1</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">)</span>	                <span class="token comment" spellcheck="true">//返回指定字符最后一次出现在字符串内的索引。</span>
<span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> ch<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">)</span>	    <span class="token comment" spellcheck="true">//返回指定字符最后一次出现在字符串内的索引，以指定的索引开始搜索。</span>
<span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span>	            <span class="token comment" spellcheck="true">//返回指定子字符串最后一次出现在字符串内的索引。</span>
<span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">)</span>	<span class="token comment" spellcheck="true">//返回指定子串的最后一次出现在字符串中的索引，从指定的索引开始搜索。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>startsWith()方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">startsWith</span><span class="token punctuation">(</span>String prefix<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 作用：判断某个字符串是否以prefix开头。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>endsWith()方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">endsWith</span><span class="token punctuation">(</span>String suffix<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//作用：判断某个字符串是否以suffix结尾</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>contains()方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span>CharSequence s<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//作用：判断字符串中是否包含某个子串（开头、中间和结尾）</span>
<span class="token comment" spellcheck="true">//注意：此处CharSequence是一个接口，该接口的实现类有String、StringBuffer和StringBuilder</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 需求：判断字符串是否包含“baidu”这个字串</span>
        String path <span class="token operator">=</span> <span class="token string">"http://www.baidu.com"</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"baidu"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：true</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出：true</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"com"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 输出：true</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"xixi"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 输出：false</span>

        <span class="token comment" spellcheck="true">/*// 需求：判断字符串是否以“com”结尾
        String path = "http://www.baidu.com";
        System.out.println(path.endsWith("com")); // 输出：true
        System.out.println(path.endsWith("cn"));  // 输出：false*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：判断字符串是否以“http”开头
        String path = "http://www.baidu.com";
        System.out.println(path.startsWith("http"));  // 输出：true
        System.out.println(path.startsWith("https")); // 输出：false*/</span>


        <span class="token comment" spellcheck="true">/*String str = "hello hello";
        System.out.println(str.lastIndexOf("llo", 6)); // 输出：2
        System.out.println(str.lastIndexOf("xixi", 6)); // 输出：-1*/</span>

        <span class="token comment" spellcheck="true">/*String str = "hello hello";
        System.out.println(str.lastIndexOf("llo")); // 输出：8
        System.out.println(str.lastIndexOf("xixi")); // 输出：-1*/</span>

        <span class="token comment" spellcheck="true">/*String str = "hello hello";
        System.out.println(str.lastIndexOf('e', 6)); // 输出：1
        System.out.println(str.lastIndexOf('a', 6)); // 输出：-1*/</span>

        <span class="token comment" spellcheck="true">/*String str = "hello hello";
        System.out.println(str.lastIndexOf('e')); // 输出：7
        System.out.println(str.lastIndexOf('a')); // 输出：-1*/</span>

        <span class="token comment" spellcheck="true">/*String str = "hello hello";
        System.out.println(str.indexOf("llo", 5)); // 输出：8
        System.out.println(str.indexOf("xixi", 5)); // 输出：-1*/</span>

        <span class="token comment" spellcheck="true">/*String str = "hello hello";
        System.out.println(str.indexOf("llo")); // 输出：2
        System.out.println(str.indexOf("xixi")); // 输出：-1*/</span>

        <span class="token comment" spellcheck="true">/*String str = "hello hello";
        System.out.println(str.indexOf('e', 5)); // 输出：7
        System.out.println(str.indexOf('a', 5)); // 输出：-1*/</span>

        <span class="token comment" spellcheck="true">/*String str = "hello hello";
        System.out.println(str.indexOf('e')); // 输出：1
        System.out.println(str.indexOf('a')); // 输出：-1*/</span>

        <span class="token comment" spellcheck="true">/*String str = "hello world";
        char ch1 = str.charAt(0);
        System.out.println(ch1); // 输出：h
        char ch2 = str.charAt(9);
        System.out.println(ch2); // 输出：l
        char ch3 = str.charAt(12); // 抛出字符串索引越界异常*/</span>

        <span class="token comment" spellcheck="true">/*String str = "hello world";
        System.out.println(str.length());*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="String类转换的方法"><a href="#String类转换的方法" class="headerlink" title="String类转换的方法"></a>String类转换的方法</h4><ol>
<li><p>字符串转数组</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">split</span><span class="token punctuation">(</span>String regex<span class="token punctuation">)</span>	<span class="token comment" spellcheck="true">//将一个字符串分割为子字符串，并返回字符串数组</span>
<span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	        <span class="token comment" spellcheck="true">//将此字符串转换为新的字符数组。</span>
<span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	            <span class="token comment" spellcheck="true">//得到一个操作系统默认的编码格式的字节数组</span>
<span class="token comment" spellcheck="true">//注意：在UTF-8编码中，中文汉字占用3个字节，英文字母占用1个字节。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>字符串大小写转换</p>
<ul>
<li><p>明确：字符串大小写转换，针对“英文字母”有效，针对“中文汉字”无效。</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">String <span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	<span class="token comment" spellcheck="true">//返回一个新的字符串，该字符串中所有英文字符转换为大写字母。</span>
String <span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	<span class="token comment" spellcheck="true">//返回一个新的字符串，该字符串中所有英文字符转换为小写字母。</span>
<span class="token comment" spellcheck="true">//注意：执行注册或登录操作的时候，就需要使用字符型大小写转换来校对验证码。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>忽略字符串前后空格</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//忽略字符串前后端的空格，中间的空格不用忽略</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>字符串的截取操作</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">String <span class="token function">substring</span><span class="token punctuation">(</span><span class="token keyword">int</span> beginIndex<span class="token punctuation">)</span>	            <span class="token comment" spellcheck="true">//从beginIndex开始截取字符串，到字符串末尾结束。</span>
<span class="token comment" spellcheck="true">// 注意：此处beginIndex的取值范围在[0, 字符串长度-1]之间。</span>
    
String <span class="token function">substring</span><span class="token punctuation">(</span><span class="token keyword">int</span> beginIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> endIndex<span class="token punctuation">)</span>	<span class="token comment" spellcheck="true">//从beginIndex开始截取字符串，到字符索引endIndex-1结束。</span>
    <span class="token comment" spellcheck="true">//注意：beginIndex的取值范围在[0, 字符串长度-1]之间，endIndex的取值范围在[0, 字符串长度]之间，并且endIndex必须大于beginIndex</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>字符串的替换操作</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 通过用newChar字符替换字符串中出现的所有oldChar字符，并返回替换后的新字符串。</span>
String <span class="token function">replace</span><span class="token punctuation">(</span><span class="token keyword">char</span> oldChar<span class="token punctuation">,</span> <span class="token keyword">char</span> newChar<span class="token punctuation">)</span>	
    
<span class="token comment" spellcheck="true">//将与字面目标序列匹配的字符串的每个子字符串替换为指定的字面替换序列。</span>
String <span class="token function">replace</span><span class="token punctuation">(</span>CharSequence target<span class="token punctuation">,</span> CharSequence replacement<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>字符串拼接的操作</p>
<ul>
<li>明确：我们可以使用“+”连接符来实现字符串的评价操作，也可以使用String类提供的“String concat(String str)”方法来实现。</li>
</ul>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 需求：完成字符串的拼接操作</span>
        String str1 <span class="token operator">=</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">"world"</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：helloworld</span>

        String str2 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：helloworld</span>

        <span class="token comment" spellcheck="true">/*// 需求：把字符串中的“CD”替换为“成都”
        String str = "hello CD hello CD";
        String replaceStr = str.replace("CD", "成都");
        System.out.println(replaceStr); // 输出：hello 成都 hello 成都*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：把字符串中的'C'替换为'成'
        String str = "hello CD hello CD";
        String replaceStr = str.replace('C', '成');
        System.out.println(replaceStr); // 输出：hello 成D hello 成D*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：截取字符串索引为[1, 8]之间的字符串
        String str = "hello world";
        String subStr = str.substring(1, 9);
        System.out.println(subStr); // 输出：ello wor*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：从索引为2的位置开始截取字符串，一直截取到字符串的末尾
        String str = "hello world";
        String subStr = str.substring(2);
        System.out.println(subStr); // 输出：llo world*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：忽略字符串前后端的空格，中间的空格不用忽略
        String str = "   hello   world   ";
        String trimStr = str.trim();
        System.out.println("aa" + trimStr + "aa"); // 输出：aahello   worldaa*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：把小写字母转化为大写字母
        String str = "hello";
        String upperCaseStr = str.toUpperCase();
        System.out.println(upperCaseStr); // 输出：HELLO
        // 需求：把大写字母转化为小写字母
        String lowerCaseStr = upperCaseStr.toLowerCase();
        System.out.println(lowerCaseStr); // 输出：hello*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：把字符串转化为字节数组
        String str = "你好";
        byte[] bytes = str.getBytes();
        System.out.println(Arrays.toString(bytes)); // 输出：[-28, -67, -96, -27, -91, -67]*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：把字符串转化为字节数组
        String str = "abcd";
        byte[] bytes = str.getBytes();
        System.out.println(Arrays.toString(bytes)); // 输出：[97, 98, 99, 100]*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：把字符串转化为char类型的数组
        String str = "hello";
        char[] chars = str.toCharArray();
        System.out.println(Arrays.toString(chars));*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：根据空格来分割字符串，分割的子串组成一个字符串类型的数组
        String str = "hello xixi world haha";
        String[] arr = str.split(" ");
        System.out.println(Arrays.toString(arr));*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="String类的其他方法"><a href="#String类的其他方法" class="headerlink" title="String类的其他方法"></a>String类的其他方法</h4><ol>
<li><p>isEmpty方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//作用：判断字符串是否为空，也就是判断底层的char类型数组空间长度是否为0</span>
 <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>equals方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object anObject<span class="token punctuation">)</span>	    <span class="token comment" spellcheck="true">//判断字符串内容是否相同，区分字母大小写。</span>
<span class="token keyword">boolean</span> <span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span>	<span class="token comment" spellcheck="true">//判断字符串内容是否相同，忽略字母大小写。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>valueOf方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">String类提供了<span class="token function">valueOf</span><span class="token punctuation">(</span>xxx x<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//这个静态方法，该方法用于将其他的数据类型转化为字符串。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test03</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String str1 <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String str2 <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String str3 <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String str4 <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Test03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">/*String str1 = "hEllo";
        String str2 = "hello";
        System.out.println(str1.equalsIgnoreCase(str2)); // 输出：true*/</span>

        <span class="token comment" spellcheck="true">/*String str1 = "hello";
        String str2 = "hello";
        System.out.println(str1.equalsIgnoreCase(str2)); // 输出：true*/</span>

        <span class="token comment" spellcheck="true">/*String str1 = "hEllo";
        String str2 = "hello";
        System.out.println(str1.equals(str2)); // 输出：false*/</span>

        <span class="token comment" spellcheck="true">/*String str1 = "hello";
        String str2 = "hello";
        System.out.println(str1.equals(str2)); // 输出：true*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：判断str字符串是否为空
        String str = "hello";
        boolean isEmpty = str.isEmpty();
        System.out.println(isEmpty); // 输出：true*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：判断str字符串是否为空
        String str = "";
        boolean isEmpty = str.isEmpty();
        System.out.println(isEmpty); // 输出：true*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="StringBuffer类的概述"><a href="#StringBuffer类的概述" class="headerlink" title="StringBuffer类的概述"></a>StringBuffer类的概述</h4><ul>
<li>StringBuffer类继承于AbstractStringBuilder抽象类，StringBuffer类底层维护者一个char类型的数组，并且该char类型的数组没有使用final修饰，也就意味着该char类型的数组可以自动扩容，也就是该char类型数组存储的元素可以改变，因此我们就称StringBuffer类为“可变的Unicode编码序列”，简称“可变字符串”。并且，StringBuffer类采用了final修饰，也就意味着StringBuffer不能被继承。</li>
</ul>
<hr>
<h4 id="String类和StringBuffer类特点"><a href="#String类和StringBuffer类特点" class="headerlink" title="String类和StringBuffer类特点"></a>String类和StringBuffer类特点</h4><ol>
<li><p>相同点：</p>
<ul>
<li>a)底层都维护者一个char类型的数组，也就是存储的都是字符，因此都属于“字符串”。</li>
<li>b)这个两个类都采用了final修饰，也就意味着String和StringBuffer都不能被继承。</li>
</ul>
</li>
<li><p>不同点：</p>
<ul>
<li><p>String类底层的char类型数组使用了final修饰，因此String类存储的字符内容不可改变，我们就称之为“不可变字符串”。</p>
<p>–&gt; 通过String类提供的方法来操作字符串中的内容时，都不是直接基于char类型数组做的操作，那么都会返回一个新的字符串。</p>
</li>
<li><p>StringBuffer类底层的char类型数组没有使用final修饰，因此StringBuffer类存储的字符内容可以改变，我们就称之为“可变字符串”。</p>
<p>–&gt; 通过StringBuffer类提供方法来操作字符串中的内容，都是直接基于char类型数组做的操作，因此就可以无需返回新的字符串。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="StringBuffer类的构造方法"><a href="#StringBuffer类的构造方法" class="headerlink" title="StringBuffer类的构造方法"></a>StringBuffer类的构造方法</h4><p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token function">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>	                <span class="token comment" spellcheck="true">//构造一个没有字符的字符串缓冲区，初始容量为16个字符（有用）。</span>
<span class="token function">StringBuffer</span><span class="token punctuation">(</span>CharSequence seq<span class="token punctuation">)</span>	<span class="token comment" spellcheck="true">//构造一个包含与指定的相同字符的字符串缓冲区CharSequence 。</span>
<span class="token function">StringBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span>	    <span class="token comment" spellcheck="true">//构造一个没有字符的字符串缓冲区和指定的初始容量。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test01</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 需求：实例化StringBuffer对象，并且可变字符串中没有指定设置内容，而且底层的char类型数组空间长度为：形参的值</span>
        StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：</span>

        <span class="token comment" spellcheck="true">/*// 需求：实例化StringBuffer对象，并且可变字符串内容可以自定义设置，而且底层的char类型数组空间长度为：形参长度 + 16
        StringBuffer sb = new StringBuffer("hello");
        System.out.println(sb); // 输出：hello*/</span>

        <span class="token comment" spellcheck="true">/*// 需求：实例化StringBuffer对象，并且可变字符串中没有指定设置内容，而且底层的char类型数组空间长度为：16
        StringBuffer sb = new StringBuffer();
        System.out.println(sb); // 输出：*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<hr>
<h4 id="StringBuffer类的方法"><a href="#StringBuffer类的方法" class="headerlink" title="StringBuffer类的方法"></a>StringBuffer类的方法</h4><p>明确：如果StringBuffer类提供方法的返回值类型为StringBuffer或AbstractStringBuilder，则该返回值就是“当前方法的调用者对象”。</p>
<ol>
<li><p>添加的方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//作用：在可变字符串末尾添加内容。</span>
<span class="token keyword">public</span> AbstractStringBuilder <span class="token function">append</span><span class="token punctuation">(</span>Type type<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 作用：在可变字符串索引为offset位置插入字符串内容。</span>
 <span class="token keyword">public</span> AbstractStringBuilder <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> offset<span class="token punctuation">,</span> Type type<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
 
 <span class="token comment" spellcheck="true">//注意：此处offset的取值范围在[0, 可变字符串长度]之间，超出范围则就会抛出“字符串索引越界异常”。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>替换的方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//作用：把可变字符串索引为index的字符替换为ch即可。</span>
 <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">setCharAt</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
 <span class="token comment" spellcheck="true">//  注意：此处index的取值范围在[0, 可变字符串长度 - 1]之间，超出范围则就会抛出“字符串索引越界异常”。</span>
 
<span class="token comment" spellcheck="true">//作用：把可变字符串索引为[start, end)之间的元素替换为str即可。</span>
 <span class="token keyword">public</span> <span class="token keyword">synchronized</span> StringBuffer <span class="token function">replace</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> String str<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
 <span class="token comment" spellcheck="true">//注意：此处start的取值范围[0, 可变字符串长度 - 1]之间，end的取值范围在[0, 可变字符串长度]之间，并且end必须大于start。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>删除的方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//作用：删除可变字符串中索引为index的字符。</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> StringBuffer <span class="token function">deleteCharAt</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// 注意：此处index的取值范围在[0, 可变字符串长度 - 1]之间，超出范围则就会抛出“字符串索引越界异常”。</span>

<span class="token comment" spellcheck="true">//作用：删除索引为[start, end)范围之间的元素。</span>
 <span class="token keyword">public</span> <span class="token keyword">synchronized</span> StringBuffer <span class="token function">delete</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
 <span class="token comment" spellcheck="true">//注意：此处start的取值范围[0, 可变字符串长度 - 1]之间，end的取值范围在[0, 可变字符串长度]之间，并且end必须大于start。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>查找的方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span>	                    <span class="token comment" spellcheck="true">//返回 char在指定索引在这个序列值。</span>
<span class="token function">indexOf</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span>	                <span class="token comment" spellcheck="true">//返回指定子字符串第一次出现的字符串内的索引。</span>
<span class="token function">indexOf</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">)</span>	    <span class="token comment" spellcheck="true">//返回指定子串的第一次出现的字符串中的索引，从指定的索引开始。</span>
<span class="token function">lastIndexOf</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span>	            <span class="token comment" spellcheck="true">//返回指定子字符串最右边出现的字符串内的索引。</span>
<span class="token function">lastIndexOf</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">)</span>	<span class="token comment" spellcheck="true">//返回指定子字符串最后一次出现的字符串中的索引，从指定的索引开始。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>反转的方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">synchronized</span> StringBuffer <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 把可变字符串中的内容进行反转操作
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li><p>操作字符串长度的方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 作用：获得可变字符串的长度</span>
 <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">int</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 作用：修改可变字符串的长度。</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">setLength</span><span class="token punctuation">(</span><span class="token keyword">int</span> newLength<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">//注意：如果“设置的长度”大于“可变字符串的长度”，则默认做“扩容操作”。</span>
<span class="token comment" spellcheck="true">//如果“设置的长度”小于“可变字符串的长度”，则默认做“剪切操作”。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>字符串截取的方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token function">substring</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">)</span>	        <span class="token comment" spellcheck="true">//返回一个新的 String ，其中包含此字符序列中当前包含的字符的子序列。</span>
<span class="token function">substring</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span>	<span class="token comment" spellcheck="true">//返回一个新的 String ，其中包含此序列中当前包含的字符的子序列。</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>转化为String类的方法</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 作用：把StringBuffer对象转化为String类型。</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>eg：</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String str <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：hello</span>

        <span class="token comment" spellcheck="true">/*StringBuffer sb = new StringBuffer("hello");
        sb.setLength(3);
        System.out.println(sb); // 输出：hel*/</span>

        <span class="token comment" spellcheck="true">/*StringBuffer sb = new StringBuffer("hello");
        sb.setLength(10);
        System.out.println("aa" + sb + "aa"); // 输出：aahello     aa*/</span>

        <span class="token comment" spellcheck="true">/*StringBuffer sb = new StringBuffer("hello world");
        int length = sb.length();
        System.out.println(length); // 输出：11*/</span>

        <span class="token comment" spellcheck="true">/*StringBuffer sb = new StringBuffer("abc");
        sb.reverse();
        System.out.println(sb); // 输出：cba*/</span>

        <span class="token comment" spellcheck="true">/*StringBuffer sb = new StringBuffer("hello world");
        sb.delete(2, 10);
        System.out.println(sb);  // 输出：hed*/</span>

        <span class="token comment" spellcheck="true">/*StringBuffer sb = new StringBuffer("hello world");
        sb.deleteCharAt(1);
        System.out.println(sb); // 输出：hllo world*/</span>

        <span class="token comment" spellcheck="true">/*StringBuffer sb = new StringBuffer("hello CD hello");
        sb.replace(6, 8, "成都市");
        System.out.println(sb); // 输出：hello 成都市 hello*/</span>

        <span class="token comment" spellcheck="true">/*StringBuffer sb = new StringBuffer("hello CD");
        sb.setCharAt(6, '成');
        System.out.println(sb); // 输出：hello 成D*/</span>

        <span class="token comment" spellcheck="true">/*StringBuffer sb = new StringBuffer("hello");
        sb.insert(3, true);
        sb.insert(9, 123);
        System.out.println(sb); // 输出：heltruelo123*/</span>

        <span class="token comment" spellcheck="true">/*StringBuffer sb = new StringBuffer("hello");
        StringBuffer stringBuffer = sb.append(123);
        System.out.println(stringBuffer == sb); // 输出：true*/</span>

        <span class="token comment" spellcheck="true">/*StringBuffer sb = new StringBuffer("hello");
        sb.append(123);
        sb.append(true);
        System.out.println(sb); // 输出：hello123true*/</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<hr>
<h4 id="StringBuilder类的概述"><a href="#StringBuilder类的概述" class="headerlink" title="StringBuilder类的概述"></a>StringBuilder类的概述</h4><ul>
<li>StringBuilder类继承于AbstractStringBuilder抽象类，StringBuilder类底层维护者一个char类型的数组，并且该char类型的数组没有使用final修饰，也就意味着该char类型的数组可以自动扩容，也就是StringBuilder类存储的字符内容可以改变，因此我们就称呼StringBuilder类为“可变的Unicode编码序列”，简称“可变字符串”。并且，StringBuilder类采用final修饰，也就意味着StringBuilder不能被继承。</li>
</ul>
<hr>
<h4 id="StringBuffer类和StringBuilder类的特点"><a href="#StringBuffer类和StringBuilder类的特点" class="headerlink" title="StringBuffer类和StringBuilder类的特点"></a>StringBuffer类和StringBuilder类的特点</h4><ol>
<li>相同点<ul>
<li>a)底层都包含char类型的数组，并且该char类型的数组都没使用final修饰，因此都称之为“可变字符串”。</li>
<li>b)这两个类都采用了final关键字来修饰，也就意味着StringBuffer类和StringBuilder类都不能被继承。</li>
<li>c)都继承于AbstractStringBuilder抽象类，并且这两个类拥有的方法都相同，因此使用方法属于类似的。</li>
</ul>
</li>
<li>不同点<ul>
<li>StringBuffer：线程安全的，会做线程同步检查，因此效率较低（不常用）。</li>
<li>StringBuilder：线程不安全的，不会做线程同步检查，因此效率较高（常用）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="使用“-”连接符完成字符串拼接操作的底层分析（重点）"><a href="#使用“-”连接符完成字符串拼接操作的底层分析（重点）" class="headerlink" title="使用“+”连接符完成字符串拼接操作的底层分析（重点）"></a>使用“+”连接符完成字符串拼接操作的底层分析（重点）</h4><ol>
<li><p>情况一：两个字符串都是常量时，使用“+”来完成拼接操作</p>
<ul>
<li><p>底层：因为常量保存的内容不可改变，也就是编译时期就能确定常量的值，因此为了提高字符串的拼接效率，所以就在编译时期就完成了拼接操作。</p>
</li>
<li><p>eg1:</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">String str <span class="token operator">=</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">"world"</span><span class="token punctuation">;</span> 
编译之后：String str <span class="token operator">=</span> <span class="token string">"helloworld"</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li><p>eg2:</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> String STR1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> 
<span class="token keyword">final</span> String STR2 <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span> 
String str <span class="token operator">=</span> STR1 <span class="token operator">+</span> STR2<span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">//编译之后：String str = "helloworld";</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
<li><p>情况二：其中一个为字符串变量时，使用“+”来完成拼接操作</p>
<ul>
<li><p>底层：因为编译时期无法确定变量的值，因此其中一个为字符串变量的拼接操作，那么肯定不是在编译时期完成，而是在运行时期来完成的，并且实现步骤如下。</p>
</li>
<li><p><strong>eg1:【重点】</strong></p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java">例如：分析“String hw <span class="token operator">=</span> str <span class="token operator">+</span> <span class="token string">"world"</span>”代码的底层实现过程
 <span class="token operator">*</span>      第一步：创建一个StringBuilder对象，用于字符串的拼接操作。
 <span class="token operator">*</span>         <span class="token operator">--</span><span class="token operator">></span> StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">*</span>      第二步：调用sb对象的<span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法，用于拼接str字符串。
 <span class="token operator">*</span>         <span class="token operator">--</span><span class="token operator">></span> sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">*</span>      第三步：调用sb对象的<span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法，用于拼接<span class="token string">"world"</span>。
 <span class="token operator">*</span>         <span class="token operator">--</span><span class="token operator">></span> sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token operator">*</span>      第四步：调用sb对象的<span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法，然后再去做赋值操作
 <span class="token operator">*</span>         <span class="token operator">--</span><span class="token operator">></span> String hw <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>eg2:</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test02</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String str <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
        String hw <span class="token operator">=</span> str <span class="token operator">+</span> <span class="token string">"world"</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 情况一：两个字符串都是常量时，使用“+”来完成拼接操作
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method02</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> String STR1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
        <span class="token keyword">final</span> String STR2 <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>
        String str <span class="token operator">=</span> STR1 <span class="token operator">+</span> STR2<span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 以上三行代码，在编译之后的结果就是：String str = "helloworld";</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment" spellcheck="true">/**
     * 情况一：两个字符串都是常量时，使用“+”来完成拼接操作
     */</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method01</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        String str <span class="token operator">=</span> <span class="token string">"hello"</span> <span class="token operator">+</span> <span class="token string">"world"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 编译之后：String str = "helloworld";</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="三种字符串的拼接效率（重点）"><a href="#三种字符串的拼接效率（重点）" class="headerlink" title="三种字符串的拼接效率（重点）"></a>三种字符串的拼接效率（重点）</h4><ol>
<li><p>System.currentTimeMillis()方法的概述？</p>
<ul>
<li>作用：获得“当前时间”距离1970年1月1日凌晨的毫秒数。</li>
<li>–&gt; 公式：1秒 &#x3D; 1000毫秒</li>
<li>使用：计算完成某个功能所需要的耗时，则就可以使用该方法来实现。</li>
<li>–&gt; 耗时：结束时间 - 开始时间</li>
</ul>
</li>
<li><p>三种字符串的拼接效率？</p>
<ul>
<li><p><strong>StringBuilder的拼接效率最高，StringBuffer的拼接效率次之，String的拼接效率最低。</strong></p>
</li>
<li><p>注意：<strong>如果需要大量执行字符串的拼接操作，则建议使用StringBuilder类来完成拼接操作。</strong></p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test03</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> COUNT <span class="token operator">=</span> <span class="token number">60000</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Arrays<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"String类拼接的耗时："</span> <span class="token operator">+</span> <span class="token function">stringAppend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"StringBuffer类拼接的耗时："</span> <span class="token operator">+</span> <span class="token function">stringBufferAppend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"StringBuilder类拼接的耗时："</span> <span class="token operator">+</span> <span class="token function">stringBuilderAppend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">stringBuilderAppend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 1.定义一个变量，用于保存开始时间距离1970年1月1日凌晨的毫秒数</span>
        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 2.通过普通for循环，完成StringBuilder类的COUNT次拼接操作</span>
        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> COUNT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 3.定义一个变量，用于保存结束时间距离1970年1月1日凌晨的毫秒数</span>
        <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 4.返回StringBuilder拼接的耗时</span>
        <span class="token keyword">return</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">stringBufferAppend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 1.定义一个变量，用于保存开始时间距离1970年1月1日凌晨的毫秒数</span>
        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 2.通过普通for循环，完成StringBuffer类的COUNT次拼接操作</span>
        StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> COUNT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 3.定义一个变量，用于保存结束时间距离1970年1月1日凌晨的毫秒数</span>
        <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 4.返回StringBuffer拼接的耗时</span>
        <span class="token keyword">return</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">stringAppend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 1.定义一个变量，用于保存开始时间距离1970年1月1日凌晨的毫秒数</span>
        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 2.通过普通for循环，完成String类的COUNT次拼接操作</span>
        String str <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> COUNT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            str <span class="token operator">+=</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用StringBuilder来完成的拼接</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 3.定义一个变量，用于保存结束时间距离1970年1月1日凌晨的毫秒数</span>
        <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 4.返回String拼接的耗时</span>
        <span class="token keyword">return</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 需求：计算完成1+2+3+...+999999+1000000功能的耗时</span>
        <span class="token comment" spellcheck="true">// 1.定义一个变量，用于保存开始时间距离1970年1月1日凌晨的毫秒数</span>
        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 2.完成1+2+3+...+9999999+10000000这个功能</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10000000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment" spellcheck="true">// 3.定义一个变量，用于保存结束时间距离1970年1月1日凌晨的毫秒数</span>
        <span class="token keyword">long</span> end <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 4.计算完成该功能所需要的耗时</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"耗时："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="链式调用语法（了解）"><a href="#链式调用语法（了解）" class="headerlink" title="链式调用语法（了解）"></a>链式调用语法（了解）</h4><p>理解：每个成员方法体中都返回this，也就是每个成员方法体中都返回该方法的调用者对象。</p>
<ol>
<li><p>问题：在目前已经学习的类中，哪些类支持链式调用语法呢？？？</p>
<ul>
<li><p>答案：StringBuilder和StringBuffer</p>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test04</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>         
        <span class="token comment" spellcheck="true">// 需求：让学生完成吃饭、睡觉和打豆豆的操作</span>
        <span class="token comment" spellcheck="true">// 方式一：不使用链式调用语法来实现</span>
        Student stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stu<span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stu<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stu<span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment" spellcheck="true">// 方式二：使用链式调用语法来完成</span>
        <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>java</p>
<pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> Student <span class="token function">eat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"吃饭"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> Student <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"睡觉"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> Student <span class="token function">play</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"打豆豆"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
</li>
</ol>
</li>
<li><p>public class Test02 {<br>public static int getValue(int[] arr, int index) throws NullPointerException, ArrayIndexOutOfBoundsException {<br>    &#x2F;&#x2F; 如果arr的值为null，则就抛出空指针异常<br>    if (arr &#x3D;&#x3D; null) {<br>        throw new NullPointerException(“空指针异常，arr：” + arr);<br>    }<br>    &#x2F;&#x2F; 如果index的取值不合法，则就抛出数组索引越界异常<br>    if (index &lt; 0 || index &gt; arr.length) {<br>        throw new ArrayIndexOutOfBoundsException(“数组索引越界异常，index：” + index);<br>    }<br>    &#x2F;&#x2F; 执行到此处，则意味着index取值合法，那么就返回数组元素<br>    int value &#x3D; arr[index];<br>    return value;<br>}<br><br>public static void main(String[] args) {<br>    try {<br>        int[] arr &#x3D; {11, 22, 33, 44, 55};<br>        int value &#x3D; getValue(arr, 12);<br>        System.out.println(value);<br>    }<br>    catch (NullPointerException exception) {<br>        exception.printStackTrace();<br>    }<br>    catch (Exception exception) {<br>        exception.printStackTrace();<br>    }<br>    System.out.println(“over”);<br><br>    &#x2F;*try {<br>        int[] arr &#x3D; null; &#x2F;&#x2F; {11, 22, 33, 44, 55};<br>        int value &#x3D; getValue(arr, 12);<br>        System.out.println(value);<br>    }<br>    &#x2F;&#x2F; 专门对空指针异常和数组索引越界异常进行处理</p>
</li>
</ul>
</li>
</ol>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">勾魂大猩猩</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://stars998.github.io/2022/08/19/11/">https://stars998.github.io/2022/08/19/11/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">勾魂大猩猩</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">无标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2022/08/19/11/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="">
                        
                        <span class="card-title"></span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-08-19
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            勾魂大猩猩
                            
                        </span>
                    </div>
                </div>

                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/08/18/MySQL/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/16.jpg" class="responsive-img" alt="MySQL学习笔记">
                        
                        <span class="card-title">MySQL学习笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-08-18
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            勾魂大猩猩
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">
                        <span class="chip bg-color">MySQL学习笔记</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>






<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFunction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="tencent"
                   type="playlist"
                   id="8417170055"
                   fixed='true'
                   autoplay='true'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2022</span>
            
            <a href="/about" target="_blank">勾魂大猩猩</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/stars998/stars998.github.io" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:93713797@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=93713797" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 93713797" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
