<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL</title>
      <link href="/2022/08/22/MySQL%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/22/MySQL%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1><center> MySQL</center><hr><h2 id="数据库的相关概念"><a href="#数据库的相关概念" class="headerlink" title="数据库的相关概念"></a>数据库的相关概念</h2><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><ul><li>表达形式：多种表现形式：文本，图形，音频，视频。</li></ul><h4 id="数据库（Database，DB）"><a href="#数据库（Database，DB）" class="headerlink" title="数据库（Database，DB）"></a>数据库（Database，DB）</h4><ul><li>存放数据的仓库，存放在计算机中，按照一定的格式存放，可为用户共享</li></ul><h4 id="数据库管理系统（Database-Management-System-DBMS）"><a href="#数据库管理系统（Database-Management-System-DBMS）" class="headerlink" title="数据库管理系统（Database Management System, DBMS）"></a>数据库管理系统（Database Management System, DBMS）</h4><ul><li>数据库管理系统就是科学的组织和存储数据，高效的获取和维护数据，</li><li>市面上常用的：Oracle MySQL SQL Server  DB2</li></ul><h4 id="数据库应用程序（DBAS）"><a href="#数据库应用程序（DBAS）" class="headerlink" title="数据库应用程序（DBAS）"></a>数据库应用程序（DBAS）</h4><ul><li>在数据库系统基础上，使用数据库管理系统的语法，开发的直接面对最终用户的应用程序</li><li>例如：学生管理系统、人事管理系统、图书管理系统</li></ul><h4 id="数据库管理员（Database-Administrator-DBA）"><a href="#数据库管理员（Database-Administrator-DBA）" class="headerlink" title="数据库管理员（Database Administrator, DBA）"></a>数据库管理员（Database Administrator, DBA）</h4><ul><li>数据库管理系统的操作者</li></ul><h4 id="最终用户"><a href="#最终用户" class="headerlink" title="最终用户"></a>最终用户</h4><ul><li>数据库应用程序的使用者</li></ul><h4 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h4><ul><li><p>数据库 + 数据库管理系统 + 数据库应用程序 + 最终用户</p><p><img src="/images/MySQL/DB.jpg" alt="DB"></p></li></ul><h4 id="数据库的发展阶段"><a href="#数据库的发展阶段" class="headerlink" title="数据库的发展阶段"></a>数据库的发展阶段</h4><ol><li><p>网状数据库</p></li><li><p>层次数据库</p></li><li><p>关系数据库</p><ul><li><p>采用关系[二维表]存储与管理数据</p></li><li><p>采用结构化查询结构（sql）作为客户端数据库服务器之间沟通的桥梁</p></li></ul></li></ol><h4 id="NOSQL数据库"><a href="#NOSQL数据库" class="headerlink" title="NOSQL数据库"></a>NOSQL数据库</h4><ul><li>Not only sql数据库 泛指非关系数据库。</li><li>关系数据库在超大规模和高并发的web2.0纯属动态网站已经显示力不从心，暴露了很多难以克服的问题。Nosql数据库的产生就是为了解决大无框数据集合多重数据种类带来的挑战，尤其是大数据应用难题</li></ul><h2 id="数据库相关基础操作"><a href="#数据库相关基础操作" class="headerlink" title="数据库相关基础操作"></a>数据库相关基础操作</h2><h4 id="数据库的启动与停止"><a href="#数据库的启动与停止" class="headerlink" title="数据库的启动与停止"></a>数据库的启动与停止</h4><ul><li>方式一<ul><li>打开任务管理器，点击服务，找到MySQL右击启动或者停止</li></ul></li><li>方式二<ul><li>打开dos窗口，输入命令，net start mysql  启动，net stop mysql  停止</li></ul></li></ul><h4 id="使用root账户登陆"><a href="#使用root账户登陆" class="headerlink" title="使用root账户登陆"></a>使用root账户登陆</h4><ul><li>mysql -uroot -p123456<ul><li>root  是默认的用户名—超级管理员</li><li>123456  是之前我们安装的时候设置的默认密码</li></ul></li></ul><h4 id="显示所有数据库"><a href="#显示所有数据库" class="headerlink" title="显示所有数据库"></a>显示所有数据库</h4><ul><li><p>命令</p><pre class="line-numbers language-mysql"><code class="language-mysql">show databases;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="默认库几个库的简单说明"><a href="#默认库几个库的简单说明" class="headerlink" title="默认库几个库的简单说明"></a>默认库几个库的简单说明</h4><ul><li><p><strong>information_schema</strong></p><ul><li>information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式。什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。</li><li>在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件</li></ul></li><li><p><strong>mysql</strong></p><ul><li>这个是mysql的核心数据库，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。不可以删除，如果对mysql不是很了解，也不要轻易修改这个数据库里面的表信息。</li></ul></li><li><p><strong>performance_schema</strong></p><ul><li>mysql 5.5 版本 新增了一个性能优化的引擎： PERFORMANCE_SCHEMA这个功能默认是关闭的：</li><li>需要设置参数： performance_schema 才可以启动该功能，这个参数是静态参数，只能写在my.cnf 中 不能动态修改。</li><li>windows里面叫 my.ini文件  C:\ProgramData\MySQL\MySQL Server 5.7  【默认在这个目录】linux里面叫my.cnf文件</li></ul></li><li><p><strong>sys</strong></p><ul><li><p>通过这个库可以快速的了解系统的元数据信息</p><p>这个库确实可以方便DBA发现数据库的很多信息，解决性能瓶颈都提供了巨大帮助</p></li></ul></li><li><p><strong>注</strong>：以上几个库都不能删除（重点）</p></li></ul><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><ul><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">use  <数据库名称>;-- 例如：使用mysql数据库use mysql;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>修改数据库密码</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">1使用mysql数据库use mysql;2修改密码命令(将root用户的密码修改为123456)update mysql.user set authentication_string=PASSWORD('123456') where user='root;3刷新flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><ul><li><p>命令</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">CREATE USER 'username'@'host' IDENTIFIED BY 'password';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>说明：</p><ul><li>username：你将创建的用户名</li><li>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%</li><li>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</li></ul></li><li><p>列如：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#创建dog用户密码为123456 并且限制只能在本机上登录访问CREATE USER 'dog'@'localhost' IDENTIFIED BY '123456';#创建pig用户密码为123456 并且限制只能在指定的ip（192.168.1.101）登录访问CREATE USER 'pig'@'192.168.1.101_' IDENDIFIED BY '123456';#创建pig用户密码为123456 并且可以通过任意远程主机登录访问CREATE USER 'pig'@'%' IDENTIFIED BY '123456';#创建pig用户输入任意密码即可登录并且可以通过任意远程主机登录访问CREATE USER 'pig'@'%' IDENTIFIED BY '';#创建pig用户没有密码并且可以通过任意远程主机登录访问CREATE USER 'pig'@'%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="给用户授权"><a href="#给用户授权" class="headerlink" title="给用户授权"></a>给用户授权</h4><ul><li><p>命令</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">GRANT privileges ON databasename.tablename TO 'username'@'host'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>说明：</p><ul><li>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL</li><li>databasename：数据库名</li><li>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，</li></ul></li><li><p>例如：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#给pig用户授权 给 test库里面 的user表 查询和插入权限并且可以通过任意主机访问GRANT SELECT, INSERT ON test.user TO 'pig'@'%';#给pig用户授权 给所有库的所有表 增删改查的权限并且可以通过任意主机访问GRANT ALL ON *.* TO 'pig'@'%'; #给pig用户授权 给 maindataplus库里面 的所有表 增删改查权限并且可以通过任意主机访问GRANT ALL ON maindataplus.* TO 'pig'@'%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注：用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">GRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h2><h4 id="DDL数据定义语言"><a href="#DDL数据定义语言" class="headerlink" title="DDL数据定义语言"></a>DDL数据定义语言</h4><ul><li><p>全称Data Definition Language，主要用于创建和删除结构。</p><ol><li><p>创建结构相关操作：表、视图、索引、数据 </p></li><li><p>删除结构相关操作：表、视图、索引、数据</p></li><li><p>改变结构相关操作：表、视图、索引、数据</p></li></ol></li></ul><h4 id="DML数据操纵语言"><a href="#DML数据操纵语言" class="headerlink" title="DML数据操纵语言"></a>DML数据操纵语言</h4><ul><li><p>DML对表和视图进行插入、删除、更新相关操作，全称Data Manipulation Language。</p><ol><li><p>插入数据关键字：insert</p></li><li><p>删除数据关键字：delete</p></li><li><p>修改数据关键字：update</p></li></ol></li></ul><h4 id="DQL数据查询语言"><a href="#DQL数据查询语言" class="headerlink" title="DQL数据查询语言"></a>DQL数据查询语言</h4><ul><li>对表和视图进行操作，全称： Data Query Language<ol><li>DQL关键字 select</li></ol></li></ul><h4 id="TCL事务控制语言"><a href="#TCL事务控制语言" class="headerlink" title="TCL事务控制语言"></a>TCL事务控制语言</h4><ul><li><p>TCL全称Transaction Control Language，使用事务管理DML操作。</p><ol><li><p>提交事务关键字 commit;</p></li><li><p>回滚事务关键字 rollback;</p></li><li><p>开启事务关键字 start transaction;</p></li></ol></li></ul><h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><table><thead><tr><th>数据类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>tinyint</td><td>8bit</td><td>范围(-128~127)</td></tr><tr><td>smallint</td><td>16bit</td><td>范围(-32768~32767)</td></tr><tr><td>mediumint</td><td>24bit</td><td>范围(-8388608~8388607)</td></tr><tr><td>int</td><td>32bit</td><td>范围(-2147483648~2147483647)&#x3D;&#x3D;（对应java中的类型int 或 Integer 记住）&#x3D;&#x3D;</td></tr><tr><td>bigint</td><td>64bit</td><td>范围(+-9.22*10的18次方)&#x3D;&#x3D;（对应java中的类型long或 Long记住）&#x3D;&#x3D;</td></tr></tbody></table><h4 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h4><table><thead><tr><th>数据类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>float(m,d)</td><td>32bit</td><td>单精度浮点型，m总个数，d小数位</td></tr><tr><td>double(m,d)</td><td>64bit</td><td>双精度浮点型，m总个数，d小数位</td></tr></tbody></table><h4 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h4><ul><li>浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。 decimal(m,d) 参数m是总个数，d是小数位。</li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tbody><tr><td>char(n)</td><td>固定长度，最多255个字符，索引效率级高，必须在括号里定义长度，可以有默认值</td></tr><tr><td>varchar(n)</td><td>可变长度，最多65535个字符&#x3D;&#x3D;（对应java中的类型String或  char记住）&#x3D;&#x3D;</td></tr><tr><td>tinytext</td><td>可变长度，最多255个字符</td></tr><tr><td>text</td><td>可变长度，最多65535个字符</td></tr><tr><td>mediumtext</td><td>可变长度，最多2的24次方-1个字符</td></tr><tr><td>longtext</td><td>可变长度，最多2的32次方-1个字符</td></tr><tr><td>json</td><td>mysql5.7新增加的数据类型，用来存放json数据</td></tr></tbody></table><ul><li><p><strong>char、varchar、text区别 （理解）</strong></p><ul><li><strong>char</strong>：存储定长数据很方便，CHAR字段上的索引效率级高，必须在括号里定义长度，可以有默认值，比如定义char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间（自动用空格填充），且在检索的时候后面的空格会隐藏掉，所以检索出来的数据需要记得用什么trim之类的函数去过滤空格。</li><li><strong>varchar</strong>：存储变长数据，但存储效率没有CHAR高，必须在括号里定义长度，可以有默认值。保存数据的时候，不进行空格自动填充，而且如果数据存在空格时，当值保存和检索时尾部的空格仍会保留。另外，varchar类型的实际长度是它的值的实际长度+1，这一个字节用于保存实际使用了多大的长度。</li><li><strong>text</strong>：存储可变长度的非Unicode数据，最大长度为2^31-1个字符。text列不能有默认值，存储或检索过程中，不存在大小写转换，后面如果指定长度，不会报错误，但是这个长度是不起作用的，意思就是你插入数据的时候，超过你指定的长度还是可以正常插入。</li></ul></li><li><p>实战结论：</p><ol><li><p>经常变化的字段用varchar；</p></li><li><p>知道固定长度的用char；</p></li><li><p>超过255字节的只能用varchar或者text；</p></li><li><p>能用varchar的地方不用text；</p></li><li><p>能够用数字类型的字段尽量选择数字类型而不用字符串类型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接回逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了；</p></li><li><p>同一张表出现多个大字段，能合并时尽量合并，不能合并时考虑分表</p></li></ol></li></ul><h4 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h4><table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tbody><tr><td>date</td><td>日期 ‘2021-1-1’（对应java中的类Date  记住）</td></tr><tr><td>time</td><td>时间 ‘12:25:36’</td></tr><tr><td>datetime</td><td>日期时间 ‘2021-1-1 22:06:44’ （对应java中的类Date 记住）</td></tr><tr><td>timestamp</td><td>自动存储记录修改时间</td></tr></tbody></table><h4 id="逻辑类型"><a href="#逻辑类型" class="headerlink" title="逻辑类型"></a>逻辑类型</h4><ul><li><strong>（适用于：性别、状态、标记等只有两个值的）</strong><ul><li>Logic类型使用bit表示，它只能存储两个值0或者1</li></ul></li></ul><h4 id="数据类型的属性"><a href="#数据类型的属性" class="headerlink" title="数据类型的属性"></a>数据类型的属性</h4><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>数据列可包含NULL值</td></tr><tr><td>NOT NULL</td><td>数据列不允许包含NULL值</td></tr><tr><td>DEFAULT</td><td>默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键</td></tr><tr><td>AUTO_INCREMENT</td><td>自动递增，适用于整数类型</td></tr><tr><td>UNSIGNED</td><td>无符号</td></tr><tr><td>CHARACTER SET  name</td><td>指定一个字符集</td></tr></tbody></table><h2 id="MySQL表的相关操作"><a href="#MySQL表的相关操作" class="headerlink" title="MySQL表的相关操作"></a>MySQL表的相关操作</h2><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><ul><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">create table <表名称>(   列名称1 数据类型1,   列名称2 数据类型2,   ..........   列名称n 数据类型n);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>实列1：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">create table tb_student(     id int(11),     stu_name varchar(50),     stu_sex bit,     stu_hobby varchar(50),     stu_age smallint);#注意：最后一列没有逗号#列与列之间以英文逗号隔开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>实例2：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">create table student(     id int(11),     stu_name varchar(50),     stu_sex bit,     stu_hobby varchar(50),     stu_age smallint)default charset=UTF8, ENGINE=INNODB;# DEFAULT CHARSET 用于指定表中数据的字符集编码方式# ENGINE 用于指定表的存储引擎<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="数据存储问题"><a href="#数据存储问题" class="headerlink" title="数据存储问题"></a>数据存储问题</h4><ul><li><p>现在我们在数据库中创建了一个表，那么如我们把电脑重启，这个表还在不在呢？</p></li><li><p>测试结果为  在  那是为什么呢？</p></li><li><p>原因是当我们创建表个表之后，在我们数据库的文件系统里面就会有一个对应的文件存在</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">.frm文件：保存了每个表的元数据，包括表结构的定义等；.ibd文件：InnoDB引擎开启了独立表空间(my.ini中配置innodb_file_per_table = 1)产生的存放该表的数据和索引的文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h4><ul><li><p>创建表之后如何查看是否创建成功？可以通过desc命令来查看表结构</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 第一种方式查看表结构# desc <表名称>;desc student;# 第二种方式查看表结构# show create <表名称>;show create table tb_student;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h4><pre class="line-numbers language-MySQL"><code class="language-MySQL">基本语法如下：alter table <表名称>;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>案列1</p></li><li><p>添加列，例如：向student表新增加一列stu_height学生身高</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 语法如下：# alter table <表名称> add column <列名称>  <数据类型>;alter table student add column stu_height int(11);# 查看表结构desc student;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>案例2</p></li><li><p>删除某一个列，例如：删除student表中的学生身高</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 语法如下：# alter table <表名称> drop column <列名称>;alter table student drop column stu_height;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>案例3</p></li><li><p>修改列名称和数据类型：例如修改stu_sex 为 student_sex 数据类型修改为 varchar(30)</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 语法如下：# alter table <表名称> change column <原列名称> <新列名称> <数据类型>;# 修改stu_sex 为 student_sex 数据类型修改为 varchar(30)alter table student change column stu_sex student_sex varchar(30);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>案例4</p></li><li><p>修改某一列的数据类型，例如：将学生年龄修改为int类型</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 语法如下：# alter table  <表名称> modify column <原来的列名称>  <新的数据类型>;# 例如：alter table student modify column stu_age int(11);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><ul><li><p>删除删除之前先判断表是否还存在</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">drop table if exists <表名称>;  # 刪除之前先做校验，表在数据库中存在才删除drop table if exists EMP_bak;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>直接删除</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">drop table <表名称>;drop table EMP_bak;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>显示当前的所有表</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">show tables;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><h2 id="MySQL表里面数据的相关操作DML"><a href="#MySQL表里面数据的相关操作DML" class="headerlink" title="MySQL表里面数据的相关操作DML"></a>MySQL表里面数据的相关操作DML</h2><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><ul><li><p>单个添加</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 插入所有的数据语法如下：#  insert into 表名称 values (值1,值2,……);insert into student values(101,'老王',0,'足球',31);# 注意：在插入所有的数据时values后面的括号必须填满所有列，保证参数的顺序和表中的列的顺序 一致insert into student values(101,'老王',0,'足球');#报错：ERROR 1136 (21S01): Column count doesn't match value count at row 1# 错误原因：student表后面没有指定列名称，默认将插入所有列的数据，此时student表定义了5列，但是只插入了4列数据，所以报错# 注意：student表后面没有指定列名称，那么在插入数据的时候，数据的类型必须跟定义表结构类型保持一致<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>批量添加</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 行与行之间使用半角逗号分离，value关键字只定义一次insert into student(id,stu_name,stu_sex,stu_hobby,stu_age)values(108,'老王',1,'Basketball',39),(1031,'老张',1,'Basketball',39);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><ul><li><p>批量修改</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 修改所有数据# 语法update <表名称> set 列名称 = 值;# 例如：student表的年龄全部修改为50update student set stu_age = 50;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>单个修改</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 如果只想修改某一行的数据，需要加上条件# 例如：我只想修改id为1031的年龄为60where 表示行过滤where id=1031 表示只选择id为1031的行进行修改# 下面代码执行步骤：首先执行 update student 确定修改那张表# 然后执行 where 条件 确定修改表中的哪一行，不满住条件的行都会被过滤掉update student set stu_age = 60 where id = 1031;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>单个修改多个值</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">update student set stu_age = 60，name='习大大' where id = 1031;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><ul><li><p>删除一个</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 删除某一条数据 语法：delete from <表名称>  where 条件;# 例如：删除id为108的student数据delete from student where id = 108;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除全部</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 语法delete from <表名称> ;# 例如：删除student表所有数据delete from student;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>truncate关键字</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">truncate 是DDL，删除所有数据，不支持where，不能回滚delete 是DML，可以删除部分数据，因为支持where，可以回滚#总体上truncate效率比delete高，他们都只能删除数据不能删除表结构，只有drop才能删除表结构<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><ul><li><p>什么是主键：主要关键字，一个表如果创建了主键那么该行的所有数据必须在表中 非空并且唯一。</p></li><li><p>主键设计原则：</p><ul><li><p>在开发中，一般的主键为数值类型，呈递增趋势，如果不想每次都插入主键，我们可以让数据自动增长</p></li><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">create table tb_class(    # id是主键列，不用显示插入值 让其自动增长    id int(11)auto_increment,      # not null 非空约束     class_name varchar(30) not null,     # 班级描述     class_desc varchar(100),      # 为tb_class表的id列设置主键约束     primary key (id)       )ENGINE=INNODB,DEFAULT CHARSET UTF8;    # 注意： MySQL 数据库 auto_increment自动增长和主键primary key 是配套的不能单独使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h4 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h4><ul><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">create table tb_class(# id是主键列，不用显示插入值 让其自动增长 id int(11) auto_increment,   # not null 非空约束 class_name varchar(30) not null,  # 班级描述 class_desc varchar(100),   # 为tb_class表的id列设置主键约束 primary key (id)   )ENGINE=INNODB,DEFAULT CHARSET UTF8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h4><ul><li>制定一个规则，让表的某一列数据必须唯一</li><li>特征：某列数据可以为空，但是必须唯一</li><li>语法：</li></ul><pre class="line-numbers language-MySQL"><code class="language-MySQL">#列如：学生的手机号码create table tb_1(    phone int unique)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h4><ul><li><p>为某一列制定一个默认规则</p></li><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#列如：性别默认为 0create table tb_1(    phone int unique,sex int DEFAULT 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><ul><li><p>外部的关键字叫做外键，通常为多张表中建立联系，确保表与表之间的数据安全性，一致性，能够减少数据冗余(重复的数据)。</p></li><li><p>前面几个约束：在一张表建立约束(规则)</p></li><li><p>外键约束： 多张表之间建立约束(关联，联系)</p></li><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#场景：创建一个tb_student表，为其添加默认约束、唯一约束、非空约束、外键约束。create table tb_student(  id  int(11) auto_increment,  stu_name varchar(50) not null,    # unique 唯一混熟  stu_mobile varchar(20) unique,      # 默认约束 性别默认为1  0女  1男  stu_sex bit default 1,  class_id int(11) not null,     # 学生表的class_id建立外键去关联 tb_class表的主键  primary key (id),  foreign key (class_id) references tb_class(id))ENGINE=INNODB,DEFAULT CHARSET UTF8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="约束关键字总结"><a href="#约束关键字总结" class="headerlink" title="约束关键字总结"></a>约束关键字总结</h4><table><thead><tr><th>约束名称</th><th>关键字</th></tr></thead><tbody><tr><td>主键约束</td><td>primary key</td></tr><tr><td>非空约束</td><td>not null</td></tr><tr><td>唯一约束</td><td>unique</td></tr><tr><td>默认约束</td><td>default</td></tr><tr><td>外键约束</td><td>foreign key…….references</td></tr></tbody></table><ul><li><p>约束分为两类：</p><ol><li><p>行级别约束： 主键约束、外键约束</p></li><li><p>列级别约束： 非空约束、唯一约束、默认约束</p></li></ol></li><li><p>外键约束小结：</p><ol><li>foreign key(外键列) </li><li>references 主表 (主键列)</li><li>references 关键字的右边是主表的主键列，左边是从表的外键列，该关键字在主表和从边之间建立了联系。</li></ol></li><li><p>创建表小结：没有外键的表是主表，有外键的表是从表。先创建主表后创建从表(有外键的表是从表)</p></li><li><p>插入数据小结：先插入主表数据后插入从表数据</p></li><li><p>删除数据小结：先删除从表数据后删除主表数据</p></li></ul><hr><h2 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h2><h4 id="一对一（one-to-one）"><a href="#一对一（one-to-one）" class="headerlink" title="一对一（one-to-one）"></a>一对一（one-to-one）</h4><ul><li><p>一对一关系就如球队与球队所在地址之间的关系，一支球队仅有一个地址，而一个地址区也仅有一支球队。</p></li><li><p>数据表间一对一关系的表现有两种，一种是外键关联，一种是主键关联。</p></li><li><p>如图：</p><p><img src="/images/MySQL/%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB.jpg" alt="一对一关系"></p></li></ul><h4 id="一对多或多对一（many-to-one）"><a href="#一对多或多对一（many-to-one）" class="headerlink" title="一对多或多对一（many-to-one）"></a>一对多或多对一（many-to-one）</h4><ul><li><p>存在最普遍的映射关系，简单来讲就如球员与球队的关系；</p><ul><li><p>一对多：从球队角度来说一个球队拥有多个球员 即为一对多</p></li><li><p>多对一：从球员角度来说多个球员属于一个球队 即为多对一数据表间一对多关系</p></li></ul></li><li><p>如图：</p><p><img src="/images/MySQL/%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg" alt="一对多关系"></p></li><li><p>案列</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 班级表 create table tb_class(    # id是主键列，不用显示插入值 让其自动增长 id int(11) auto_increment,       # not null 非空约束 class_name varchar(30) not null,     # 班级描述 class_desc varchar(100),     # 为tb_class表的id列设置主键约束 primary key (id)  )ENGINE=INNODB,DEFAULT CHARSET UTF8;# 学生表create table tb_student(  id  int(11) auto_increment,  stu_name varchar(50) not null,    # unique 唯一约束  stu_mobile varchar(20) unique,     # 默认约束 性别默认为1  0女  1男  stu_sex bit default 1,     #非空约束 class_id  class_id int(11) not null,    #id为主键  primary key (id),    # 学生表的class_id建立外键去关联 tb_class表的主键  foreign key (class_id) references tb_class(id))ENGINE=INNODB,DEFAULT CHARSET UTF8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="多对多（many-to-many）"><a href="#多对多（many-to-many）" class="headerlink" title="多对多（many-to-many）"></a>多对多（many-to-many）</h4><ul><li><p>多对多关系也很常见，例如学生与选修课之间的关系，一个学生可以选择多门选修课，而每个选修课又可以被多名学生选择。</p></li><li><p>数据库中的多对多关联关系一般需采用中间表的方式处理，将多对多转化为两个一对多。</p></li><li><p>数据表间多对多关系如图：</p><p><img src="/images/MySQL/%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg" alt="多对多关系"></p></li><li><p>案列</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">-- 学生表create table tb_student(  id  int(11) auto_increment,  stu_name varchar(50) not null,  stu_mobile varchar(20) unique, -- unique 唯一混熟  stu_sex bit default 1, -- 默认约束 性别默认为1  0女  1男  class_id int(11) not null,   primary key (id),    -- 学生表的class_id建立外键去关联 tb_class表的主键  foreign key (class_id) references tb_class(id))ENGINE=INNODB,DEFAULT CHARSET UTF8;-- 课程表create table tb_course(  id int(11) auto_increment,  course_name varchar(30) not null, -- 课程名称  primary key(id))ENGINE=INNODB,DEFAULT CHARSET UTF8;-- 学生课程表是一个中间表，在学生表和课程表之间解耦create table tb_student_course(  stu_id int(11), -- 学生id  course_id int(11), -- 课程id  course_score int(11), -- 课程的成绩    primary key(stu_id,course_id),    -- 复合主键-- stu_id作为外键关联学生表主键  foreign key(stu_id) references tb_student(id),  -- course_id作为外键关联课程表主键 foreign key(course_id) references tb_course(id))ENGINE=INNODB,DEFAULT CHARSET UTF8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="单表数据查询"><a href="#单表数据查询" class="headerlink" title="单表数据查询"></a>单表数据查询</h2><h4 id="最简单的查询方式"><a href="#最简单的查询方式" class="headerlink" title="最简单的查询方式"></a>最简单的查询方式</h4><ul><li><p>查询所有员工的信息</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp;#查询所有部门信息select * from dept;#查询所有员工的 编号，姓名，工资，职位信息select empno, ename,sal,job  from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h4><ul><li><p>查询所有员工的编号、姓名、工资、年终奖信息</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select empno, ename,sal,sal*1.08 from emp;#查询所有员工的 编号，姓名，工资，年薪信息select empno, ename,sal, sal*12 from emp;#查询所有员工的 编号，姓名，工资，年薪增加1000 信息select empno, ename,sal, sal*12 +1000 from emp;注：在Select语句中，对数值型数据可以使用算术运算符创建表达式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="使用字段别名"><a href="#使用字段别名" class="headerlink" title="使用字段别名"></a>使用字段别名</h4><ul><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select empno as 员工编号, ename 员工姓名, sal*12 年薪  from emp;select empno, ename "Ename", sal*12 "Anual Salary" from emp;select sal*12+5000  as "年度工资(加年终奖)" from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>字段别名说明：</p><ul><li>重命名查询结果中的字段，以增强可读性，别名如果含有空格或其他特殊字符或大小写敏感，需用双引号引起来。</li><li>AS可以省略</li></ul></li></ul><h4 id="去重查询"><a href="#去重查询" class="headerlink" title="去重查询"></a>去重查询</h4><ul><li><p>缺省情况下，查询结果中包含所有符合条件的记录行，包括重复行</p></li><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#查询所有员工的部门编号信息select deptno from emp;使用DISTINCT关键字可从查询结果中清除重复行#查询所有员工的部门编号信息并去重select distinct deptno from emp;#查询所有员工的职位信息并去重select distinct  job from emp;DISTINCT的作用范围是后面所有字段的组合#查询所有员工的部门编号和职位信息去重select distinct deptno，  job from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><ul><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#使用order by 子句对查询结果进行排序#排序方式包括升序（asc，缺省）和降序（desc）两种：#查询员工的编号，姓名，工资并按照工资升序排序select empno, ename, sal from emp order by sal;#查询员工的编号，姓名，工资并按照工资升序降序select empno, ename, sal from emp order by sal desc ;#按多字段排序#查询员工的编号，姓名，工资并先按照部门编号升序排序，如果编号相同，再按照工资升序排序select deptno, empno, ename, sal from emp order by deptno, sal;#使用字段别名排序#查询员工的编号，姓名，年薪并先按照年薪升序排序  (别名 可以在 排序中使用)select empno, ename, sal*12 annsal from emp order by annsal;#查询员工的编号，年薪 且年薪大于10000 select empno, sal*12 incomeyear where incomeyear>10000 # (错误的)select empno, sal*12 incomeyear where sal*12 >10000 # (对的)#因为 where子句的优先级比select子句高#执行顺序:  from > where>select >order by <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><ul><li><p><strong>关键字：limit</strong></p></li><li><p>案列1：查询每页显示3条数据，查询第一页数据的sql</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp limit 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>案列2：每页显示三条数据，查询第五页的数据的sql</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp limit 12，3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>limit 参数1，参数2</p><ul><li>参数1：表示索引</li><li>参数2：表示每页显示的信息条数</li></ul></li><li><p><strong>参数1的计算方法：</strong>索引 &#x3D; （查询页数 - 1）* 2</p></li></ul><h4 id="合并查询"><a href="#合并查询" class="headerlink" title="合并查询"></a>合并查询</h4><ul><li><p>将多个select语句联合(合并)为一个select语句，涉及的关键字union 和union all。</p></li><li><p>union all 不管是否重复，全部合并</p></li><li><p>union 如果有重复的，过滤掉重复的</p></li><li><p>案列：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp  where DEPTNO=10 union all select * from emp  where DEPTNO=20select * from emp  where DEPTNO=10 union select * from emp  where DEPTNO=20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h2><h4 id="用法举例"><a href="#用法举例" class="headerlink" title="用法举例"></a>用法举例</h4><ul><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#查询员工的部门编号为10的所有信息select * from emp where deptno=10;#查询员工的姓名为‘JACK’的所有信息select * from emp where ename = 'JACK';#查询员工的入职日期为2020-12-12的所有信息select * from emp where hiredate = '2020-12-12';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>注意：</strong>字符串和日期值要用单引号括起来，字符串大小写不敏感。</p></li><li><p>日期格式敏感，缺省的日期格式是’YYYY-MM-DD HH:mm:ss’</p></li></ul><h4 id="查询条件中可以使用比较运算符"><a href="#查询条件中可以使用比较运算符" class="headerlink" title="查询条件中可以使用比较运算符"></a>查询条件中可以使用比较运算符</h4><ul><li><p>MySQL支持如下比较运算符： &gt; &gt;&#x3D;  &lt; &lt;&#x3D;  !&#x3D;  &lt;&gt;</p><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>between…and..</td><td>介于两值之间（闭区间）</td></tr><tr><td>in(set)</td><td>出现在集合中</td></tr><tr><td>like</td><td>模糊查询</td></tr><tr><td>is null</td><td>为控制</td></tr></tbody></table></li><li><p><strong>注意：</strong>MySQL使用“&#x3D;”运算符来判断表达式是否相等，它没有&#x3D;&#x3D;Java使用!&#x3D;表示不等于，MySQL也支持。但是我们不要使用，效率太低了</p></li><li><p>MySQL使用的不等于使用&lt;&gt;</p></li><li><p>案列：查询工资大于2900的员工信息</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp where sal > 2900;#查询部门编号不等于30的员工信息select * from emp where deptno <> 30;#查询工资在1600 到 2900之间的员工信息select * from emp where sal between 1600 and 2900;#查询员工姓名为'SMITH','CLARK','KING'的员工信息select * from emp where ename in('SMITH','CLARK','KING');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>模糊查询案列：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 查询员工名字中包含 m的员工信息select * from emp where ename like '%M%'#查询名字以M开头的员工信息select * from emp where ename like 'M%'#查询名字以M结尾的员工信息select * from emp where ename like '%M'# _下划线 表示占位符,一个下划线表示占一个字符# 查找名字中倒数第二个字母为M的员工信息select * from emp where ename like '%M_'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="使用LIKE运算符执行模糊查询（通配查询）"><a href="#使用LIKE运算符执行模糊查询（通配查询）" class="headerlink" title="使用LIKE运算符执行模糊查询（通配查询）"></a>使用LIKE运算符执行模糊查询（通配查询）</h4><ul><li><p>% 表示零或多个字符    _ 表示一个字符</p></li><li><p>对于特殊符号可使用ESCAPE 标识符来查找</p></li><li><p>案列：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#查询员工姓名以S开头的员工信息select * from emp where ename like 'S%';#查询 员工 姓名第二给字母为A的员工信息select * from emp where ename like '_A%';# 查找名字中包含下划线的员工信息select * from emp where ename like '%/_%' escape  '/'select * from emp where ename like '%\_%'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>判断空值</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#查询没有奖金的员工信息select * from emp where comm is null;#查询有奖金的员工信息select * from emp where comm is not null; （固定写法）#查询有奖金的员工信息select * from emp where not comm is null; （通用型）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="查询条件中可以使用逻辑运算符"><a href="#查询条件中可以使用逻辑运算符" class="headerlink" title="查询条件中可以使用逻辑运算符"></a>查询条件中可以使用逻辑运算符</h4><ul><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#查询部门编号为10 且工资大于1000 的员工信息select * from emp where deptno = 10 and sal > 1000;#查询部门编号为10 或者 岗位为 ‘ClerK’的员工信息select * from emp where deptno = 10 or job = ‘CLERK’;#查询工资不等800,1500,2000 的员工信息select * from emp where sal not in (800, 1500, 2000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="SQL优化问题"><a href="#SQL优化问题" class="headerlink" title="SQL优化问题"></a>SQL优化问题</h4><ul><li>AND: 把检索结果较少的条件放到后面</li><li>OR: 把检索结果较多的条件放到后面</li></ul><h4 id="四种运算符优先级：算术-gt-连接-gt-比较-gt-逻辑"><a href="#四种运算符优先级：算术-gt-连接-gt-比较-gt-逻辑" class="headerlink" title="四种运算符优先级：算术&gt;连接&gt;比较&gt;逻辑"></a>四种运算符优先级：算术&gt;连接&gt;比较&gt;逻辑</h4><p><img src="/images/MySQL/%E8%BF%90%E7%AE%97%E7%AC%A6.jpg" alt="运算符"></p><ul><li><p><strong>可使用小括号强行改变运算顺序</strong></p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp where job='SALESMAN' or job='CLERK' and sal>=1280;select * from emp where (job='SALESMAN' or job='CLERK') and sal>=1280;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>优先级： Not&gt;and&gt;or</li></ul></li></ul><hr><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><h4 id="函数概念"><a href="#函数概念" class="headerlink" title="函数概念"></a>函数概念</h4><ul><li>使用函数可以大大提高SELECT语句操作数据库的能力。它给数据的转换和处理提供了方便。</li><li>函数只是将取出的数据进行处理，不会改变数据库中的值。</li></ul><h4 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类"></a>函数的分类</h4><ul><li><p>单行函数分类</p><ol><li>数学函数</li><li>字符串函数</li><li>日期和时间函数</li><li>条件判断函数</li><li>系统信息函数</li><li>加密函数</li><li>格式化函数</li></ol></li><li><p>多行函数分类</p><ol><li><p>仅适用数值型的多行函数 </p><ul><li><p>sum() 求和 </p></li><li><p>avg() 求平均值</p></li></ul></li><li><p>适用任何类型数据</p><ul><li><p>count() 计数  </p></li><li><p>max() 求最大值    </p></li><li><p>min() 求最小值</p></li></ul></li></ol></li></ul><h4 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h4><ul><li><p>数学函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">ABS(x)   # 返回x的绝对值PI()     # 返回圆周率π，默认显示6位小数SQRT(x)  # 返回非负数的x的二次方根MOD(x,y) # 返回x被y除后的余数CEIL(x)、CEILING(x) #返回不小于x的最小整数FLOOR(x)  #返回不大于x的最大整数ROUND(x)、ROUND(x,y)  #前者返回最接近于x的整数，即对x进行四舍五入；后者返回最接近x的数，其值保留到小数点后面y位，若y为负值，则将保留到x到小数点左边y位SIGN(x)  #返回参数x的符号，-1表示负数，0表示0，1表示正数POW(x,y)和、POWER(x,y) # 返回x的y次乘方的值EXP(x)  #返回e的x乘方后的值LOG(x)  #返回x的自然对数，x相对于基数e的对数LOG10(x) # 返回x的基数为10的对数RADIANS(x)  #返回x由角度转化为弧度的值DEGREES(x)  #返回x由弧度转化为角度的值SIN(x)、ASIN(x)  #前者返回x的正弦，其中x为给定的弧度值；后者返回x的反正弦值，x为正弦COS(x)、ACOS(x) # 前者返回x的余弦，其中x为给定的弧度值；后者返回x的反余弦值，x为余弦TAN(x)、ATAN(x)  #前者返回x的正切，其中x为给定的弧度值；后者返回x的反正切值，x为正切COT(x)   #返回给定弧度值x的余切RAND(x)   #返回0-1之间的随机小数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>字符串函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">（1）CHAR_LENGTH(str)  #计算字符串字符个数（2）CONCAT(s1,s2，...) # 返回连接参数产生的字符串，一个或多个待拼接的内容，任意一个为NULL则返回值为NULL（3）CONCAT_WS(x,s1,s2,...) #返回多个字符串拼接之后的字符串，每个字符串之间有一个x（4）INSERT(s1,x,len,s2)  #返回字符串s1，其子字符串起始于位置x，被字符串s2取代len个字符（5）LOWER(str)和LCASE(str)、UPPER(str)和UCASE(str)#前两者将str中的字母全部转换成小写，后两者将字符串中的字母全部转换成大写（6）LEFT(s,n)、RIGHT(s,n)  #前者返回字符串s从最左边开始的n个字符，后者返回字符串s从最右边开始的n个字符（7）LPAD(s1,len,s2)、RPAD(s1,len,s2)  #前者返回s1，其左边由字符串s2填补到len字符长度，假如s1的长度大于len，则返回值被缩短至len字符；前者返回s1，其右边由字符串s2填补到len字符长度，假如s1的长度大于len，则返回值被缩短至len字符（8）LTRIM(s)、RTRIM(s) #前者返回字符串s，其左边所有空格被删除；后者返回字符串s，其右边所有空格被删除（9）TRIM(s)  #返回字符串s删除了两边空格之后的字符串（10）TRIM(s1 FROM s)  #删除字符串s两端所有子字符串s1，未指定s1的情况下则默认删除空格（11）REPEAT(s,n) # 返回一个由重复字符串s组成的字符串，字符串s的数目等于n（12）SPACE(n) # 返回一个由n个空格组成的字符串（13）REPLACE(s,s1,s2)  #返回一个字符串，用字符串s2替代字符串s中所有的字符串s1（14）STRCMP(s1,s2) # 若s1和s2中所有的字符串都相同，则返回0；根据当前分类次序，第一个参数小于第二个则返回-1，其他情况返回1（15）SUBSTRING(s,n,len)、MID(s,n,len) #两个函数作用相同，从字符串s中返回一个第n个字符开始、长度为len的字符串（16）LOCATE(str1,str)、POSITION(str1 IN str)、INSTR(str,str1) #三个函数作用相同，返回子字符串str1在字符串str中的开始位置（从第几个字符开始）（17）REVERSE(s)  #将字符串s反转（18）ELT(N,str1,str2,str3,str4,...) #返回第N个字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>日期和时间函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">（1）CURDATE()、CURRENT_DATE()#将当前日期按照"YYYY-MM-DD"或者"YYYYMMDD"格式的值返回，具体格式根据函数用在字符串或是数字语境中而定（2）CURRENT_TIMESTAMP()、LOCALTIME()、NOW()、SYSDATE() #这四个函数作用相同，返回当前日期和时间值，格式为"YYYY_MM-DD HH:MM:SS"或"YYYYMMDDHHMMSS"，具体格式根据函数用在字符串或数字语境中而定（3）MONTH(date)和MONTHNAME(date) #前者返回指定日期中的月份，后者返回指定日期中的月份的名称（4）WEEK(d)、WEEKOFYEAR(d) #前者计算日期d是一年中的第几周，后者计算某一天位于一年中的第几周（5）DAYOFYEAR(d)、DAYOFMONTH(d) #前者返回d是一年中的第几天，后者返回d是一月中的第几天（6）EXTRACT(type FROM date) #从日期中提取一部分，type可以是YEAR、YEAR_MONTH、DAY_HOUR、DAY_MICROSECOND、DAY_MINUTE、DAY_SECOND（7）TimeStampDiff #(间隔类型，前一个日期，后一个日期) #例如距离现在差了多少年：TimeStampDiff(year, 前一个日期, now())#间隔类型有：second秒，minute分，hour时，day天，week周，month月，quarter季度，year年（8）DATE_ADD(date,INTERVAL expr type)、ADD_DATE(date,INTERVAL expr type) # 返回将起始时间加上expr type之后的时间，比如DATE_ADD('2010-12-31 23:59:59', INTERVAL 1 SECOND)表示的就是把第一个时间加1秒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>条件判断函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">（1）IF(expr,v1,v2) #如果expr是TRUE则返回v1，否则返回v2（2）IFNULL(v1,v2) #函数  如果v1的值不为NULL，则返回v1，否则返回v2。（2）CASE expr WHEN v1 THEN r1 [WHEN v2 THEN v2] [ELSE rn] END #如果expr等于某个vn，则返回对应位置THEN后面的结果，如果与所有值都不想等，则返回ELSE后面的rn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>系统信息函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">（1）VERSION() #查看MySQL版本号（2）CONNECTION_ID() #查看当前用户的连接数（3）USER()、CURRENT_USER()、SYSTEM_USER()、SESSION_USER() #查看当前被MySQL服务器验证的用户名和主机的组合，一般这几个函数的返回值是相同的（4）CHARSET(str) #查看字符串str使用的字符集（5）COLLATION() #查看字符串排列方式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>加密函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">（1）PASSWORD(str)#从原明文密码str计算并返回加密后的字符串密码，注意这个函数的加密是单向的（不可逆），因此不应将它应用在个人的应用程序中而应该只在MySQL服务器的鉴定系统中使用（2）MD5(str) #为字符串算出一个MD5 128比特校验和，改值以32位十六进制数字的二进制字符串形式返回（3）ENCODE(str, pswd_str) #使用pswd_str作为密码，加密str（4） DECODE(crypt_str,pswd_str) #使用pswd_str作为密码，解密加密字符串crypt_str，crypt_str是由ENCODE函数返回的字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>格式化函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">（1）FORMAT(x,n) #将数字x格式化，并以四舍五入的方式保留小数点后n位，结果以字符串形式返回（2）CONV(N,from_base,to_base) #不同进制数之间的转换，返回值为数值N的字符串表示，由from_base进制转换为to_base进制（3）INET_ATON(expr) #给出一个作为字符串的网络地址的点地址表示，返回一个代表该地址数值的整数，地址可以使4或8比特（4）INET_NTOA(expr) #给定一个数字网络地址（4或8比特），返回作为字符串的该地址的点地址表示（5）BENCHMARK(count,expr) #重复执行count次表达式expr，它可以用于计算MySQL处理表达式的速度，结果值通常是0（0只是表示很快，并不是没有速度）。另一个作用是用它在MySQL客户端内部报告语句执行的时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h4><ul><li><p>对一组数据进行运算，针对一组数据（多行记录）只返回一个结果，也称分组函数。</p></li><li><p>常用的多行函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">sum()  avg()   仅适用数值型count()   max()   min()   适用任何类型数据# 查询平均工资，最高工资，最低工资，工资总select avg(sal), max(sal), min(sal), sum(sal) from emp; # 查询最早入职和最晚入职的员工信息select max(hiredate), min(hiredate) from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>多行函数与空值</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#多行函数除了count(*)外，都跳过空值而处理非空值select count(comm),sum(comm),avg(comm) from emp;#可使用IF()函数强制多行函数处理空值select count(IF(comm is null,0,comm)),sum(IF(comm is null,0,comm)),avg(IF(comm is null,0 ,comm)) from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>count（*）函数的说明</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">count(*) #返回组中总记录数目；count(exp) # 返回表达式exp值非空的记录数目；count(distinct(exp)) # 返回表达式exp值不重复的、非空的记录数目。#查询所有员工个数select count(*) from emp;#查询有奖金的员工的个数select count(comm) from emp;#查询部门的个数select count(distinct(deptno)) from emp; #查询所有的员工数select count(IF(comm IS null,0,comm)) from emp;select count(IFnull(0,comm)) from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="group-by子句"><a href="#group-by子句" class="headerlink" title="group by子句"></a>group by子句</h4><ul><li><p>GROUP BY 子句将表中数据分成若干小组</p></li><li><p>语法格式</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select column, group_function(column)from table[where condition][group by group_by_expression][order by column];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用举例</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#按照部门分组并查询部门的平均工资select deptno, avg(sal) from emp group by deptno;#按照部门分组，并统计部门的平均工资和数量select  deptno, ename,count(*),avg(sal) from emp group by deptno；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注意事项</p><ul><li><p>出现在SELECT列表中的字段，如果不是包含在多行函数中，那么该字段必须同时在GROUP BY子句中出现。</p></li><li><p>错误：select ename,deptno,sum(sal) from emp group by deptno;</p><ul><li>|以上的SQL在MYSQL中是不错的，但是在oracle是错的，在开发中避免这样写</li><li>包含在GROUP BY子句中的字段则不必须出现在SELECT列表中。</li></ul></li><li><p>如果没有GROUP BY子句，SELECT列表中不允许出现字段（单行函数）与多行函数混用的情况</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select empno, sal from emp;  #合法select avg(sal) from emp;  #合法select empno, avg(sal) from emp;  #非法# 不允许在WHERE 子句中使用多行函数select deptno, avg(sal)   from empwhere avg(sal) > 2000;   # 执行where时尚未执行groupby 及其他group by deptno;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h4 id="having子句"><a href="#having子句" class="headerlink" title="having子句"></a>having子句</h4><ul><li><p>对分组查询的结果进行过滤，要使用having从句。</p></li><li><p>having从句过滤分组后的结果，它只能出现在group by从句之后，而where从句要出现在group by从句之前。</p></li><li><p>where过滤行，having过滤分组。having支持所有where操作符。</p></li><li><p>语法格式：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select column, group_function(column)from table[where condition][group by  group_by_expression][having group_condition][order by column];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>注意：</strong>执行过程：from–where – group by– having– select– order by</li></ul></li><li><p>用法举例</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 列出平均工资大于8000元的部门IDselect deptno, avg(sal)   from empgroup by deptno having avg(sal) > 8000  order by deptno;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>练习：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 统计人数小于4的部门的平均工资。Select deptno ,avg(sal),count(*)  from emp group by deptno having count(*) <4# 统计各部门的最高工资，排除最高工资小于8000的部门。Select max(sal),deptno  from emp group by deptno having not max(sal)<8000# 显示部门编号大于10 的部门的人数，要求人数大于3Select deptno, count(*) from emp group by deptno  having deptno > 10 and count(*) > 3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="连接查询SQL-92"><a href="#连接查询SQL-92" class="headerlink" title="连接查询SQL 92"></a>连接查询SQL 92</h2><h4 id="链接查询的概述"><a href="#链接查询的概述" class="headerlink" title="链接查询的概述"></a>链接查询的概述</h4><ul><li>笛卡尔集</li><li>等值连接</li><li>非等值连接</li><li>外连接</li><li>自连接</li><li>说明。SQL92是1992年提出的查询语法，向上兼容</li></ul><h4 id="连接查询语法"><a href="#连接查询语法" class="headerlink" title="连接查询语法"></a>连接查询语法</h4><ul><li><p>语法规则：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">SELECTtable1.column, table2.column FROM table1, table2 WHERE table1.column1 = table2.column2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>特点</p><ul><li>在 WHERE 子句中写入连接条件</li><li>当多个表中有重名列时，必须在列的名字前加上表名作为前缀</li></ul></li><li><p>链接查询的类型</p><ul><li><p>等值连接 – Equijoin</p></li><li><p>非等值连接 – Non-equijoin</p></li><li><p>左连接 –LEFT JOIN</p></li><li><p>右连接 –RIGHT JOIN</p></li><li><p>自连接 – Self join</p></li></ul></li></ul><h4 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><p>- </p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from dept; # 4条记录select * from emp; ; # 14条记录select * from dept,emp; ; # 4*14=56条记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>总结</p><ol><li>检索出的行的数目将是第一个表中的行数乘以第二个表中的行数</li><li>检索出的列的数目将是第一个表中的列数加上第二个表中的列数</li><li>应该保证所有联结都有where子句，不然数据库返回比想要的数据多得多的数据</li></ol></li></ul><h4 id="等值查询"><a href="#等值查询" class="headerlink" title="等值查询"></a>等值查询</h4><ul><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#查询员工信息以及部门信息select * from dept,emp where dept.deptno=emp.deptno;#查询员工信息以及部门信息（使用别名）select * from dept d,emp e where d.deptno=e.deptno;#针对重复的字段必须要指定哪个表的字段select d.deptno,dname,loc,empno,ename,job from dept d,emp e where d.deptno=e.deptno;#查询10号部门的员工信息以及部门信息select d.deptno,dname,loc,empno,ename,job from dept d,emp e where d.deptno=e.deptno and d.deptno=10#查询部门的地址为武汉的员工信息以及部门信息select d.deptno,dname,loc,empno,ename,job from dept d,emp e where d.deptno=e.deptno and loc='武汉';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>注意点：</strong></p><ol><li>当被连接的多个表中存在同名字段时，须在该字段前加上”表名.”前缀</li><li>可使用AND 操作符增加查询条件；</li><li>使用表别名可以简化查询，使用表名（表别名）前缀可提高查询效率；</li></ol></li></ul><h4 id="非等值查询"><a href="#非等值查询" class="headerlink" title="非等值查询"></a>非等值查询</h4><ul><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 要求：查询员工的工资等级select  empno,ename,job,sal,grade from emp e,salgrade swhere e.sal<s.hisal and e.sal>s.losal;# 查询经理的工资等级select  empno,ename,job,sal,grade from emp e,salgrade swhere e.sal<s.hisal and e.sal>s.losal and e.job='MANAGER';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><ul><li><p>特点：将一个表当两个表使用</p></li><li><p>使用举例：查询每个员工的工号、姓名、直接领导姓名</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 要求：必须使用别名select e1.empno,e1.ename,e1.job,e2.ename from emp e1 ,emp e2where e1.mgr=e2.empnoorder by e1.empno;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="连接查询SQL99"><a href="#连接查询SQL99" class="headerlink" title="连接查询SQL99"></a>连接查询SQL99</h2><h4 id="SQL语法概述"><a href="#SQL语法概述" class="headerlink" title="SQL语法概述"></a>SQL语法概述</h4><ul><li><p><strong>SQL92</strong>的语法规则的缺点：</p><ol><li>语句过滤条件和表连接的条件都放到了where子句中 。</li><li>当条件过多时，联结条件多，过滤条件多时，就容易造成混淆</li></ol></li><li><p><strong>SQL99</strong>修正了整个缺点，把联结条件，过滤条件分开来，包括以下新的TABLE JOIN的句法结构：</p><ol><li><p>交叉连接（Cross join）</p></li><li><p>自然连接（Natural join）</p></li><li><p>使用Using子句建立连接</p></li><li><p>使用On子句建立连接</p></li><li><p>连接（ Outer join ）</p><ul><li><p>内连接INNER JOIN </p></li><li><p>左连接LEFT JOIN</p></li><li><p>右连接RIGHT JOIN</p></li></ul></li></ol></li></ul><h4 id="SQL99语法"><a href="#SQL99语法" class="headerlink" title="SQL99语法"></a>SQL99语法</h4><ul><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select 字段列表 from table1 [cross join table2] |     # 1：交叉连接[natural join table2] |                              # 2：自然连接[join table2 using (字段名)] |                        # 3：using子句[join table2 on (table1.column_name = table2.column_name)] |  # 4：on子句[(left | right | full outer) join table2on (table1.column_name = table2.column_name)]; # 5：左/右/满外连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h4><ul><li><p>Cross join 产生了一个笛卡尔集，其效果等同于在两个表进行连接时未使用WHERE子句限定连接条件;</p></li><li><p>可以使用where条件从笛卡尔集中选出满足条件的记录。</p></li><li><p>举例：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select dept.deptno,dname,ename from dept cross join emp; 等价于select dept.deptno,dname,ename from dept,emp; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><ul><li><p>Natural join基于两个表中的全部同名列建立连接</p></li><li><p>从两个表中选出同名列的值均对应相等的所有行</p></li><li><p>如果两个表中同名列的数据类型不同，则出错</p></li><li><p>不允许在参照列上使用表名或者别名作为前缀</p></li><li><p>自然连接的结果不保留重复的属性</p></li><li><p>举例：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select empno, ename, sal, deptno, dname from emp natural join dept<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="using子句"><a href="#using子句" class="headerlink" title="using子句"></a>using子句</h4><ul><li><p>如果不希望参照被连接表的所有同名列进行等值连接，自然连接将无法满足要求，可以在连接时使用USING子句来设置用于等值连接的列（参照列）名。</p></li><li><p>using子句引用的列在sql任何地方不能使用表名或者别名做前缀</p></li><li><p>举例：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select e.ename,e.sal,deptno,d. dname from emp e join dept d using(deptno) where deptno=10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="on子句"><a href="#on子句" class="headerlink" title="on子句"></a>on子句</h4><ul><li><p>自然连接的条件是基于表中所有同名列的等值连接，为了设置任意的连接条件或者指定连接的列，需要使用ON子句</p></li><li><p>连接条件与其它的查询条件分开书写</p></li><li><p>使用ON 子句使查询语句更容易理解</p></li><li><p>举例：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 1.select ename,dname from emp inner join  dept on emp.deptno=dept.deptno where  emp.deptno=30;# 2.select empno, ename, sal, emp.deptno, dname from emp inner  join dept on (emp.deptno = dept.deptno and sal>5000);# 3.select * from dept, emp where dept.deptno = emp.deptno and sal>5000;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>第三种是sql92里面的查询方法，和上面两种等价</p></li><li><p>等列名</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select emp.empno,emp.ename,dept.dname,dept.loc from emp join dept on emp.deptno = dept.deptno<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>不等列名</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select  emp.empno,emp.ename, s.grade  from emp join salgrade s on emp.sal > s.losal and emp.sal < s.hisal<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><ul><li><p>左外连接</p><ul><li><p>两个表在连接过程中除返回满足连接条件的行以外，还返回左表中不满足条件的行，这种连接称为左外联接。</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select deptno, dname,empno,ename from dept left join emp using(deptno);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>右外连接</p><ul><li><p>两个表在连接过程中除返回满足连接条件的行以外，还返回右表中不满足条件的行，这种连接称为右外联接。</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select deptno, dname,empno,ename from dept right join emp using(deptno);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>满外连接</p><ul><li><p>两个表在连接过程中除返回满足连接条件的行以外，还返回两个表中不满足条件的所有行，这种连接称为满外联接。</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select deptno, dname,empno,ename from dept full join emp using(deptno);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>内连接</p><ul><li>在SQL99规范中，内连接只返回满足连接条件的数据。</li></ul></li></ul><hr><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><ul><li><p>将查询到的信息用作条件使用，称之为子查询</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select 字段列表   from table where 表达式  operator (select 字段列表  from table);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>例如：如何查得所有比“CLARK”工资高的员工的信息</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp where sal>( select sal from emp where ename='CLARK');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询工资高于平均工资的雇员名字和工资。</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">Select ename, sal from emp Where sal > (Select avg(sal) from emp )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>：查询和Lucy同一部门且比他工资低的雇员名字和工资。</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">Select ename ,sal from emp where (Sal < (Select sal from emp where ename = 'ALLEN')) and (emp.deptno= (Select deptno from emp where ename = 'ALLEN'))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>特点：</p><ol><li><p>子查询在主查询前执行一次</p></li><li><p>主查询使用子查询的结果</p></li></ol></li><li><p>使用子查询注意事项：</p><ol><li>在查询是基于未知值时应考虑使用子查询</li><li>子查询必须包含在括号内，建议将子查询放在比较运算符的右侧，以增强可读性。</li><li>除非进行Top-N 分析，否则不要在子查询中使用ORDER BY 子句。</li><li>如果子查询返回单行结果，则为单行子查询，可以在主查询中对其使用相应的单行记录比较运算符</li><li>如果子查询返回多行结果，则为多行子查询，此时不允许对其使用单行记录比较运算符</li></ol></li></ul><h4 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h4><ul><li><p>单行子查询只返回一行记录，对单行子查询可使用单行记录比较运算符</p></li><li><p>&lt; 、 &gt; 、 &#x3D; 、 &gt;&#x3D;、 &lt;&#x3D; 、 &lt;&gt;</p></li><li><p>举例：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp where sal > (select sal from emp where empno = 101);# 查询工资最高的雇员名字和工资。Select ename , sal  from emp where Sal = (Select max(sal) from emp) # 查询职务和SCOTT相同，比SCOTT雇佣时间早的雇员信息SELECT  empno, ename, job FROM emp WHERE job =(SELECT job FROM emp WHERE empno=7788) AND hiredate < (SELECT hiredate FROM emp WHERE empno=7788);#查询工资比SCOTT高或者雇佣时间比SCOTT早的雇员的编号和名字select empno,ename,sal,hiredate from emp where sal>(select sal from emp where ename='SCOTT') or hiredate<(select hiredate from emp where ename='SCOTT')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h4><ul><li><p>多行子查询返回多行记录</p></li><li><p>对多行子查询只能使用多行记录比较运算符</p></li><li><p>ALL 和子查询返回的所有值比较</p></li><li><p>ANY 和子查询返回的任意一个值比较</p></li><li><p>IN 等于列表中的任何一个</p></li><li><p>案例1</p></li><li><p>查询工资低于任何一个’CLERK’的工资的雇员信息。</p></li><li><p>思路：查询 ‘CLERK’ 最高工资 ，查询小于最高工资的雇员</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">SELECT  empno, ename, job,sal FROM emp WHERE   sal < ANY (SELECT sal FROM emp WHERE job = 'CLERK') AND job <> 'CLERK';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>案例2</p></li><li><p>查询工资比所有的 ‘SALESMAN’都高的雇员的编号、名字和工资。</p></li><li><p>思路：查询 ‘SALESMAN’最高工资 ，查询高于于最高工资的雇员</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">SELECT  empno, ename,sal FROM emp WHERE sal > ALL(SELECT sal FROM emp WHERE job= 'SALESMAN');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>案例3</p></li><li><p>查询部门20中职务同部门10的雇员一样的雇员信息。</p></li><li><p>思路：部门为10号中的职位，根据职位从20号部门中跳取 </p><pre class="line-numbers language-MySQL"><code class="language-MySQL">SELECT empno, ename, job FROM emp WHERE job IN (SELECT job FROM emp WHERE deptno=10) AND deptno =20;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h4 id="视图的定义及作用"><a href="#视图的定义及作用" class="headerlink" title="视图的定义及作用"></a>视图的定义及作用</h4><ul><li><p>定义</p><ul><li>视图是从若干基本表和（或）其他视图构造出来的表。在创建一个视图时，只是存放的视图的定义，也即是动态检索数据的查询语句，而并不存放视图对应的数据</li><li>在用户使用视图时才去求相对应的数据。所以视图被称作“虚表”</li></ul></li><li><p>作用</p><ol><li><p>可以限制对数据的访问，可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</p></li><li><p>可以使复杂的查询变的简单。在编写查询后，可以方便地重用它而不必知道他的基本查询细节。</p></li><li><p>提供了对相同数据的不同显示</p></li></ol></li></ul><h4 id="视图的创建和删除"><a href="#视图的创建和删除" class="headerlink" title="视图的创建和删除"></a>视图的创建和删除</h4><ul><li><p>创建单表视图</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">CREATE VIEW MYVIEW1 AS SELECT * FROM EMP;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建或修改一个单表视图</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">CREATE OR REPLACE VIEW MYVIEW2 AS SELECT EMPNO,ENAME,JOB,SAL,DEPTNO FROM EMP WHERE DEPTNO >=102<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用视图添加和修改数据</p></li><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">INSERT INTO MYVIEW1 (EMPNO,ENAME,SAL)VALUES(9999,'AAAA',3000);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>为视图添加相关权限</p></li><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">CREATE OR REPLACE VIEW MYVIEW2 AS SELECT EMPNO,ENAME,JOB,SAL,DEPTNO FROM EMP WHERE DEPTNO >=20<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除视图</p></li><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">DROP VIEW MYVIEW4;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>统计视图</p></li><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">CREATE OR REPLACE VIEW MYVIEW4 AS SELECT DEPTNO 部门编号,DNAME 部门名称,AVG(SAL) 平均工资,MAX(SAL) 最高工资,COUNT(*)人数 FROM EMP E JOIN DEPT D USING(DEPTNO)WHERE DEPTNO IS NOT NULL GROUP BY DEPTNO，DNAME ORDER BY AVG(SAL)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>基于其它视图的视图</p></li><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">CREATE OR REPLACE VIEW MYVIEW5 AS SELECT * FROM MYVIEW4 WHERE 部门编号=10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="视图总结"><a href="#视图总结" class="headerlink" title="视图总结"></a>视图总结</h4><ol><li><p>视图对应一个查询语句；视图是（从若干基本表和（或）其他视图构造出来的）表</p></li><li><p>视图进行查询，添加，修改，删除，其实就是对背后的表进行相应操作</p></li><li><p>虚表 在创建一个视图时，只是存放的视图的定义，也即是动态检索数据的查询语句，而并不存放视图对应的数据</p></li><li><p>视图的好处</p><ol><li><p>安全 可以只显示部分行部分列的数据;可以对添加的数据进行检查；可以设置为只读视图</p><p>2.操作简单</p></li><li><p>只显示多个数据库表的部分列，部分行的视图</p></li></ol></li></ol><hr><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><h4 id="InnoDB-引擎-MySQL5-5以后默认使用"><a href="#InnoDB-引擎-MySQL5-5以后默认使用" class="headerlink" title="InnoDB 引擎(MySQL5.5以后默认使用)"></a>InnoDB 引擎(MySQL5.5以后默认使用)</h4><ul><li><p>MySQL 5.5 及以后版本中的默认存储引擎，他的优点如下：</p><ol><li><p>灾难恢复性好</p></li><li><p>支持事务</p></li><li><p>使用行级锁</p></li><li><p>支持外键关联</p></li><li><p>支持热备份</p></li></ol></li><li><p>对于InnoDB引擎中的表，其数据的物理组织形式是簇表（Cluster Table），主键索引和数据是在一起的，数据按主键的顺序物理分布</p></li><li><p>实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的获取</p><p>支持热备份</p></li></ul><h4 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h4><ul><li>特性如下：<ol><li>不支持事务</li><li>使用表级锁，并发性差</li><li>主机宕机后，MyISAM表易损坏，灾难恢复性不佳</li><li>可以配合锁，实现操作系统下的复制备份、迁移</li><li>只缓存索引，数据的缓存是利用操作系统缓冲区来实现的。可能引发过多的系统调用且效率不佳</li><li>数据紧凑存储，因此可获得更小的索引和更快的全表扫描性能</li></ol></li></ul><h4 id="两种存储引擎的大致区别表现在"><a href="#两种存储引擎的大致区别表现在" class="headerlink" title="两种存储引擎的大致区别表现在"></a>两种存储引擎的大致区别表现在</h4><ol><li><p>区别：</p><ol><li><p>InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</p></li><li><p>MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用</p></li><li><p>InnoDB支持外键，MyISAM不支持</p></li><li><p>从MySQL5.5.5以后，InnoDB是默认引擎</p></li><li><p>InnoDB不支持FULLTEXT类型的索引</p></li><li><p>InnoDB中不保存表的行数，如select count(<em>) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含where条件时MyISAM也需要扫描整个表。</p></li><li><p>对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。</p></li><li><p>清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表。</p></li><li><p>InnoDB支持行锁（某些情况下还是锁整表，如 update table set a&#x3D;1 where user like ‘%lee%’</p></li></ol></li><li><p>有人说MYISAM只能用于小型应用，其实这只是一种偏见。</p><p>如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，读写分离，而不是单纯地依赖存储引擎。现在一般都是选用InnoDB了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。</p></li><li><p>总结</p><ul><li>MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。</li><li>MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。</li></ul></li></ol><h4 id="存储引擎的其他说明"><a href="#存储引擎的其他说明" class="headerlink" title="存储引擎的其他说明"></a>存储引擎的其他说明</h4><ul><li><p>存储引擎：数据在数据库中的组织方式（存储方式）。</p></li><li><p>例如：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">create table test_table( id int(11))ENGINE=INNODB ,DEFAULT CHARSET = UTF8;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建表的时候指定存储引擎为INNODB，这个存储引擎在MySQL中用的非常广泛，因为它支持外键、支持事务、支持行级锁。</p></li><li><p>查看MySQL支持的存储引擎命令如下：</p><p><img src="/images/MySQL/%E6%9F%A5%E7%9C%8B%E5%BC%95%E6%93%8E.jpg" alt="查看引擎"></p></li><li><p>除了上述操作之外，还可以在数据库安装盘的my.ini文件可以配置数据库表默认的存储引擎。</p></li></ul><hr><h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>完成一个事情需要的一系列步骤(操作)，这些操作要么同时成功，要么同时失败</li></ul><h4 id="事务的基本操作"><a href="#事务的基本操作" class="headerlink" title="事务的基本操作"></a>事务的基本操作</h4><ol><li>开启事务<ul><li>start transaction;</li></ul></li><li>提交事务<ul><li>commit;</li></ul></li><li>回滚事务<ul><li>rollback;</li></ul></li><li><strong>注意：</strong><ul><li>一旦使用start transaction;开启事务那么自动提交将失效，如果所有操作都正常执行使用commit;提交事务</li><li>当发生异常情况回滚事务，数据(此时为tb_account表)通常回滚到开启事务之前的状态</li></ul></li></ol><ul><li><p>例如：有两个账户分别为张三和李四，他们默认都有1000块钱的余额。在这两个账户之间进行转账。</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 1 创建account表create table tb_account(id int(11) auto_increment,user_name varchar(30) not null,account_blance  int(11) not null, # 账户余额primary key (id))ENGINE=INNODB,default charset =UTF8;# 2 插入数据insert into tb_account(user_name,account_blance)values('ZS',1000),('LS',1000);# 3 执行张三向李四转账500# ZS账户-500，LS账户+500# 下面两个update语句要么同时执行成功要么同时执行失败# 执行下列SQL语句会出现问题：张三的钱减少了，李四的钱没有加上。因为此时的两个update语句并没有使用事务来托管update tb_account set account_blance=account_blance-500 where id=1;# 银行转帐异常情况：如机机房停电update tb_account set account_blance=account_blance+500 where id=2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果想要解决上述问题，那么就可以使用事务来解决</p></li></ul><h4 id="事务的四大特质"><a href="#事务的四大特质" class="headerlink" title="事务的四大特质"></a>事务的四大特质</h4><ol><li>原子性：事务每一步都是不可再分</li><li>一致性：张三和李四账户一共2000块钱，不管转账多少次总金额不变</li><li>持久性：当一个事务执行成功(完毕)，数据会持久化到磁盘的数据文件中。例如转账成功：张三余额变为500，李四余额变为1500.</li><li>隔离性：A事务和B事务同时操作一份数据，相互之间不影响。</li></ol><h4 id="事务的提交方式"><a href="#事务的提交方式" class="headerlink" title="事务的提交方式"></a>事务的提交方式</h4><ol><li><p>自动提交，MySQL默认为自动提交。不需要写commit;就会自动将DML语句持久化提交</p></li><li><p>手动提交，Oracle默认手动提交。</p></li><li><p>在dos窗口中查看当前的提交方式：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 查询结果为1表示自动提交，0表示手动提交 select @@autocommit;# 修改提交方式（自动提交修改为手动提交）set @@autocommit = 0 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ul><li><p>ISO定义的四大隔离级别</p><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>读已提交（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><ul><li>查询当前的隔离级别：select @@tx_isolation</li><li>隔离级别1最低，4最高 。隔离级别越高就越安全，同时内存资源消耗也越大。隔离级别越高效率越低下。</li><li>工作中：1和4都不用，只会在2和3之间切换</li><li><strong>MySQL</strong>默认的事务隔离级别为3，<strong>Oracle</strong>默认隔离界别默认为2</li></ul></li><li><p>并发下的脏读，不可重复读，幻读的问题</p><ol><li><p>脏读问题</p><ul><li>一个事务(A)读取到另一个事务(B)没有提交的数据（破坏了隔离性）.</li><li>例如：事务A开启事务做转账，DML语句执行成功但是没有commit；事务B在另一个窗口开启了，执行Select语句读取tb_account数据，读取到的结果是事务A没有提交的数据。</li></ul></li><li><p>不可重复读问题</p><ul><li>同一个事务中多次读取到的数据不一致(破坏了一致性，update和delete)</li><li>例如：事务A开启事务做转账，DML语句执行成功但是没有commit；；事务B在另一个窗口开启了，执行Select语句读取tb_account数据，读取的结果正确（1000,1000）.</li><li>事务A里面提交了事务。然后事务B再次做Select操作查询结果也正确(500,1500)</li><li>问题：事务B在一次事务中对tb_account表做了两次select操作，两次操作查询的结果不一致。</li></ul></li><li><p>幻读问题</p><ul><li><p>事务A插入一条数据，能够使用select获取结果，此时事务B几乎同时插入了一条或者大量数据，此时事务A看不到事务B的更新（破坏了一致性，insert）。</p></li><li><p>查看事务隔离级别</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># REPEATABLE-READ  可重复读# tx 表示事务的简称  transaction# isolation表示隔离性select @@tx_isolation;# 设置事务的隔离级别 读未提交set session transaction isolation level  READ UNCOMMITTED;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol></li></ul><hr><h2 id="SQL优化之索引"><a href="#SQL优化之索引" class="headerlink" title="SQL优化之索引"></a>SQL优化之索引</h2><h4 id="索引概念"><a href="#索引概念" class="headerlink" title="索引概念"></a>索引概念</h4><ul><li>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。</li><li>拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。</li><li>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</li><li>创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</li><li>索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</li><li>建立索引会占用磁盘空间的索引文件。</li></ul><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ul><li><p>普通索引</p><ul><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">CREATE INDEX 索引名称 on 表名称(列名称);#例如：为person表的pname列建立普通索引CREATE INDEX INDEX_PERSON_PNAME ON PERSON(PNAME);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看是否使用了索引</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">EXPLAIN select * from person where pname= 'Jack';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在MySQL中为表创建主键的同时默认也创建了一个索引</p></li><li><p><strong>注意：</strong></p><ul><li><p>在表中如果条件使用的是模糊查询。</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 前后模糊中间精确不会使用索引EXPLAINselect  * from person where pname like '%e%';# 前面模糊后面精确也不会使用索引EXPLAINselect  * from person where pname like '%e';# 只有前面精确后面模糊才会使用索引，工作中数据量大的表模糊查询尽量不要使用 '%%',也不要使用'%a',他们都不支持索引EXPLAINselect  * from person where pname like 'e%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>总结</p><ol><li><p>如果为某个列创建索引，那么就会在数据文件中创建一个类似TreeMap的文件。如果一个表的数据很多，那么索引会大量的占据数据文件的磁盘空间。</p></li><li><p>不是所有的列都适合建立索引，如果某个列的有效数据很少不要建立索引 。 </p></li><li><p>可以为表的多个列创建复合索引，经常使用的列放在前面。</p></li><li><p>创建主键的同时默认也创建了一个索引。</p></li></ol></li></ul></li><li><p>唯一索引</p><ul><li>唯一索引关键字： unique</li><li>之前学习了唯一约束，当我们创建了一个唯一约束的时候就创建了一个唯一索引，唯一约束就是唯一索引。</li></ul></li><li><p>组合索引</p><p>- </p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 为多个列创建复合索引ALTER TABLE PERSON  DROP  INDEX INDEX_PERSON_AGE_SEX;CREATE INDEX INDEX_PERSON_AGE_SEX ON PERSON(PNAME,PSEX);# 没有创建索执行下面DQL语句引耗时11.427秒，创建索引执行耗时1毫秒SELECT * FROM PERSON WHERE PNAME ="oQlJN" AND PSEX='男';EXPLAIN SELECT * FROM PERSON WHERE  PSEX='男'  AND PNAME ="oQlJN";# 创建的复合索引，但是只对第二个索引列单独进行where条件，不会使用索引# 如果创建复合索引，经常使用的列放在前面，并且查询时一定要带上第一列的条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>全文索引</p><ul><li>概述</li><li>通过数值比较、范围过滤等就可以完成绝大多数我们需要的查询，但是，如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。</li><li>你可能会说，用 like + % 就可以实现模糊匹配了，为什么还要全文索引？like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。</li><li>你可能没有注意过全文索引，不过至少应该对一种全文索引技术比较熟悉：各种的搜索引擎。虽然搜索引擎的索引对象是超大量的数据，并且通常其背后都不是关系型数据库，不过全文索引的基本原理是一样的。</li></ul></li><li><p>删除索引</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 语法ALTER TABLE 表名称 DROP INDEX 索引名称；# 示例ALTER TABLE PERSON DROP INDEX INDEX_PERSON_PNAME;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="数据库设计原则"><a href="#数据库设计原则" class="headerlink" title="数据库设计原则"></a>数据库设计原则</h2><h4 id="引入三大范式"><a href="#引入三大范式" class="headerlink" title="引入三大范式"></a>引入三大范式</h4><ul><li><p>必须保证数据库设计的合理性</p><ul><li><p>数据库设计关系整个系统的架构，关系到后续的开发效率和运行效率</p></li><li><p>数据库的设计主要包含了设计表结构和表之间的联系</p></li></ul></li><li><p>如何是合理数据库</p><ul><li>结构合理</li><li>冗余较小</li><li>尽量避免插入删除修改异常</li></ul></li><li><p>如何才能保证数据库设计水平</p><ul><li>遵循一定的规则</li><li>在关系型数据库中这种规则就称为范式</li></ul></li><li><p>什么是范式（NF&#x3D; NormalForm）</p><ul><li>范式是符合某一种设计要求的总结。</li><li>要想设计一个结构合理的关系型数据库，必须满足一定的范式。</li></ul></li><li><p>范式的分类</p><ul><li>第一范式</li><li>第二范式</li><li>第三范式</li><li>各个范式是依次嵌套包含的,范式越高，设计质量越高，在现实设计中也越难实现，一般数据库设计，只要达到第三范式，即可避免异常的出现</li></ul></li></ul><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><ul><li>要求<ul><li>最基本的范式</li><li>数据库表每一列都是不可分割的基本数据项，同一列中不能有多个值</li><li>简单说就是要确保每列保持原子性</li><li>第一范式的合理遵循需要根据系统的实际需求来定</li></ul></li></ul><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><ul><li>要求<ul><li>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。</li><li>即在一个数据库表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</li></ul></li></ul><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><ul><li>要求<ul><li>确保数据表中的每一列数据都和主键直接相关，而不能间接相关</li><li>属性不依赖于其他非主属性。</li></ul></li></ul><h4 id="范式的优缺点"><a href="#范式的优缺点" class="headerlink" title="范式的优缺点"></a>范式的优缺点</h4><ul><li><p>优点</p><ul><li>结构合理</li><li>冗余较小</li><li>尽量避免插入删除修改异常</li></ul></li><li><p>缺点</p><ul><li><p>性能降低</p></li><li><p>多表查询比单表查询速度慢</p></li></ul></li></ul><h4 id="数据库的设计应该根据当前情况和需求做出灵活的处理。"><a href="#数据库的设计应该根据当前情况和需求做出灵活的处理。" class="headerlink" title="数据库的设计应该根据当前情况和需求做出灵活的处理。"></a>数据库的设计应该根据当前情况和需求做出灵活的处理。</h4><ul><li>在实际设计中，要整体遵循范式理论。</li><li>大多时候我们是打破这些范式来设计的。</li><li>如果在某些特定的情况下还死死遵循范式也是不可取的，因为可能降低数据库的效率，此时可以适当增加冗余而提高性能。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2022/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2022/08/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1><center>数据结构与算法</center><hr><h2 id="数据结构与算法的概述"><a href="#数据结构与算法的概述" class="headerlink" title="数据结构与算法的概述"></a>数据结构与算法的概述</h2><h4 id="数据结构与算法的介绍"><a href="#数据结构与算法的介绍" class="headerlink" title="数据结构与算法的介绍"></a>数据结构与算法的介绍</h4><ul><li><p>算法</p><ul><li><p>算法是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。</p></li><li><p>算法是独立存在的一种解决问题的方法和思想。</p><ul><li>对于算法而言，实现的语言并不重要，重要的是思想。</li></ul></li><li><p>算法可以有不同的语言描述实现版本（如C描述、C++描述、Python描述等）</p></li><li><p>案列一</p><ul><li>有一个背包，背包容量是M&#x3D;150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。</li></ul></li><li><p>案列二</p><ul><li>有一对兔子,从出生后第3个月起每个月都生一对兔子,小兔子长到第4个月后,每个月又生一对兔子,假如兔子不死,问每个月的兔子总数为多少?</li></ul></li></ul></li><li><p>数据结构</p><ul><li>数据结构就是把数据组织起来，为了更方便地使用数据我们为了解决问题，需要将数据保存下来，然后根据数据的存储方式来设计算法实现进行处理，那么数据的存储方式不同就会导致需要不同的算法进行处理。我们希望算法解决问题的效率越快越好，于是我们就需要考虑数据究竟如何保存的问题，这就是数据结构。</li><li>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。</li></ul></li></ul><h4 id="数据结构与算法关系"><a href="#数据结构与算法关系" class="headerlink" title="数据结构与算法关系"></a>数据结构与算法关系</h4><ul><li>程序 &#x3D; 数据结构 + 算法</li><li>数据结构是算法的基础。</li><li>图书馆储藏书籍你肯定见过吧？为了方便查找，图书管理员一般会将书籍分门别类进行“存储”。按照一定规律编号，就是书籍这种“数据”的存储结构。</li><li>那我们如何来查找一本书呢？有很多种办法，你当然可以一本一本地找，也可以先根据书籍类别的编号，是人文，还是科学、计算机，来定位书架，然后再依次查找。笼统地说，这些查找方法都是算法。</li><li>数据结构和算法是相辅相成的。数据结构是为算法服务的，算法要作用在特定的数据结构之上。 因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。</li></ul><h4 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h4><ul><li><p>线性结构</p><ul><li>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系。</li><li>线性结构有两种不同的存储结构，即顺序存储结构(数组)和链式存储结构(链表)。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的。</li><li>链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素结点存放数据元素以及相邻元素的地址信息。</li><li>线性结构常见的有：数组、队列、链表和栈。</li></ul><p><img src="/images/DSA/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%9B%BE.jpg" alt="线性表的顺序存储图"></p></li><li><p>非线性结构</p><ul><li><p>二维数组、多维数组、广义表、树结构、图结构</p><p><img src="/images/DSA/%E6%A0%91%E7%8A%B6%E7%BB%93%E6%9E%84.jpg" alt="树状结构图"></p></li></ul></li></ul><hr><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h4 id="栈的介绍"><a href="#栈的介绍" class="headerlink" title="栈的介绍"></a>栈的介绍</h4><ul><li><p><strong>栈是限制插入和删除只能在一个位置上进行的线性表。</strong></p></li><li><p>其中，允许插入和删除的一端位于表的末端，叫做栈顶（top），不允许插入和删除的另一端叫做栈底（bottom）。对栈的基本操作有 <strong>PUSH（压栈）</strong>和 <strong>POP （出栈）</strong>，前者相当于表的插入操作（向栈顶插入一个元素），后者则是删除操作（删除一个栈顶元素）。栈是一种后进先出（LIFO）**的数据结构，最先被删除的是最近压栈的元素。</p></li><li><p>栈的结构图</p><p><img src="/images/DSA/%E6%A0%88%E5%9B%BE.jpg" alt="栈结构图"></p></li><li><p>压栈图</p><p><img src="/images/DSA/%E5%8E%8B%E6%A0%88%E5%9B%BE.jpg" alt="压栈图"></p></li><li><p>弹栈图</p><p><img src="/images/DSA/%E5%BC%B9%E6%A0%88%E5%9B%BE.jpg" alt="弹栈图"></p></li><li><p>栈实现</p><ul><li>由于栈是一个表，因此任何实现表的方法都可以用来实现栈。主要有两种方式，链表实现和数组实现。</li></ul></li><li><p>链表实现块</p><ul><li>可以使用单链表来实现栈。通过在表顶端插入一个元素来实现 PUSH，通过删除表顶端元素来实现 POP。使用链表方式实现的栈又叫<strong>动态栈</strong>。动态栈有链表的部分特性，即元素与元素之间在物理存储上可以不连续，但是功能有些受限制，动态栈只能在栈顶处进行插入和删除操作，不能在栈尾或栈中间进行插入和删除操作</li></ul></li><li><p>数组实现块</p><ul><li>栈也可以用数组来实现。使用数组方式实现的栈叫<strong>静态栈</strong>。</li></ul></li></ul><h4 id="栈的应用场景"><a href="#栈的应用场景" class="headerlink" title="栈的应用场景"></a>栈的应用场景</h4><ul><li>子程序的调用，在跳往子程序前，会将下一个指令的地址存到堆栈中，知道子程序执行完后再将地址取出，以回到原来的程序中。</li><li>处理递归调用：和子程序的调用类似，只是除了存储下一个指令的地址外，也将参数，区域变量等数据存入堆栈中。</li><li>表达式的转换：【中缀表达式转后缀表达式】与求值（）实际解决</li></ul><h4 id="栈的快速入门"><a href="#栈的快速入门" class="headerlink" title="栈的快速入门"></a>栈的快速入门</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2022/08/21/JDBC/"/>
      <url>/2022/08/21/JDBC/</url>
      
        <content type="html"><![CDATA[<h1><center>JDBC</center><hr><h2 id="JDBC的概述"><a href="#JDBC的概述" class="headerlink" title="JDBC的概述"></a>JDBC的概述</h2><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul><li>JDBC（Java DataBase Connectivity）就是Java数据库连接，即一套使用Java语言来操作数据库的编程接口，也可以认为是一组规范。</li></ul><h4 id="JDBC-的原理"><a href="#JDBC-的原理" class="headerlink" title="JDBC 的原理"></a>JDBC 的原理</h4><ul><li>早期SUN公司的天才们想编写一套可以连接天下所有数据库的API，但是当他们刚刚开始时就发现这是不可完成的任务，因为各个厂商的数据库服务器差异太大了。后来SUN开始与数据库厂商们讨论，最终得出的结论是，由SUN提供一套访问数据库的规范（就是一组接口），并提供连接数据库的协议标准，然后各个数据库厂商会遵循SUN的规范提供一套访问自己公司的数据库服务器的API出现。SUN提供的规范命名为JDBC，而各个厂商提供的，遵循了JDBC规范的，可以访问自己数据库的API被称之为驱动！</li></ul><h4 id="程序员，JDBC，JDBC驱动的关系"><a href="#程序员，JDBC，JDBC驱动的关系" class="headerlink" title="程序员，JDBC，JDBC驱动的关系"></a>程序员，JDBC，JDBC驱动的关系</h4><ul><li><p>三方关系</p></li><li><p>SUN公司是规范制定者，制定了规范JDBC（连接数据库规范）</p><p>数据库厂商微软、甲骨文等分别提供实现JDBC接口的驱动jar包</p><p>程序员学习JDBC规范来应用这些jar包里的类。</p><p><img src="/images/JDBC/%E4%B8%89%E8%A7%92%E5%85%B3%E7%B3%BB.png" alt="三角关系"></p></li><li><p>总结：</p></li><li><p>简单地说，JDBC 可做三件事：与数据库建立连接、发送指令操作数据库并处理结果。</p></li></ul><hr><h2 id="JDBC操作数据库的步骤"><a href="#JDBC操作数据库的步骤" class="headerlink" title="JDBC操作数据库的步骤"></a>JDBC操作数据库的步骤</h2><h4 id="总体步骤"><a href="#总体步骤" class="headerlink" title="总体步骤"></a>总体步骤</h4><ol><li><p>官网下载驱动包</p></li><li><p>加载一个Driver驱动</p></li><li><p>创建数据库连接（Connection）</p></li><li><p>创建SQL命令发送器Statement</p></li><li><p>创建SQL</p></li><li><p>通过Statement发送SQL命令并得到结果</p></li><li><p>处理SQL结果（select语句）</p></li><li><p>关闭数据库资源</p><ul><li><p>ResultSet</p></li><li><p>Statement</p></li><li><p>Connection</p></li></ul></li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h4 id="创建数据库及数据表"><a href="#创建数据库及数据表" class="headerlink" title="创建数据库及数据表"></a>创建数据库及数据表</h4><ul><li>在navicat Premium 15或者dos窗口中创建一个自己的数据库</li><li>在创建的数据库中创建自己的数据表</li></ul><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><ul><li>在idea中新建一个自己的项目</li></ul><h4 id="创建lib目录并引入MySQL驱动包"><a href="#创建lib目录并引入MySQL驱动包" class="headerlink" title="创建lib目录并引入MySQL驱动包"></a>创建lib目录并引入MySQL驱动包</h4><ul><li>在项目下新建一个lib目录</li><li>在目录中引入MySQL驱动包</li><li>在把lib包引入项目环境中</li></ul><hr><h2 id="使用JDBC完成数据的添加操作"><a href="#使用JDBC完成数据的添加操作" class="headerlink" title="使用JDBC完成数据的添加操作"></a>使用JDBC完成数据的添加操作</h2><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li><p>加载MySQL的JDBC驱动</p></li><li><p>建立数据的连接</p></li><li><p>创建SQL命令的发送器</p></li><li><p>编写SQL</p></li><li><p>使用SQL命令发送器发送SQL命令并得到结果</p></li><li><p>处理结果</p></li><li><p>关闭数据库资源</p></li></ol><h4 id="演示代码"><a href="#演示代码" class="headerlink" title="演示代码"></a>演示代码</h4><ul><li><p>Java</p><pre class="line-numbers language-Java"><code class="language-Java">package com.abc.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class Test01Add {    // 驱动器路径    private static final String DRIVER = "com.mysql.jdbc.Driver";    //连接数据库地址    private static final String URL = "jdbc:mysql://localhost:3306/whpowernode?useUnicode=true&useSSL=false&characterEncoding=UTF8";    //数据库用户名    private static final String USER_NAME = "root";    //数据库密码    private static final String USER_PASSWORD = "123456";        public static void main(String[] args) throws ClassNotFoundException, SQLException {        // 加载JDBC访问Oracle的驱动        Class.forName(DRIVER);        // 建立和数据库的连接        Connection conn = DriverManager.getConnection(URL, USER_NAME, USER_PASSWORD);        // 创建SQL命令发送器        Statement stmt = conn.createStatement();        // 使用SQL命令发送器发送SQL命令并得到结果        String sql = "insert into student values(1,'小刚',32,'男','湖北省武汉市')";        int n = stmt.executeUpdate(sql);        // 处理结果        if (n > 0) {            System.out.println("添加成功");        } else {            System.out.println("添加失败");        }        // 关闭数据库资源        stmt.close();        conn.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="URL详解"><a href="#URL详解" class="headerlink" title="URL详解"></a>URL详解</h4><ul><li><p>为什么要定义URL</p><ul><li>Java和MySQL是厂商的，Java程序和MySQL数据库此时不在同一个进程下，此时Java程序需要向MySQL发送请求。</li></ul></li><li><p>如何发送请求</p><pre class="line-numbers language-MYSQL"><code class="language-MYSQL">jdbc:mysql://localhost:3306/whpowernode?useUnicode=true&useSSL=false&characterEncoding=UTF8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><h2 id="使用JDBC完成更新和删除操作"><a href="#使用JDBC完成更新和删除操作" class="headerlink" title="使用JDBC完成更新和删除操作"></a>使用JDBC完成更新和删除操作</h2><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><ul><li><p>代码</p><pre class="line-numbers language-Java"><code class="language-Java">package com.abc.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class Test02Update {    // 驱动器路径    private static final String DRIVER = "com.mysql.jdbc.Driver";    //连接数据库地址    private static final String URL = "jdbc:mysql://localhost:3306/whpowernode?useUnicode=true&useSSL=false&characterEncoding=UTF8";    //数据库用户名    private static final String USER_NAME = "root";    //数据库密码    private static final String USER_PASSWORD = "123456";    public static void main(String[] args) throws ClassNotFoundException, SQLException {        // 加载Oracle的JDBC驱动        Class.forName(DRIVER);        // 建立数据的连接        Connection conn=DriverManager.getConnection(URL, USER_NAME, USER_PASSWORD);        // 创建SQL命令的发送器        Statement stat=conn.createStatement();        // 编写SQL        String sql="update student set name='小明',age=23,sex='女',address='武汉' where id=1";        // 使用SQL命令发送器发送SQL命令并得到结果        int res=stat.executeUpdate(sql);        // 处理结果        if(res>0){            System.out.println("修改成功");        }        else{            System.out.println("处理失败");        }        // 关闭数据库资源        stat.close();        conn.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><ul><li><p>代码</p><pre class="line-numbers language-Java"><code class="language-Java">package com.abc.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.sql.Statement;public class Test03Delete {    // 驱动器路径    private static final String DRIVER = "com.mysql.jdbc.Driver";    //连接数据库地址    private static final String URL = "jdbc:mysql://localhost:3306/whpowernode?useUnicode=true&useSSL=false&characterEncoding=UTF8";    //数据库用户名    private static final String USER_NAME = "root";    //数据库密码    private static final String USER_PASSWORD = "123456";    public static void main(String[] args) throws ClassNotFoundException, SQLException {        // 加载Oracle的JDBC驱动        Class.forName(DRIVER);        // 建立数据的连接        Connection conn=DriverManager.getConnection(URL, USER_NAME, USER_PASSWORD);        // 创建SQL命令的发送器        Statement stat=conn.createStatement();        // 编写SQL        String sql="delete from student where id=1";        // 使用SQL命令发送器发送SQL命令并得到结果        int res=stat.executeUpdate(sql);        // 处理结果        if(res>0){            System.out.println("删除成功");        }        else{            System.out.println("删除失败");        }        // 关闭数据库资源        stat.close();        conn.close();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="DBUtils的简单封装"><a href="#DBUtils的简单封装" class="headerlink" title="DBUtils的简单封装"></a>DBUtils的简单封装</h2><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul><li><p>我们为什么要封装，从以上代码可以看出，每一次写我们创建一个连接，创建一个发送SQL的对象，最后还要关闭，那么我们可以考虑把这重复的代码提取出来!</p></li><li><p>封装代码</p><pre class="line-numbers language-Java"><code class="language-Java">package com.abc.utils;import java.io.Closeable;import java.io.IOException;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;public class DBUtils {    // 驱动器路径    private static final String DRIVER = "com.mysql.jdbc.Driver";    // 连接数据库地址    private static final String URL = "jdbc:mysql://localhost:3306/whpowernode?useUnicode=true&useSSL=false&characterEncoding=UTF8";    // 数据库用户名    private static final String USER_NAME = "root";    // 数据库密码    private static final String USER_PASSWORD = "123456";    /**     * 静态加载驱动程序     */    static {        try {            Class.forName(DRIVER);        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }    /**     * @return 连接对象     */    public static Connection getConn() {        try {            return  DriverManager.getConnection(URL, USER_NAME, USER_PASSWORD);        } catch (SQLException e) {            e.printStackTrace();            System.out.println("创建连接对象异常");        }        return null;    }    /**     * 关闭资源     */    public static void close(Connection conn,Statement statement) {        try {            if (statement != null) {                statement.close();            }        } catch (Exception e) {            e.printStackTrace();        }        try {            if (conn != null) {                conn.close();            }        } catch (Exception e) {            e.printStackTrace();        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="使用JDBC完成查询"><a href="#使用JDBC完成查询" class="headerlink" title="使用JDBC完成查询"></a>使用JDBC完成查询</h4><ul><li><p>代码</p><pre class="line-numbers language-Java"><code class="language-Java">package com.abc.jdbc;import com.abc.utils.DBUtils;import java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;public class Test04Query {    public static void main(String[] args) throws ClassNotFoundException, SQLException {        Connection conn = DBUtils.getConn();        // 创建SQL命令发送器        Statement stmt = conn.createStatement();        // 编写SQL        String sql="select * from student";        // 使用SQL命令发送器发送SQL命令并得到结果        ResultSet rs=stmt.executeQuery(sql);        // 处理结果        while(rs.next()){            int id=rs.getInt(1);            String name=rs.getString(2);            int age=rs.getInt(3);            String sex=rs.getString(4);            String address=rs.getString(5);            System.out.println(id+"  "+name+"  "+age+"   "+sex+"   "+address);        }        // 关闭数据库资源        DBUtils.close(rs);        DBUtils.close(stmt);        DBUtils.close(conn);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JDBC学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2022/08/18/MySQL/"/>
      <url>/2022/08/18/MySQL/</url>
      
        <content type="html"><![CDATA[<h1><center>MySQL</center><hr><h2 id="数据库的相关概念"><a href="#数据库的相关概念" class="headerlink" title="数据库的相关概念"></a>数据库的相关概念</h2><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><ul><li>表达形式：多种表现形式：文本，图形，音频，视频。</li></ul><h4 id="数据库（Database，DB）"><a href="#数据库（Database，DB）" class="headerlink" title="数据库（Database，DB）"></a>数据库（Database，DB）</h4><ul><li>存放数据的仓库，存放在计算机中，按照一定的格式存放，可为用户共享</li></ul><h4 id="数据库管理系统（Database-Management-System-DBMS）"><a href="#数据库管理系统（Database-Management-System-DBMS）" class="headerlink" title="数据库管理系统（Database Management System, DBMS）"></a>数据库管理系统（Database Management System, DBMS）</h4><ul><li>数据库管理系统就是科学的组织和存储数据，高效的获取和维护数据，</li><li>市面上常用的：Oracle MySQL SQL Server  DB2</li></ul><h4 id="数据库应用程序（DBAS）"><a href="#数据库应用程序（DBAS）" class="headerlink" title="数据库应用程序（DBAS）"></a>数据库应用程序（DBAS）</h4><ul><li>在数据库系统基础上，使用数据库管理系统的语法，开发的直接面对最终用户的应用程序</li><li>例如：学生管理系统、人事管理系统、图书管理系统</li></ul><h4 id="数据库管理员（Database-Administrator-DBA）"><a href="#数据库管理员（Database-Administrator-DBA）" class="headerlink" title="数据库管理员（Database Administrator, DBA）"></a>数据库管理员（Database Administrator, DBA）</h4><ul><li>数据库管理系统的操作者</li></ul><h4 id="最终用户"><a href="#最终用户" class="headerlink" title="最终用户"></a>最终用户</h4><ul><li>数据库应用程序的使用者</li></ul><h4 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h4><ul><li><p>数据库 + 数据库管理系统 + 数据库应用程序 + 最终用户</p><p><img src="/images/MySQL/DB.jpg" alt="DB"></p></li></ul><h4 id="数据库的发展阶段"><a href="#数据库的发展阶段" class="headerlink" title="数据库的发展阶段"></a>数据库的发展阶段</h4><ol><li><p>网状数据库</p></li><li><p>层次数据库</p></li><li><p>关系数据库</p><ul><li><p>采用关系[二维表]存储与管理数据</p></li><li><p>采用结构化查询结构（sql）作为客户端数据库服务器之间沟通的桥梁</p></li></ul></li></ol><h4 id="NOSQL数据库"><a href="#NOSQL数据库" class="headerlink" title="NOSQL数据库"></a>NOSQL数据库</h4><ul><li>Not only sql数据库 泛指非关系数据库。</li><li>关系数据库在超大规模和高并发的web2.0纯属动态网站已经显示力不从心，暴露了很多难以克服的问题。Nosql数据库的产生就是为了解决大无框数据集合多重数据种类带来的挑战，尤其是大数据应用难题</li></ul><h2 id="数据库相关基础操作"><a href="#数据库相关基础操作" class="headerlink" title="数据库相关基础操作"></a>数据库相关基础操作</h2><h4 id="数据库的启动与停止"><a href="#数据库的启动与停止" class="headerlink" title="数据库的启动与停止"></a>数据库的启动与停止</h4><ul><li>方式一<ul><li>打开任务管理器，点击服务，找到MySQL右击启动或者停止</li></ul></li><li>方式二<ul><li>打开dos窗口，输入命令，net start mysql  启动，net stop mysql  停止</li></ul></li></ul><h4 id="使用root账户登陆"><a href="#使用root账户登陆" class="headerlink" title="使用root账户登陆"></a>使用root账户登陆</h4><ul><li>mysql -uroot -p123456<ul><li>root  是默认的用户名—超级管理员</li><li>123456  是之前我们安装的时候设置的默认密码</li></ul></li></ul><h4 id="显示所有数据库"><a href="#显示所有数据库" class="headerlink" title="显示所有数据库"></a>显示所有数据库</h4><ul><li><p>命令</p><pre class="line-numbers language-mysql"><code class="language-mysql">show databases;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="默认库几个库的简单说明"><a href="#默认库几个库的简单说明" class="headerlink" title="默认库几个库的简单说明"></a>默认库几个库的简单说明</h4><ul><li><p><strong>information_schema</strong></p><ul><li>information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式。什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。</li><li>在MySQL中，把 information_schema 看作是一个数据库，确切说是信息数据库。其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权 限等。在INFORMATION_SCHEMA中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件</li></ul></li><li><p><strong>mysql</strong></p><ul><li>这个是mysql的核心数据库，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。不可以删除，如果对mysql不是很了解，也不要轻易修改这个数据库里面的表信息。</li></ul></li><li><p><strong>performance_schema</strong></p><ul><li>mysql 5.5 版本 新增了一个性能优化的引擎： PERFORMANCE_SCHEMA这个功能默认是关闭的：</li><li>需要设置参数： performance_schema 才可以启动该功能，这个参数是静态参数，只能写在my.cnf 中 不能动态修改。</li><li>windows里面叫 my.ini文件  C:\ProgramData\MySQL\MySQL Server 5.7  【默认在这个目录】linux里面叫my.cnf文件</li></ul></li><li><p><strong>sys</strong></p><ul><li><p>通过这个库可以快速的了解系统的元数据信息</p><p>这个库确实可以方便DBA发现数据库的很多信息，解决性能瓶颈都提供了巨大帮助</p></li></ul></li><li><p><strong>注</strong>：以上几个库都不能删除（重点）</p></li></ul><h4 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h4><ul><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">use  <数据库名称>;-- 例如：使用mysql数据库use mysql;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>修改数据库密码</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">1使用mysql数据库use mysql;2修改密码命令(将root用户的密码修改为123456)update mysql.user set authentication_string=PASSWORD('123456') where user='root;3刷新flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h4><ul><li><p>命令</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">CREATE USER 'username'@'host' IDENTIFIED BY 'password';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>说明：</p><ul><li>username：你将创建的用户名</li><li>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%</li><li>password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器</li></ul></li><li><p>列如：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#创建dog用户密码为123456 并且限制只能在本机上登录访问CREATE USER 'dog'@'localhost' IDENTIFIED BY '123456';#创建pig用户密码为123456 并且限制只能在指定的ip（192.168.1.101）登录访问CREATE USER 'pig'@'192.168.1.101_' IDENDIFIED BY '123456';#创建pig用户密码为123456 并且可以通过任意远程主机登录访问CREATE USER 'pig'@'%' IDENTIFIED BY '123456';#创建pig用户输入任意密码即可登录并且可以通过任意远程主机登录访问CREATE USER 'pig'@'%' IDENTIFIED BY '';#创建pig用户没有密码并且可以通过任意远程主机登录访问CREATE USER 'pig'@'%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="给用户授权"><a href="#给用户授权" class="headerlink" title="给用户授权"></a>给用户授权</h4><ul><li><p>命令</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">GRANT privileges ON databasename.tablename TO 'username'@'host'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>说明：</p><ul><li>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL</li><li>databasename：数据库名</li><li>tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，</li></ul></li><li><p>例如：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#给pig用户授权 给 test库里面 的user表 查询和插入权限并且可以通过任意主机访问GRANT SELECT, INSERT ON test.user TO 'pig'@'%';#给pig用户授权 给所有库的所有表 增删改查的权限并且可以通过任意主机访问GRANT ALL ON *.* TO 'pig'@'%'; #给pig用户授权 给 maindataplus库里面 的所有表 增删改查权限并且可以通过任意主机访问GRANT ALL ON maindataplus.* TO 'pig'@'%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注：用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">GRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h2><h4 id="DDL数据定义语言"><a href="#DDL数据定义语言" class="headerlink" title="DDL数据定义语言"></a>DDL数据定义语言</h4><ul><li><p>全称Data Definition Language，主要用于创建和删除结构。</p><ol><li><p>创建结构相关操作：表、视图、索引、数据 </p></li><li><p>删除结构相关操作：表、视图、索引、数据</p></li><li><p>改变结构相关操作：表、视图、索引、数据</p></li></ol></li></ul><h4 id="DML数据操纵语言"><a href="#DML数据操纵语言" class="headerlink" title="DML数据操纵语言"></a>DML数据操纵语言</h4><ul><li><p>DML对表和视图进行插入、删除、更新相关操作，全称Data Manipulation Language。</p><ol><li><p>插入数据关键字：insert</p></li><li><p>删除数据关键字：delete</p></li><li><p>修改数据关键字：update</p></li></ol></li></ul><h4 id="DQL数据查询语言"><a href="#DQL数据查询语言" class="headerlink" title="DQL数据查询语言"></a>DQL数据查询语言</h4><ul><li>对表和视图进行操作，全称： Data Query Language<ol><li>DQL关键字 select</li></ol></li></ul><h4 id="TCL事务控制语言"><a href="#TCL事务控制语言" class="headerlink" title="TCL事务控制语言"></a>TCL事务控制语言</h4><ul><li>TCL全称Transaction Control Language，使用事务管理DML操作。</li></ul><ol><li><p>提交事务关键字 commit;</p></li><li><p>回滚事务关键字 rollback;</p></li><li><p>开启事务关键字 start transaction;</p></li></ol><h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><table><thead><tr><th>数据类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>tinyint</td><td>8bit</td><td>范围(-128~127)</td></tr><tr><td>smallint</td><td>16bit</td><td>范围(-32768~32767)</td></tr><tr><td>mediumint</td><td>24bit</td><td>范围(-8388608~8388607)</td></tr><tr><td>int</td><td>32bit</td><td>范围(-2147483648~2147483647)&#x3D;&#x3D;（对应java中的类型int 或 Integer 记住）&#x3D;&#x3D;</td></tr><tr><td>bigint</td><td>64bit</td><td>范围(+-9.22*10的18次方)&#x3D;&#x3D;（对应java中的类型long或 Long记住）&#x3D;&#x3D;</td></tr></tbody></table><h4 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h4><table><thead><tr><th>数据类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr><td>float(m,d)</td><td>32bit</td><td>单精度浮点型，m总个数，d小数位</td></tr><tr><td>double(m,d)</td><td>64bit</td><td>双精度浮点型，m总个数，d小数位</td></tr></tbody></table><h4 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h4><ul><li>浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。 decimal(m,d) 参数m是总个数，d是小数位。</li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tbody><tr><td>char(n)</td><td>固定长度，最多255个字符，索引效率级高，必须在括号里定义长度，可以有默认值</td></tr><tr><td>varchar(n)</td><td>可变长度，最多65535个字符&#x3D;&#x3D;（对应java中的类型String或  char记住）&#x3D;&#x3D;</td></tr><tr><td>tinytext</td><td>可变长度，最多255个字符</td></tr><tr><td>text</td><td>可变长度，最多65535个字符</td></tr><tr><td>mediumtext</td><td>可变长度，最多2的24次方-1个字符</td></tr><tr><td>longtext</td><td>可变长度，最多2的32次方-1个字符</td></tr><tr><td>json</td><td>mysql5.7新增加的数据类型，用来存放json数据</td></tr></tbody></table><ul><li><p><strong>char、varchar、text区别 （理解）</strong></p><ul><li><strong>char</strong>：存储定长数据很方便，CHAR字段上的索引效率级高，必须在括号里定义长度，可以有默认值，比如定义char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间（自动用空格填充），且在检索的时候后面的空格会隐藏掉，所以检索出来的数据需要记得用什么trim之类的函数去过滤空格。</li><li><strong>varchar</strong>：存储变长数据，但存储效率没有CHAR高，必须在括号里定义长度，可以有默认值。保存数据的时候，不进行空格自动填充，而且如果数据存在空格时，当值保存和检索时尾部的空格仍会保留。另外，varchar类型的实际长度是它的值的实际长度+1，这一个字节用于保存实际使用了多大的长度。</li><li><strong>text</strong>：存储可变长度的非Unicode数据，最大长度为2^31-1个字符。text列不能有默认值，存储或检索过程中，不存在大小写转换，后面如果指定长度，不会报错误，但是这个长度是不起作用的，意思就是你插入数据的时候，超过你指定的长度还是可以正常插入。</li></ul></li><li><p>实战结论：</p><ol><li><p>经常变化的字段用varchar；</p></li><li><p>知道固定长度的用char；</p></li><li><p>超过255字节的只能用varchar或者text；</p></li><li><p>能用varchar的地方不用text；</p></li><li><p>能够用数字类型的字段尽量选择数字类型而不用字符串类型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接回逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了；</p></li><li><p>同一张表出现多个大字段，能合并时尽量合并，不能合并时考虑分表</p></li></ol></li></ul><h4 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h4><table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tbody><tr><td>date</td><td>日期 ‘2021-1-1’（对应java中的类Date  记住）</td></tr><tr><td>time</td><td>时间 ‘12:25:36’</td></tr><tr><td>datetime</td><td>日期时间 ‘2021-1-1 22:06:44’ （对应java中的类Date 记住）</td></tr><tr><td>timestamp</td><td>自动存储记录修改时间</td></tr></tbody></table><h4 id="逻辑类型"><a href="#逻辑类型" class="headerlink" title="逻辑类型"></a>逻辑类型</h4><ul><li><strong>（适用于：性别、状态、标记等只有两个值的）</strong><ul><li>Logic类型使用bit表示，它只能存储两个值0或者1</li></ul></li></ul><h4 id="数据类型的属性"><a href="#数据类型的属性" class="headerlink" title="数据类型的属性"></a>数据类型的属性</h4><table><thead><tr><th>关键字</th><th>含义</th></tr></thead><tbody><tr><td>NULL</td><td>数据列可包含NULL值</td></tr><tr><td>NOT NULL</td><td>数据列不允许包含NULL值</td></tr><tr><td>DEFAULT</td><td>默认值</td></tr><tr><td>PRIMARY KEY</td><td>主键</td></tr><tr><td>AUTO_INCREMENT</td><td>自动递增，适用于整数类型</td></tr><tr><td>UNSIGNED</td><td>无符号</td></tr><tr><td>CHARACTER SET  name</td><td>指定一个字符集</td></tr></tbody></table><h2 id="MySQL表的相关操作"><a href="#MySQL表的相关操作" class="headerlink" title="MySQL表的相关操作"></a>MySQL表的相关操作</h2><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><ul><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">create table <表名称>(   列名称1 数据类型1,   列名称2 数据类型2,   ..........   列名称n 数据类型n);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>实列1：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">create table tb_student(     id int(11),     stu_name varchar(50),     stu_sex bit,     stu_hobby varchar(50),     stu_age smallint);#注意：最后一列没有逗号#列与列之间以英文逗号隔开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>实例2：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">create table student(     id int(11),     stu_name varchar(50),     stu_sex bit,     stu_hobby varchar(50),     stu_age smallint)default charset=UTF8, ENGINE=INNODB;# DEFAULT CHARSET 用于指定表中数据的字符集编码方式# ENGINE 用于指定表的存储引擎<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="数据存储问题"><a href="#数据存储问题" class="headerlink" title="数据存储问题"></a>数据存储问题</h4><ul><li><p>现在我们在数据库中创建了一个表，那么如我们把电脑重启，这个表还在不在呢？</p></li><li><p>测试结果为  在  那是为什么呢？</p></li><li><p>原因是当我们创建表个表之后，在我们数据库的文件系统里面就会有一个对应的文件存在</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">.frm文件：保存了每个表的元数据，包括表结构的定义等；.ibd文件：InnoDB引擎开启了独立表空间(my.ini中配置innodb_file_per_table = 1)产生的存放该表的数据和索引的文件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h4><ul><li><p>创建表之后如何查看是否创建成功？可以通过desc命令来查看表结构</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 第一种方式查看表结构# desc <表名称>;desc student;# 第二种方式查看表结构# show create <表名称>;show create table tb_student;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h4><pre class="line-numbers language-MySQL"><code class="language-MySQL">基本语法如下：alter table <表名称>;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>案列1</p></li><li><p>添加列，例如：向student表新增加一列stu_height学生身高</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 语法如下：# alter table <表名称> add column <列名称>  <数据类型>;alter table student add column stu_height int(11);# 查看表结构desc student;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>案例2</p></li><li><p>删除某一个列，例如：删除student表中的学生身高</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 语法如下：# alter table <表名称> drop column <列名称>;alter table student drop column stu_height;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>案例3</p></li><li><p>修改列名称和数据类型：例如修改stu_sex 为 student_sex 数据类型修改为 varchar(30)</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 语法如下：# alter table <表名称> change column <原列名称> <新列名称> <数据类型>;# 修改stu_sex 为 student_sex 数据类型修改为 varchar(30)alter table student change column stu_sex student_sex varchar(30);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>案例4</p></li><li><p>修改某一列的数据类型，例如：将学生年龄修改为int类型</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 语法如下：# alter table  <表名称> modify column <原来的列名称>  <新的数据类型>;# 例如：alter table student modify column stu_age int(11);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><ul><li><p>删除删除之前先判断表是否还存在</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">drop table if exists <表名称>;  # 刪除之前先做校验，表在数据库中存在才删除drop table if exists EMP_bak;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>直接删除</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">drop table <表名称>;drop table EMP_bak;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>显示当前的所有表</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">show tables;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><h2 id="MySQL表里面数据的相关操作DML"><a href="#MySQL表里面数据的相关操作DML" class="headerlink" title="MySQL表里面数据的相关操作DML"></a>MySQL表里面数据的相关操作DML</h2><h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><ul><li><p>单个添加</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 插入所有的数据语法如下：#  insert into 表名称 values (值1,值2,……);insert into student values(101,'老王',0,'足球',31);# 注意：在插入所有的数据时values后面的括号必须填满所有列，保证参数的顺序和表中的列的顺序 一致insert into student values(101,'老王',0,'足球');#报错：ERROR 1136 (21S01): Column count doesn't match value count at row 1# 错误原因：student表后面没有指定列名称，默认将插入所有列的数据，此时student表定义了5列，但是只插入了4列数据，所以报错# 注意：student表后面没有指定列名称，那么在插入数据的时候，数据的类型必须跟定义表结构类型保持一致<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>批量添加</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 行与行之间使用半角逗号分离，value关键字只定义一次insert into student(id,stu_name,stu_sex,stu_hobby,stu_age)values(108,'老王',1,'Basketball',39),(1031,'老张',1,'Basketball',39);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><ul><li><p>批量修改</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 修改所有数据# 语法update <表名称> set 列名称 = 值;# 例如：student表的年龄全部修改为50update student set stu_age = 50;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>单个修改</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 如果只想修改某一行的数据，需要加上条件# 例如：我只想修改id为1031的年龄为60where 表示行过滤where id=1031 表示只选择id为1031的行进行修改# 下面代码执行步骤：首先执行 update student 确定修改那张表# 然后执行 where 条件 确定修改表中的哪一行，不满住条件的行都会被过滤掉update student set stu_age = 60 where id = 1031;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>单个修改多个值</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">update student set stu_age = 60，name='习大大' where id = 1031;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><ul><li><p>删除一个</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 删除某一条数据 语法：delete from <表名称>  where 条件;# 例如：删除id为108的student数据delete from student where id = 108;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除全部</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 语法delete from <表名称> ;# 例如：删除student表所有数据delete from student;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>truncate关键字</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">truncate 是DDL，删除所有数据，不支持where，不能回滚delete 是DML，可以删除部分数据，因为支持where，可以回滚#总体上truncate效率比delete高，他们都只能删除数据不能删除表结构，只有drop才能删除表结构<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><ul><li><p>什么是主键：主要关键字，一个表如果创建了主键那么该行的所有数据必须在表中 非空并且唯一。</p></li><li><p>主键设计原则：</p><ul><li><p>在开发中，一般的主键为数值类型，呈递增趋势，如果不想每次都插入主键，我们可以让数据自动增长</p></li><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">create table tb_class(    # id是主键列，不用显示插入值 让其自动增长    id int(11)auto_increment,      # not null 非空约束     class_name varchar(30) not null,     # 班级描述     class_desc varchar(100),      # 为tb_class表的id列设置主键约束     primary key (id)       )ENGINE=INNODB,DEFAULT CHARSET UTF8;    # 注意： MySQL 数据库 auto_increment自动增长和主键primary key 是配套的不能单独使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h4 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h4><ul><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">create table tb_class(# id是主键列，不用显示插入值 让其自动增长 id int(11) auto_increment,   # not null 非空约束 class_name varchar(30) not null,  # 班级描述 class_desc varchar(100),   # 为tb_class表的id列设置主键约束 primary key (id)   )ENGINE=INNODB,DEFAULT CHARSET UTF8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h4><ul><li>制定一个规则，让表的某一列数据必须唯一</li><li>特征：某列数据可以为空，但是必须唯一</li><li>语法：</li></ul><pre class="line-numbers language-MySQL"><code class="language-MySQL">#列如：学生的手机号码create table tb_1(    phone int unique)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h4><ul><li><p>为某一列制定一个默认规则</p></li><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#列如：性别默认为 0create table tb_1(    phone int unique,sex int DEFAULT 0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><ul><li><p>外部的关键字叫做外键，通常为多张表中建立联系，确保表与表之间的数据安全性，一致性，能够减少数据冗余(重复的数据)。</p></li><li><p>前面几个约束：在一张表建立约束(规则)</p></li><li><p>外键约束： 多张表之间建立约束(关联，联系)</p></li><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#场景：创建一个tb_student表，为其添加默认约束、唯一约束、非空约束、外键约束。create table tb_student(  id  int(11) auto_increment,  stu_name varchar(50) not null,    # unique 唯一混熟  stu_mobile varchar(20) unique,      # 默认约束 性别默认为1  0女  1男  stu_sex bit default 1,  class_id int(11) not null,     # 学生表的class_id建立外键去关联 tb_class表的主键  primary key (id),  foreign key (class_id) references tb_class(id))ENGINE=INNODB,DEFAULT CHARSET UTF8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="约束关键字总结"><a href="#约束关键字总结" class="headerlink" title="约束关键字总结"></a>约束关键字总结</h4><table><thead><tr><th>约束名称</th><th>关键字</th></tr></thead><tbody><tr><td>主键约束</td><td>primary key</td></tr><tr><td>非空约束</td><td>not null</td></tr><tr><td>唯一约束</td><td>unique</td></tr><tr><td>默认约束</td><td>default</td></tr><tr><td>外键约束</td><td>foreign key…….references</td></tr></tbody></table><ul><li><p>约束分为两类：</p><ol><li><p>行级别约束： 主键约束、外键约束</p></li><li><p>列级别约束： 非空约束、唯一约束、默认约束</p></li></ol></li><li><p>外键约束小结：</p><ol><li>foreign key(外键列) </li><li>references 主表 (主键列)</li><li>references 关键字的右边是主表的主键列，左边是从表的外键列，该关键字在主表和从边之间建立了联系。</li></ol></li><li><p>创建表小结：没有外键的表是主表，有外键的表是从表。先创建主表后创建从表(有外键的表是从表)</p></li><li><p>插入数据小结：先插入主表数据后插入从表数据</p></li><li><p>删除数据小结：先删除从表数据后删除主表数据</p></li></ul><hr><h2 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h2><h4 id="一对一（one-to-one）"><a href="#一对一（one-to-one）" class="headerlink" title="一对一（one-to-one）"></a>一对一（one-to-one）</h4><ul><li><p>一对一关系就如球队与球队所在地址之间的关系，一支球队仅有一个地址，而一个地址区也仅有一支球队。</p></li><li><p>数据表间一对一关系的表现有两种，一种是外键关联，一种是主键关联。</p></li><li><p>如图：</p><p><img src="/images/MySQL/%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB.jpg" alt="一对一关系"></p></li></ul><h4 id="一对多或多对一（many-to-one）"><a href="#一对多或多对一（many-to-one）" class="headerlink" title="一对多或多对一（many-to-one）"></a>一对多或多对一（many-to-one）</h4><ul><li><p>存在最普遍的映射关系，简单来讲就如球员与球队的关系；</p><ul><li><p>一对多：从球队角度来说一个球队拥有多个球员 即为一对多</p></li><li><p>多对一：从球员角度来说多个球员属于一个球队 即为多对一数据表间一对多关系</p></li></ul></li><li><p>如图：</p><p><img src="/images/MySQL/%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg" alt="一对多关系"></p></li><li><p>案列</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 班级表 create table tb_class(    # id是主键列，不用显示插入值 让其自动增长 id int(11) auto_increment,       # not null 非空约束 class_name varchar(30) not null,     # 班级描述 class_desc varchar(100),     # 为tb_class表的id列设置主键约束 primary key (id)  )ENGINE=INNODB,DEFAULT CHARSET UTF8;# 学生表create table tb_student(  id  int(11) auto_increment,  stu_name varchar(50) not null,    # unique 唯一约束  stu_mobile varchar(20) unique,     # 默认约束 性别默认为1  0女  1男  stu_sex bit default 1,     #非空约束 class_id  class_id int(11) not null,    #id为主键  primary key (id),    # 学生表的class_id建立外键去关联 tb_class表的主键  foreign key (class_id) references tb_class(id))ENGINE=INNODB,DEFAULT CHARSET UTF8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="多对多（many-to-many）"><a href="#多对多（many-to-many）" class="headerlink" title="多对多（many-to-many）"></a>多对多（many-to-many）</h4><ul><li><p>多对多关系也很常见，例如学生与选修课之间的关系，一个学生可以选择多门选修课，而每个选修课又可以被多名学生选择。</p></li><li><p>数据库中的多对多关联关系一般需采用中间表的方式处理，将多对多转化为两个一对多。</p></li><li><p>数据表间多对多关系如图：</p><p><img src="/images/MySQL/%E5%A4%9A%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg" alt="多对多关系"></p></li><li><p>案列</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">-- 学生表create table tb_student(  id  int(11) auto_increment,  stu_name varchar(50) not null,  stu_mobile varchar(20) unique, -- unique 唯一混熟  stu_sex bit default 1, -- 默认约束 性别默认为1  0女  1男  class_id int(11) not null,   primary key (id),    -- 学生表的class_id建立外键去关联 tb_class表的主键  foreign key (class_id) references tb_class(id))ENGINE=INNODB,DEFAULT CHARSET UTF8;-- 课程表create table tb_course(  id int(11) auto_increment,  course_name varchar(30) not null, -- 课程名称  primary key(id))ENGINE=INNODB,DEFAULT CHARSET UTF8;-- 学生课程表是一个中间表，在学生表和课程表之间解耦create table tb_student_course(  stu_id int(11), -- 学生id  course_id int(11), -- 课程id  course_score int(11), -- 课程的成绩    primary key(stu_id,course_id),    -- 复合主键-- stu_id作为外键关联学生表主键  foreign key(stu_id) references tb_student(id),  -- course_id作为外键关联课程表主键 foreign key(course_id) references tb_course(id))ENGINE=INNODB,DEFAULT CHARSET UTF8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="单表数据查询"><a href="#单表数据查询" class="headerlink" title="单表数据查询"></a>单表数据查询</h2><h4 id="最简单的查询方式"><a href="#最简单的查询方式" class="headerlink" title="最简单的查询方式"></a>最简单的查询方式</h4><ul><li><p>查询所有员工的信息</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp;#查询所有部门信息select * from dept;#查询所有员工的 编号，姓名，工资，职位信息select empno, ename,sal,job  from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h4><ul><li><p>查询所有员工的编号、姓名、工资、年终奖信息</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select empno, ename,sal,sal*1.08 from emp;#查询所有员工的 编号，姓名，工资，年薪信息select empno, ename,sal, sal*12 from emp;#查询所有员工的 编号，姓名，工资，年薪增加1000 信息select empno, ename,sal, sal*12 +1000 from emp;注：在Select语句中，对数值型数据可以使用算术运算符创建表达式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="使用字段别名"><a href="#使用字段别名" class="headerlink" title="使用字段别名"></a>使用字段别名</h4><ul><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select empno as 员工编号, ename 员工姓名, sal*12 年薪  from emp;select empno, ename "Ename", sal*12 "Anual Salary" from emp;select sal*12+5000  as "年度工资(加年终奖)" from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>字段别名说明：</p><ul><li>重命名查询结果中的字段，以增强可读性，别名如果含有空格或其他特殊字符或大小写敏感，需用双引号引起来。</li><li>AS可以省略</li></ul></li></ul><h4 id="去重查询"><a href="#去重查询" class="headerlink" title="去重查询"></a>去重查询</h4><ul><li><p>缺省情况下，查询结果中包含所有符合条件的记录行，包括重复行</p></li><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#查询所有员工的部门编号信息select deptno from emp;使用DISTINCT关键字可从查询结果中清除重复行#查询所有员工的部门编号信息并去重select distinct deptno from emp;#查询所有员工的职位信息并去重select distinct  job from emp;DISTINCT的作用范围是后面所有字段的组合#查询所有员工的部门编号和职位信息去重select distinct deptno，  job from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><ul><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#使用order by 子句对查询结果进行排序#排序方式包括升序（asc，缺省）和降序（desc）两种：#查询员工的编号，姓名，工资并按照工资升序排序select empno, ename, sal from emp order by sal;#查询员工的编号，姓名，工资并按照工资升序降序select empno, ename, sal from emp order by sal desc ;#按多字段排序#查询员工的编号，姓名，工资并先按照部门编号升序排序，如果编号相同，再按照工资升序排序select deptno, empno, ename, sal from emp order by deptno, sal;#使用字段别名排序#查询员工的编号，姓名，年薪并先按照年薪升序排序  (别名 可以在 排序中使用)select empno, ename, sal*12 annsal from emp order by annsal;#查询员工的编号，年薪 且年薪大于10000 select empno, sal*12 incomeyear where incomeyear>10000 # (错误的)select empno, sal*12 incomeyear where sal*12 >10000 # (对的)#因为 where子句的优先级比select子句高#执行顺序:  from > where>select >order by <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><ul><li><p><strong>关键字：limit</strong></p></li><li><p>案列1：查询每页显示3条数据，查询第一页数据的sql</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp limit 3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>案列2：每页显示三条数据，查询第五页的数据的sql</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp limit 12，3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>limit 参数1，参数2</p><ul><li>参数1：表示索引</li><li>参数2：表示每页显示的信息条数</li></ul></li><li><p><strong>参数1的计算方法：</strong>索引 &#x3D; （查询页数 - 1）* 2</p></li></ul><h4 id="合并查询"><a href="#合并查询" class="headerlink" title="合并查询"></a>合并查询</h4><ul><li><p>将多个select语句联合(合并)为一个select语句，涉及的关键字union 和union all。</p></li><li><p>union all 不管是否重复，全部合并</p></li><li><p>union 如果有重复的，过滤掉重复的</p></li><li><p>案列：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp  where DEPTNO=10 union all select * from emp  where DEPTNO=20select * from emp  where DEPTNO=10 union select * from emp  where DEPTNO=20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h2><h4 id="用法举例"><a href="#用法举例" class="headerlink" title="用法举例"></a>用法举例</h4><ul><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#查询员工的部门编号为10的所有信息select * from emp where deptno=10;#查询员工的姓名为‘JACK’的所有信息select * from emp where ename = 'JACK';#查询员工的入职日期为2020-12-12的所有信息select * from emp where hiredate = '2020-12-12';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>注意：</strong>字符串和日期值要用单引号括起来，字符串大小写不敏感。</p></li><li><p>日期格式敏感，缺省的日期格式是’YYYY-MM-DD HH:mm:ss’</p></li></ul><h4 id="查询条件中可以使用比较运算符"><a href="#查询条件中可以使用比较运算符" class="headerlink" title="查询条件中可以使用比较运算符"></a>查询条件中可以使用比较运算符</h4><ul><li><p>MySQL支持如下比较运算符： &gt; &gt;&#x3D;  &lt; &lt;&#x3D;  !&#x3D;  &lt;&gt;</p><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>between…and..</td><td>介于两值之间（闭区间）</td></tr><tr><td>in(set)</td><td>出现在集合中</td></tr><tr><td>like</td><td>模糊查询</td></tr><tr><td>is null</td><td>为控制</td></tr></tbody></table></li><li><p><strong>注意：</strong>MySQL使用“&#x3D;”运算符来判断表达式是否相等，它没有&#x3D;&#x3D;Java使用!&#x3D;表示不等于，MySQL也支持。但是我们不要使用，效率太低了</p></li><li><p>MySQL使用的不等于使用&lt;&gt;</p></li><li><p>案列：查询工资大于2900的员工信息</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp where sal > 2900;#查询部门编号不等于30的员工信息select * from emp where deptno <> 30;#查询工资在1600 到 2900之间的员工信息select * from emp where sal between 1600 and 2900;#查询员工姓名为'SMITH','CLARK','KING'的员工信息select * from emp where ename in('SMITH','CLARK','KING');<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>模糊查询案列：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 查询员工名字中包含 m的员工信息select * from emp where ename like '%M%'#查询名字以M开头的员工信息select * from emp where ename like 'M%'#查询名字以M结尾的员工信息select * from emp where ename like '%M'# _下划线 表示占位符,一个下划线表示占一个字符# 查找名字中倒数第二个字母为M的员工信息select * from emp where ename like '%M_'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="使用LIKE运算符执行模糊查询（通配查询）"><a href="#使用LIKE运算符执行模糊查询（通配查询）" class="headerlink" title="使用LIKE运算符执行模糊查询（通配查询）"></a>使用LIKE运算符执行模糊查询（通配查询）</h4><ul><li><p>% 表示零或多个字符    _ 表示一个字符</p></li><li><p>对于特殊符号可使用ESCAPE 标识符来查找</p></li><li><p>案列：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#查询员工姓名以S开头的员工信息select * from emp where ename like 'S%';#查询 员工 姓名第二给字母为A的员工信息select * from emp where ename like '_A%';# 查找名字中包含下划线的员工信息select * from emp where ename like '%/_%' escape  '/'select * from emp where ename like '%\_%'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>判断空值</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#查询没有奖金的员工信息select * from emp where comm is null;#查询有奖金的员工信息select * from emp where comm is not null; （固定写法）#查询有奖金的员工信息select * from emp where not comm is null; （通用型）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="查询条件中可以使用逻辑运算符"><a href="#查询条件中可以使用逻辑运算符" class="headerlink" title="查询条件中可以使用逻辑运算符"></a>查询条件中可以使用逻辑运算符</h4><ul><li><p>语法：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#查询部门编号为10 且工资大于1000 的员工信息select * from emp where deptno = 10 and sal > 1000;#查询部门编号为10 或者 岗位为 ‘ClerK’的员工信息select * from emp where deptno = 10 or job = ‘CLERK’;#查询工资不等800,1500,2000 的员工信息select * from emp where sal not in (800, 1500, 2000);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="SQL优化问题"><a href="#SQL优化问题" class="headerlink" title="SQL优化问题"></a>SQL优化问题</h4><ul><li>AND: 把检索结果较少的条件放到后面</li><li>OR: 把检索结果较多的条件放到后面</li></ul><h4 id="四种运算符优先级：算术-gt-连接-gt-比较-gt-逻辑"><a href="#四种运算符优先级：算术-gt-连接-gt-比较-gt-逻辑" class="headerlink" title="四种运算符优先级：算术&gt;连接&gt;比较&gt;逻辑"></a>四种运算符优先级：算术&gt;连接&gt;比较&gt;逻辑</h4><p><img src="/images/MySQL/%E8%BF%90%E7%AE%97%E7%AC%A6.jpg" alt="运算符"></p><ul><li><p><strong>可使用小括号强行改变运算顺序</strong></p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp where job='SALESMAN' or job='CLERK' and sal>=1280;select * from emp where (job='SALESMAN' or job='CLERK') and sal>=1280;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>优先级： Not&gt;and&gt;or</li></ul></li></ul><hr><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><h4 id="函数概念"><a href="#函数概念" class="headerlink" title="函数概念"></a>函数概念</h4><ul><li>使用函数可以大大提高SELECT语句操作数据库的能力。它给数据的转换和处理提供了方便。</li><li>函数只是将取出的数据进行处理，不会改变数据库中的值。</li></ul><h4 id="函数的分类"><a href="#函数的分类" class="headerlink" title="函数的分类"></a>函数的分类</h4><ul><li><p>单行函数分类</p><ol><li>数学函数</li><li>字符串函数</li><li>日期和时间函数</li><li>条件判断函数</li><li>系统信息函数</li><li>加密函数</li><li>格式化函数</li></ol></li><li><p>多行函数分类</p><ol><li><p>仅适用数值型的多行函数 </p><ul><li><p>sum() 求和 </p></li><li><p>avg() 求平均值</p></li></ul></li><li><p>适用任何类型数据</p><ul><li><p>count() 计数  </p></li><li><p>max() 求最大值    </p></li><li><p>min() 求最小值</p></li></ul></li></ol></li></ul><h4 id="单行函数"><a href="#单行函数" class="headerlink" title="单行函数"></a>单行函数</h4><ul><li><p>数学函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">ABS(x)   # 返回x的绝对值PI()     # 返回圆周率π，默认显示6位小数SQRT(x)  # 返回非负数的x的二次方根MOD(x,y) # 返回x被y除后的余数CEIL(x)、CEILING(x) #返回不小于x的最小整数FLOOR(x)  #返回不大于x的最大整数ROUND(x)、ROUND(x,y)  #前者返回最接近于x的整数，即对x进行四舍五入；后者返回最接近x的数，其值保留到小数点后面y位，若y为负值，则将保留到x到小数点左边y位SIGN(x)  #返回参数x的符号，-1表示负数，0表示0，1表示正数POW(x,y)和、POWER(x,y) # 返回x的y次乘方的值EXP(x)  #返回e的x乘方后的值LOG(x)  #返回x的自然对数，x相对于基数e的对数LOG10(x) # 返回x的基数为10的对数RADIANS(x)  #返回x由角度转化为弧度的值DEGREES(x)  #返回x由弧度转化为角度的值SIN(x)、ASIN(x)  #前者返回x的正弦，其中x为给定的弧度值；后者返回x的反正弦值，x为正弦COS(x)、ACOS(x) # 前者返回x的余弦，其中x为给定的弧度值；后者返回x的反余弦值，x为余弦TAN(x)、ATAN(x)  #前者返回x的正切，其中x为给定的弧度值；后者返回x的反正切值，x为正切COT(x)   #返回给定弧度值x的余切RAND(x)   #返回0-1之间的随机小数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>字符串函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">（1）CHAR_LENGTH(str)  #计算字符串字符个数（2）CONCAT(s1,s2，...) # 返回连接参数产生的字符串，一个或多个待拼接的内容，任意一个为NULL则返回值为NULL（3）CONCAT_WS(x,s1,s2,...) #返回多个字符串拼接之后的字符串，每个字符串之间有一个x（4）INSERT(s1,x,len,s2)  #返回字符串s1，其子字符串起始于位置x，被字符串s2取代len个字符（5）LOWER(str)和LCASE(str)、UPPER(str)和UCASE(str)#前两者将str中的字母全部转换成小写，后两者将字符串中的字母全部转换成大写（6）LEFT(s,n)、RIGHT(s,n)  #前者返回字符串s从最左边开始的n个字符，后者返回字符串s从最右边开始的n个字符（7）LPAD(s1,len,s2)、RPAD(s1,len,s2)  #前者返回s1，其左边由字符串s2填补到len字符长度，假如s1的长度大于len，则返回值被缩短至len字符；前者返回s1，其右边由字符串s2填补到len字符长度，假如s1的长度大于len，则返回值被缩短至len字符（8）LTRIM(s)、RTRIM(s) #前者返回字符串s，其左边所有空格被删除；后者返回字符串s，其右边所有空格被删除（9）TRIM(s)  #返回字符串s删除了两边空格之后的字符串（10）TRIM(s1 FROM s)  #删除字符串s两端所有子字符串s1，未指定s1的情况下则默认删除空格（11）REPEAT(s,n) # 返回一个由重复字符串s组成的字符串，字符串s的数目等于n（12）SPACE(n) # 返回一个由n个空格组成的字符串（13）REPLACE(s,s1,s2)  #返回一个字符串，用字符串s2替代字符串s中所有的字符串s1（14）STRCMP(s1,s2) # 若s1和s2中所有的字符串都相同，则返回0；根据当前分类次序，第一个参数小于第二个则返回-1，其他情况返回1（15）SUBSTRING(s,n,len)、MID(s,n,len) #两个函数作用相同，从字符串s中返回一个第n个字符开始、长度为len的字符串（16）LOCATE(str1,str)、POSITION(str1 IN str)、INSTR(str,str1) #三个函数作用相同，返回子字符串str1在字符串str中的开始位置（从第几个字符开始）（17）REVERSE(s)  #将字符串s反转（18）ELT(N,str1,str2,str3,str4,...) #返回第N个字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>日期和时间函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">（1）CURDATE()、CURRENT_DATE()#将当前日期按照"YYYY-MM-DD"或者"YYYYMMDD"格式的值返回，具体格式根据函数用在字符串或是数字语境中而定（2）CURRENT_TIMESTAMP()、LOCALTIME()、NOW()、SYSDATE() #这四个函数作用相同，返回当前日期和时间值，格式为"YYYY_MM-DD HH:MM:SS"或"YYYYMMDDHHMMSS"，具体格式根据函数用在字符串或数字语境中而定（3）MONTH(date)和MONTHNAME(date) #前者返回指定日期中的月份，后者返回指定日期中的月份的名称（4）WEEK(d)、WEEKOFYEAR(d) #前者计算日期d是一年中的第几周，后者计算某一天位于一年中的第几周（5）DAYOFYEAR(d)、DAYOFMONTH(d) #前者返回d是一年中的第几天，后者返回d是一月中的第几天（6）EXTRACT(type FROM date) #从日期中提取一部分，type可以是YEAR、YEAR_MONTH、DAY_HOUR、DAY_MICROSECOND、DAY_MINUTE、DAY_SECOND（7）TimeStampDiff #(间隔类型，前一个日期，后一个日期) #例如距离现在差了多少年：TimeStampDiff(year, 前一个日期, now())#间隔类型有：second秒，minute分，hour时，day天，week周，month月，quarter季度，year年（8）DATE_ADD(date,INTERVAL expr type)、ADD_DATE(date,INTERVAL expr type) # 返回将起始时间加上expr type之后的时间，比如DATE_ADD('2010-12-31 23:59:59', INTERVAL 1 SECOND)表示的就是把第一个时间加1秒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>条件判断函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">（1）IF(expr,v1,v2) #如果expr是TRUE则返回v1，否则返回v2（2）IFNULL(v1,v2) #函数  如果v1的值不为NULL，则返回v1，否则返回v2。（2）CASE expr WHEN v1 THEN r1 [WHEN v2 THEN v2] [ELSE rn] END #如果expr等于某个vn，则返回对应位置THEN后面的结果，如果与所有值都不想等，则返回ELSE后面的rn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>系统信息函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">（1）VERSION() #查看MySQL版本号（2）CONNECTION_ID() #查看当前用户的连接数（3）USER()、CURRENT_USER()、SYSTEM_USER()、SESSION_USER() #查看当前被MySQL服务器验证的用户名和主机的组合，一般这几个函数的返回值是相同的（4）CHARSET(str) #查看字符串str使用的字符集（5）COLLATION() #查看字符串排列方式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>加密函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">（1）PASSWORD(str)#从原明文密码str计算并返回加密后的字符串密码，注意这个函数的加密是单向的（不可逆），因此不应将它应用在个人的应用程序中而应该只在MySQL服务器的鉴定系统中使用（2）MD5(str) #为字符串算出一个MD5 128比特校验和，改值以32位十六进制数字的二进制字符串形式返回（3）ENCODE(str, pswd_str) #使用pswd_str作为密码，加密str（4） DECODE(crypt_str,pswd_str) #使用pswd_str作为密码，解密加密字符串crypt_str，crypt_str是由ENCODE函数返回的字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>格式化函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">（1）FORMAT(x,n) #将数字x格式化，并以四舍五入的方式保留小数点后n位，结果以字符串形式返回（2）CONV(N,from_base,to_base) #不同进制数之间的转换，返回值为数值N的字符串表示，由from_base进制转换为to_base进制（3）INET_ATON(expr) #给出一个作为字符串的网络地址的点地址表示，返回一个代表该地址数值的整数，地址可以使4或8比特（4）INET_NTOA(expr) #给定一个数字网络地址（4或8比特），返回作为字符串的该地址的点地址表示（5）BENCHMARK(count,expr) #重复执行count次表达式expr，它可以用于计算MySQL处理表达式的速度，结果值通常是0（0只是表示很快，并不是没有速度）。另一个作用是用它在MySQL客户端内部报告语句执行的时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="多行函数"><a href="#多行函数" class="headerlink" title="多行函数"></a>多行函数</h4><ul><li><p>对一组数据进行运算，针对一组数据（多行记录）只返回一个结果，也称分组函数。</p></li><li><p>常用的多行函数</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">sum()  avg()   仅适用数值型count()   max()   min()   适用任何类型数据# 查询平均工资，最高工资，最低工资，工资总select avg(sal), max(sal), min(sal), sum(sal) from emp; # 查询最早入职和最晚入职的员工信息select max(hiredate), min(hiredate) from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>多行函数与空值</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#多行函数除了count(*)外，都跳过空值而处理非空值select count(comm),sum(comm),avg(comm) from emp;#可使用IF()函数强制多行函数处理空值select count(IF(comm is null,0,comm)),sum(IF(comm is null,0,comm)),avg(IF(comm is null,0 ,comm)) from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>count（*）函数的说明</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">count(*) #返回组中总记录数目；count(exp) # 返回表达式exp值非空的记录数目；count(distinct(exp)) # 返回表达式exp值不重复的、非空的记录数目。#查询所有员工个数select count(*) from emp;#查询有奖金的员工的个数select count(comm) from emp;#查询部门的个数select count(distinct(deptno)) from emp; #查询所有的员工数select count(IF(comm IS null,0,comm)) from emp;select count(IFnull(0,comm)) from emp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="group-by子句"><a href="#group-by子句" class="headerlink" title="group by子句"></a>group by子句</h4><ul><li><p>GROUP BY 子句将表中数据分成若干小组</p></li><li><p>语法格式</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select column, group_function(column)from table[where condition][group by group_by_expression][order by column];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用举例</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#按照部门分组并查询部门的平均工资select deptno, avg(sal) from emp group by deptno;#按照部门分组，并统计部门的平均工资和数量select  deptno, ename,count(*),avg(sal) from emp group by deptno；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注意事项</p><ul><li><p>出现在SELECT列表中的字段，如果不是包含在多行函数中，那么该字段必须同时在GROUP BY子句中出现。</p></li><li><p>错误：select ename,deptno,sum(sal) from emp group by deptno;</p><ul><li>|以上的SQL在MYSQL中是不错的，但是在oracle是错的，在开发中避免这样写</li><li>包含在GROUP BY子句中的字段则不必须出现在SELECT列表中。</li></ul></li><li><p>如果没有GROUP BY子句，SELECT列表中不允许出现字段（单行函数）与多行函数混用的情况</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select empno, sal from emp;  #合法select avg(sal) from emp;  #合法select empno, avg(sal) from emp;  #非法# 不允许在WHERE 子句中使用多行函数select deptno, avg(sal)   from empwhere avg(sal) > 2000;   # 执行where时尚未执行groupby 及其他group by deptno;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><h4 id="having子句"><a href="#having子句" class="headerlink" title="having子句"></a>having子句</h4><ul><li><p>对分组查询的结果进行过滤，要使用having从句。</p></li><li><p>having从句过滤分组后的结果，它只能出现在group by从句之后，而where从句要出现在group by从句之前。</p></li><li><p>where过滤行，having过滤分组。having支持所有where操作符。</p></li><li><p>语法格式：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select column, group_function(column)from table[where condition][group by  group_by_expression][having group_condition][order by column];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>注意：</strong>执行过程：from–where – group by– having– select– order by</li></ul></li><li><p>用法举例</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 列出平均工资大于8000元的部门IDselect deptno, avg(sal)   from empgroup by deptno having avg(sal) > 8000  order by deptno;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>练习：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 统计人数小于4的部门的平均工资。Select deptno ,avg(sal),count(*)  from emp group by deptno having count(*) <4# 统计各部门的最高工资，排除最高工资小于8000的部门。Select max(sal),deptno  from emp group by deptno having not max(sal)<8000# 显示部门编号大于10 的部门的人数，要求人数大于3Select deptno, count(*) from emp group by deptno  having deptno > 10 and count(*) > 3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="连接查询SQL-92"><a href="#连接查询SQL-92" class="headerlink" title="连接查询SQL 92"></a>连接查询SQL 92</h2><h4 id="链接查询的概述"><a href="#链接查询的概述" class="headerlink" title="链接查询的概述"></a>链接查询的概述</h4><ul><li>笛卡尔集</li><li>等值连接</li><li>非等值连接</li><li>外连接</li><li>自连接</li><li>说明。SQL92是1992年提出的查询语法，向上兼容</li></ul><h4 id="连接查询语法"><a href="#连接查询语法" class="headerlink" title="连接查询语法"></a>连接查询语法</h4><ul><li><p>语法规则：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">SELECTtable1.column, table2.column FROM table1, table2 WHERE table1.column1 = table2.column2;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>特点</p><ul><li>在 WHERE 子句中写入连接条件</li><li>当多个表中有重名列时，必须在列的名字前加上表名作为前缀</li></ul></li><li><p>链接查询的类型</p><ul><li><p>等值连接 – Equijoin</p></li><li><p>非等值连接 – Non-equijoin</p></li><li><p>左连接 –LEFT JOIN</p></li><li><p>右连接 –RIGHT JOIN</p></li><li><p>自连接 – Self join</p></li></ul></li></ul><h4 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><ul><li></li></ul><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from dept; # 4条记录select * from emp; ; # 14条记录select * from dept,emp; ; # 4*14=56条记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>总结</p><ol><li>检索出的行的数目将是第一个表中的行数乘以第二个表中的行数</li><li>检索出的列的数目将是第一个表中的列数加上第二个表中的列数</li><li>应该保证所有联结都有where子句，不然数据库返回比想要的数据多得多的数据</li></ol></li></ul><h4 id="等值查询"><a href="#等值查询" class="headerlink" title="等值查询"></a>等值查询</h4><ul><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">#查询员工信息以及部门信息select * from dept,emp where dept.deptno=emp.deptno;#查询员工信息以及部门信息（使用别名）select * from dept d,emp e where d.deptno=e.deptno;#针对重复的字段必须要指定哪个表的字段select d.deptno,dname,loc,empno,ename,job from dept d,emp e where d.deptno=e.deptno;#查询10号部门的员工信息以及部门信息select d.deptno,dname,loc,empno,ename,job from dept d,emp e where d.deptno=e.deptno and d.deptno=10#查询部门的地址为武汉的员工信息以及部门信息select d.deptno,dname,loc,empno,ename,job from dept d,emp e where d.deptno=e.deptno and loc='武汉';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>注意点：</strong></p><ol><li>当被连接的多个表中存在同名字段时，须在该字段前加上”表名.”前缀</li><li>可使用AND 操作符增加查询条件；</li><li>使用表别名可以简化查询，使用表名（表别名）前缀可提高查询效率；</li></ol></li></ul><h4 id="非等值查询"><a href="#非等值查询" class="headerlink" title="非等值查询"></a>非等值查询</h4><ul><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 要求：查询员工的工资等级select  empno,ename,job,sal,grade from emp e,salgrade swhere e.sal<s.hisal and e.sal>s.losal;# 查询经理的工资等级select  empno,ename,job,sal,grade from emp e,salgrade swhere e.sal<s.hisal and e.sal>s.losal and e.job='MANAGER';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><ul><li><p>特点：将一个表当两个表使用</p></li><li><p>使用举例：查询每个员工的工号、姓名、直接领导姓名</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 要求：必须使用别名select e1.empno,e1.ename,e1.job,e2.ename from emp e1 ,emp e2where e1.mgr=e2.empnoorder by e1.empno;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="连接查询SQL99"><a href="#连接查询SQL99" class="headerlink" title="连接查询SQL99"></a>连接查询SQL99</h2><h4 id="SQL语法概述"><a href="#SQL语法概述" class="headerlink" title="SQL语法概述"></a>SQL语法概述</h4><ul><li><p><strong>SQL92</strong>的语法规则的缺点：</p><ol><li>语句过滤条件和表连接的条件都放到了where子句中 。</li><li>当条件过多时，联结条件多，过滤条件多时，就容易造成混淆</li></ol></li><li><p><strong>SQL99</strong>修正了整个缺点，把联结条件，过滤条件分开来，包括以下新的TABLE JOIN的句法结构：</p><ol><li><p>交叉连接（Cross join）</p></li><li><p>自然连接（Natural join）</p></li><li><p>使用Using子句建立连接</p></li><li><p>使用On子句建立连接</p></li><li><p>连接（ Outer join ）</p><ul><li><p>内连接INNER JOIN </p></li><li><p>左连接LEFT JOIN</p></li><li><p>右连接RIGHT JOIN</p></li></ul></li></ol></li></ul><h4 id="SQL99语法"><a href="#SQL99语法" class="headerlink" title="SQL99语法"></a>SQL99语法</h4><ul><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select 字段列表 from table1 [cross join table2] |     # 1：交叉连接[natural join table2] |                              # 2：自然连接[join table2 using (字段名)] |                        # 3：using子句[join table2 on (table1.column_name = table2.column_name)] |  # 4：on子句[(left | right | full outer) join table2on (table1.column_name = table2.column_name)]; # 5：左/右/满外连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="交叉连接"><a href="#交叉连接" class="headerlink" title="交叉连接"></a>交叉连接</h4><ul><li><p>Cross join 产生了一个笛卡尔集，其效果等同于在两个表进行连接时未使用WHERE子句限定连接条件;</p></li><li><p>可以使用where条件从笛卡尔集中选出满足条件的记录。</p></li><li><p>举例：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select dept.deptno,dname,ename from dept cross join emp; 等价于select dept.deptno,dname,ename from dept,emp; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><ul><li><p>Natural join基于两个表中的全部同名列建立连接</p></li><li><p>从两个表中选出同名列的值均对应相等的所有行</p></li><li><p>如果两个表中同名列的数据类型不同，则出错</p></li><li><p>不允许在参照列上使用表名或者别名作为前缀</p></li><li><p>自然连接的结果不保留重复的属性</p></li><li><p>举例：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select empno, ename, sal, deptno, dname from emp natural join dept<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="using子句"><a href="#using子句" class="headerlink" title="using子句"></a>using子句</h4><ul><li><p>如果不希望参照被连接表的所有同名列进行等值连接，自然连接将无法满足要求，可以在连接时使用USING子句来设置用于等值连接的列（参照列）名。</p></li><li><p>using子句引用的列在sql任何地方不能使用表名或者别名做前缀</p></li><li><p>举例：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select e.ename,e.sal,deptno,d. dname from emp e join dept d using(deptno) where deptno=10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="on子句"><a href="#on子句" class="headerlink" title="on子句"></a>on子句</h4><ul><li><p>自然连接的条件是基于表中所有同名列的等值连接，为了设置任意的连接条件或者指定连接的列，需要使用ON子句</p></li><li><p>连接条件与其它的查询条件分开书写</p></li><li><p>使用ON 子句使查询语句更容易理解</p></li><li><p>举例：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 1.select ename,dname from emp inner join  dept on emp.deptno=dept.deptno where  emp.deptno=30;# 2.select empno, ename, sal, emp.deptno, dname from emp inner  join dept on (emp.deptno = dept.deptno and sal>5000);# 3.select * from dept, emp where dept.deptno = emp.deptno and sal>5000;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>第三种是sql92里面的查询方法，和上面两种等价</p></li><li><p>等列名</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select emp.empno,emp.ename,dept.dname,dept.loc from emp join dept on emp.deptno = dept.deptno<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>不等列名</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select  emp.empno,emp.ename, s.grade  from emp join salgrade s on emp.sal > s.losal and emp.sal < s.hisal<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><ul><li><p>左外连接</p><ul><li>两个表在连接过程中除返回满足连接条件的行以外，还返回左表中不满足条件的行，这种连接称为左外联接。</li></ul><pre class="line-numbers language-MySQL"><code class="language-MySQL">select deptno, dname,empno,ename from dept left join emp using(deptno);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>右外连接</p><ul><li><p>两个表在连接过程中除返回满足连接条件的行以外，还返回右表中不满足条件的行，这种连接称为右外联接。</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select deptno, dname,empno,ename from dept right join emp using(deptno);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>满外连接</p><ul><li>两个表在连接过程中除返回满足连接条件的行以外，还返回两个表中不满足条件的所有行，这种连接称为满外联接。</li></ul><pre class="line-numbers language-MySQL"><code class="language-MySQL">select deptno, dname,empno,ename from dept full join emp using(deptno);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>内连接</p><ul><li>在SQL99规范中，内连接只返回满足连接条件的数据。</li></ul></li></ul><hr><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><ul><li><p>将查询到的信息用作条件使用，称之为子查询</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select 字段列表   from table where 表达式  operator (select 字段列表  from table);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>例如：如何查得所有比“CLARK”工资高的员工的信息</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp where sal>( select sal from emp where ename='CLARK');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>查询工资高于平均工资的雇员名字和工资。</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">Select ename, sal from emp Where sal > (Select avg(sal) from emp )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>：查询和Lucy同一部门且比他工资低的雇员名字和工资。</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">Select ename ,sal from emp where (Sal < (Select sal from emp where ename = 'ALLEN')) and (emp.deptno= (Select deptno from emp where ename = 'ALLEN'))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>特点：</p><ol><li><p>子查询在主查询前执行一次</p></li><li><p>主查询使用子查询的结果</p></li></ol></li><li><p>使用子查询注意事项：</p><ol><li>在查询是基于未知值时应考虑使用子查询</li><li>子查询必须包含在括号内，建议将子查询放在比较运算符的右侧，以增强可读性。</li><li>除非进行Top-N 分析，否则不要在子查询中使用ORDER BY 子句。</li><li>如果子查询返回单行结果，则为单行子查询，可以在主查询中对其使用相应的单行记录比较运算符</li><li>如果子查询返回多行结果，则为多行子查询，此时不允许对其使用单行记录比较运算符</li></ol></li></ul><h4 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h4><ul><li><p>单行子查询只返回一行记录，对单行子查询可使用单行记录比较运算符</p></li><li><p>&lt; 、 &gt; 、 &#x3D; 、 &gt;&#x3D;、 &lt;&#x3D; 、 &lt;&gt;</p></li><li><p>举例：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">select * from emp where sal > (select sal from emp where empno = 101);# 查询工资最高的雇员名字和工资。Select ename , sal  from emp where Sal = (Select max(sal) from emp) # 查询职务和SCOTT相同，比SCOTT雇佣时间早的雇员信息SELECT  empno, ename, job FROM emp WHERE job =(SELECT job FROM emp WHERE empno=7788) AND hiredate < (SELECT hiredate FROM emp WHERE empno=7788);#查询工资比SCOTT高或者雇佣时间比SCOTT早的雇员的编号和名字select empno,ename,sal,hiredate from emp where sal>(select sal from emp where ename='SCOTT') or hiredate<(select hiredate from emp where ename='SCOTT')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h4><ul><li><p>多行子查询返回多行记录</p></li><li><p>对多行子查询只能使用多行记录比较运算符</p></li><li><p>ALL 和子查询返回的所有值比较</p></li><li><p>ANY 和子查询返回的任意一个值比较</p></li><li><p>IN 等于列表中的任何一个</p></li><li><p>案例1</p></li><li><p>查询工资低于任何一个’CLERK’的工资的雇员信息。</p></li><li><p>思路：查询 ‘CLERK’ 最高工资 ，查询小于最高工资的雇员</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">SELECT  empno, ename, job,sal FROM emp WHERE   sal < ANY (SELECT sal FROM emp WHERE job = 'CLERK') AND job <> 'CLERK';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>案例2</p></li><li><p>查询工资比所有的 ‘SALESMAN’都高的雇员的编号、名字和工资。</p></li><li><p>思路：查询 ‘SALESMAN’最高工资 ，查询高于于最高工资的雇员</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">SELECT  empno, ename,sal FROM emp WHERE sal > ALL(SELECT sal FROM emp WHERE job= 'SALESMAN');<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>案例3</p></li><li><p>查询部门20中职务同部门10的雇员一样的雇员信息。</p></li><li><p>思路：部门为10号中的职位，根据职位从20号部门中跳取 </p><pre class="line-numbers language-MySQL"><code class="language-MySQL">SELECT empno, ename, job FROM emp WHERE job IN (SELECT job FROM emp WHERE deptno=10) AND deptno =20;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h4 id="视图的定义及作用"><a href="#视图的定义及作用" class="headerlink" title="视图的定义及作用"></a>视图的定义及作用</h4><ul><li><p>定义</p><ul><li>视图是从若干基本表和（或）其他视图构造出来的表。在创建一个视图时，只是存放的视图的定义，也即是动态检索数据的查询语句，而并不存放视图对应的数据</li><li>在用户使用视图时才去求相对应的数据。所以视图被称作“虚表”</li></ul></li><li><p>作用</p><ol><li><p>可以限制对数据的访问，可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</p></li><li><p>可以使复杂的查询变的简单。在编写查询后，可以方便地重用它而不必知道他的基本查询细节。</p></li><li><p>提供了对相同数据的不同显示</p></li></ol></li></ul><h4 id="视图的创建和删除"><a href="#视图的创建和删除" class="headerlink" title="视图的创建和删除"></a>视图的创建和删除</h4><ul><li><p>创建单表视图</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">CREATE VIEW MYVIEW1 AS SELECT * FROM EMP;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建或修改一个单表视图</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">CREATE OR REPLACE VIEW MYVIEW2 AS SELECT EMPNO,ENAME,JOB,SAL,DEPTNO FROM EMP WHERE DEPTNO >=102<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用视图添加和修改数据</p></li><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">INSERT INTO MYVIEW1 (EMPNO,ENAME,SAL)VALUES(9999,'AAAA',3000);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>为视图添加相关权限</p></li><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">CREATE OR REPLACE VIEW MYVIEW2 AS SELECT EMPNO,ENAME,JOB,SAL,DEPTNO FROM EMP WHERE DEPTNO >=20<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>删除视图</p></li><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">DROP VIEW MYVIEW4;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>统计视图</p></li><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">CREATE OR REPLACE VIEW MYVIEW4 AS SELECT DEPTNO 部门编号,DNAME 部门名称,AVG(SAL) 平均工资,MAX(SAL) 最高工资,COUNT(*)人数 FROM EMP E JOIN DEPT D USING(DEPTNO)WHERE DEPTNO IS NOT NULL GROUP BY DEPTNO，DNAME ORDER BY AVG(SAL)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>基于其它视图的视图</p></li><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">CREATE OR REPLACE VIEW MYVIEW5 AS SELECT * FROM MYVIEW4 WHERE 部门编号=10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="视图总结"><a href="#视图总结" class="headerlink" title="视图总结"></a>视图总结</h4><ol><li><p>视图对应一个查询语句；视图是（从若干基本表和（或）其他视图构造出来的）表</p></li><li><p>视图进行查询，添加，修改，删除，其实就是对背后的表进行相应操作</p></li><li><p>虚表 在创建一个视图时，只是存放的视图的定义，也即是动态检索数据的查询语句，而并不存放视图对应的数据</p></li><li><p>视图的好处</p><ol><li><p>安全 可以只显示部分行部分列的数据;可以对添加的数据进行检查；可以设置为只读视图</p><p>2.操作简单</p></li><li><p>只显示多个数据库表的部分列，部分行的视图</p></li></ol></li></ol><hr><h2 id="MySQL存储引擎"><a href="#MySQL存储引擎" class="headerlink" title="MySQL存储引擎"></a>MySQL存储引擎</h2><h4 id="InnoDB-引擎-MySQL5-5以后默认使用"><a href="#InnoDB-引擎-MySQL5-5以后默认使用" class="headerlink" title="InnoDB 引擎(MySQL5.5以后默认使用)"></a>InnoDB 引擎(MySQL5.5以后默认使用)</h4><ul><li><p>MySQL 5.5 及以后版本中的默认存储引擎，他的优点如下：</p><ol><li><p>灾难恢复性好</p></li><li><p>支持事务</p></li><li><p>使用行级锁</p></li><li><p>支持外键关联</p></li><li><p>支持热备份</p></li></ol></li><li><p>对于InnoDB引擎中的表，其数据的物理组织形式是簇表（Cluster Table），主键索引和数据是在一起的，数据按主键的顺序物理分布</p></li><li><p>实现了缓冲管理，不仅能缓冲索引也能缓冲数据，并且会自动创建散列索引以加快数据的获取</p><p>支持热备份</p></li></ul><h4 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h4><ul><li>特性如下：<ol><li>不支持事务</li><li>使用表级锁，并发性差</li><li>主机宕机后，MyISAM表易损坏，灾难恢复性不佳</li><li>可以配合锁，实现操作系统下的复制备份、迁移</li><li>只缓存索引，数据的缓存是利用操作系统缓冲区来实现的。可能引发过多的系统调用且效率不佳</li><li>数据紧凑存储，因此可获得更小的索引和更快的全表扫描性能</li></ol></li></ul><h4 id="两种存储引擎的大致区别表现在"><a href="#两种存储引擎的大致区别表现在" class="headerlink" title="两种存储引擎的大致区别表现在"></a>两种存储引擎的大致区别表现在</h4><ol><li><p>区别：</p><ol><li><p>InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</p></li><li><p>MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用</p></li><li><p>InnoDB支持外键，MyISAM不支持</p></li><li><p>从MySQL5.5.5以后，InnoDB是默认引擎</p></li><li><p>InnoDB不支持FULLTEXT类型的索引</p></li><li><p>InnoDB中不保存表的行数，如select count(<em>) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含where条件时MyISAM也需要扫描整个表。</p></li><li><p>对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。</p></li><li><p>清空整个表时，InnoDB是一行一行的删除，效率非常慢。MyISAM则会重建表。</p></li><li><p>InnoDB支持行锁（某些情况下还是锁整表，如 update table set a&#x3D;1 where user like ‘%lee%’</p></li></ol></li><li><p>有人说MYISAM只能用于小型应用，其实这只是一种偏见。</p><p>如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，读写分离，而不是单纯地依赖存储引擎。现在一般都是选用InnoDB了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。</p></li><li><p>总结</p><ul><li>MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。</li><li>MyISAM类型的表强调的是性能，其执行速度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。</li></ul></li></ol><h4 id="存储引擎的其他说明"><a href="#存储引擎的其他说明" class="headerlink" title="存储引擎的其他说明"></a>存储引擎的其他说明</h4><ul><li><p>存储引擎：数据在数据库中的组织方式（存储方式）。</p></li><li><p>例如：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">create table test_table( id int(11))ENGINE=INNODB ,DEFAULT CHARSET = UTF8;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>创建表的时候指定存储引擎为INNODB，这个存储引擎在MySQL中用的非常广泛，因为它支持外键、支持事务、支持行级锁。</p></li><li><p>查看MySQL支持的存储引擎命令如下：</p><p><img src="/images/MySQL/%E6%9F%A5%E7%9C%8B%E5%BC%95%E6%93%8E.jpg" alt="查看引擎"></p></li><li><p>除了上述操作之外，还可以在数据库安装盘的my.ini文件可以配置数据库表默认的存储引擎。</p></li></ul><hr><h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>完成一个事情需要的一系列步骤(操作)，这些操作要么同时成功，要么同时失败</li></ul><h4 id="事务的基本操作"><a href="#事务的基本操作" class="headerlink" title="事务的基本操作"></a>事务的基本操作</h4><ol><li>开启事务<ul><li>start transaction;</li></ul></li><li>提交事务<ul><li>commit;</li></ul></li><li>回滚事务<ul><li>rollback;</li></ul></li><li><strong>注意：</strong><ul><li>一旦使用start transaction;开启事务那么自动提交将失效，如果所有操作都正常执行使用commit;提交事务</li><li>当发生异常情况回滚事务，数据(此时为tb_account表)通常回滚到开启事务之前的状态</li></ul></li></ol><ul><li><p>例如：有两个账户分别为张三和李四，他们默认都有1000块钱的余额。在这两个账户之间进行转账。</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 1 创建account表create table tb_account(id int(11) auto_increment,user_name varchar(30) not null,account_blance  int(11) not null, # 账户余额primary key (id))ENGINE=INNODB,default charset =UTF8;# 2 插入数据insert into tb_account(user_name,account_blance)values('ZS',1000),('LS',1000);# 3 执行张三向李四转账500# ZS账户-500，LS账户+500# 下面两个update语句要么同时执行成功要么同时执行失败# 执行下列SQL语句会出现问题：张三的钱减少了，李四的钱没有加上。因为此时的两个update语句并没有使用事务来托管update tb_account set account_blance=account_blance-500 where id=1;# 银行转帐异常情况：如机机房停电update tb_account set account_blance=account_blance+500 where id=2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果想要解决上述问题，那么就可以使用事务来解决</p></li></ul><h4 id="事务的四大特质"><a href="#事务的四大特质" class="headerlink" title="事务的四大特质"></a>事务的四大特质</h4><ol><li>原子性：事务每一步都是不可再分</li><li>一致性：张三和李四账户一共2000块钱，不管转账多少次总金额不变</li><li>持久性：当一个事务执行成功(完毕)，数据会持久化到磁盘的数据文件中。例如转账成功：张三余额变为500，李四余额变为1500.</li><li>隔离性：A事务和B事务同时操作一份数据，相互之间不影响。</li></ol><h4 id="事务的提交方式"><a href="#事务的提交方式" class="headerlink" title="事务的提交方式"></a>事务的提交方式</h4><ol><li><p>自动提交，MySQL默认为自动提交。不需要写commit;就会自动将DML语句持久化提交</p></li><li><p>手动提交，Oracle默认手动提交。</p></li><li><p>在dos窗口中查看当前的提交方式：</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 查询结果为1表示自动提交，0表示手动提交 select @@autocommit;# 修改提交方式（自动提交修改为手动提交）set @@autocommit = 0 ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ul><li>ISO定义的四大隔离级别</li></ul><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>读已提交（read-committed）</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><ul><li><p>查询当前的隔离级别：select @@tx_isolation</p></li><li><p>隔离级别1最低，4最高 。隔离级别越高就越安全，同时内存资源消耗也越大。隔离级别越高效率越低下。</p></li><li><p>工作中：1和4都不用，只会在2和3之间切换</p></li><li><p><strong>MySQL</strong>默认的事务隔离级别为3，<strong>Oracle</strong>默认隔离界别默认为2</p></li><li><p>并发下的脏读，不可重复读，幻读的问题</p></li></ul><ol><li><p>脏读问题<br> - 一个事务(A)读取到另一个事务(B)没有提交的数据（破坏了隔离性）.<br> - 例如：事务A开启事务做转账，DML语句执行成功但是没有commit；事务B在另一个窗口开启了，执行Select语句读取tb_account数据，读取到的结果是事务A没有提交的数据。</p></li><li><p>不可重复读问题</p><ul><li>同一个事务中多次读取到的数据不一致(破坏了一致性，update和delete)</li><li>例如：事务A开启事务做转账，DML语句执行成功但是没有commit；；事务B在另一个窗口开启了，执行Select语句读取tb_account数据，读取的结果正确（1000,1000）.</li><li>事务A里面提交了事务。然后事务B再次做Select操作查询结果也正确(500,1500)</li><li>问题：事务B在一次事务中对tb_account表做了两次select操作，两次操作查询的结果不一致。</li></ul></li><li><p>幻读问题</p><ul><li><p>事务A插入一条数据，能够使用select获取结果，此时事务B几乎同时插入了一条或者大量数据，此时事务A看不到事务B的更新（破坏了一致性，insert）。</p></li><li><p>查看事务隔离级别</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># REPEATABLE-READ  可重复读# tx 表示事务的简称  transaction# isolation表示隔离性select @@tx_isolation;# 设置事务的隔离级别 读未提交set session transaction isolation level  READ UNCOMMITTED;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><hr><h2 id="SQL优化之索引"><a href="#SQL优化之索引" class="headerlink" title="SQL优化之索引"></a>SQL优化之索引</h2><h4 id="索引概念"><a href="#索引概念" class="headerlink" title="索引概念"></a>索引概念</h4><ul><li>MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。</li><li>拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。</li><li>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</li><li>创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。</li><li>索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</li><li>建立索引会占用磁盘空间的索引文件。</li></ul><h4 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h4><ul><li><p>普通索引</p><ul><li><p>语法</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">CREATE INDEX 索引名称 on 表名称(列名称);#例如：为person表的pname列建立普通索引CREATE INDEX INDEX_PERSON_PNAME ON PERSON(PNAME);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查看是否使用了索引</p><pre class="line-numbers language-MySQL"><code class="language-MySQL">EXPLAIN select * from person where pname= 'Jack';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>在MySQL中为表创建主键的同时默认也创建了一个索引</p></li><li><p><strong>注意：</strong></p><ul><li><p>在表中如果条件使用的是模糊查询。</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 前后模糊中间精确不会使用索引EXPLAINselect  * from person where pname like '%e%';# 前面模糊后面精确也不会使用索引EXPLAINselect  * from person where pname like '%e';# 只有前面精确后面模糊才会使用索引，工作中数据量大的表模糊查询尽量不要使用 '%%',也不要使用'%a',他们都不支持索引EXPLAINselect  * from person where pname like 'e%';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>总结</p><ol><li><p>如果为某个列创建索引，那么就会在数据文件中创建一个类似TreeMap的文件。如果一个表的数据很多，那么索引会大量的占据数据文件的磁盘空间。</p></li><li><p>不是所有的列都适合建立索引，如果某个列的有效数据很少不要建立索引 。 </p></li><li><p>可以为表的多个列创建复合索引，经常使用的列放在前面。</p></li><li><p>创建主键的同时默认也创建了一个索引。</p></li></ol></li></ul></li><li><p>唯一索引</p><ul><li>唯一索引关键字： unique</li><li>之前学习了唯一约束，当我们创建了一个唯一约束的时候就创建了一个唯一索引，唯一约束就是唯一索引。</li></ul></li><li><p>组合索引</p><p>- </p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 为多个列创建复合索引ALTER TABLE PERSON  DROP  INDEX INDEX_PERSON_AGE_SEX;CREATE INDEX INDEX_PERSON_AGE_SEX ON PERSON(PNAME,PSEX);# 没有创建索执行下面DQL语句引耗时11.427秒，创建索引执行耗时1毫秒SELECT * FROM PERSON WHERE PNAME ="oQlJN" AND PSEX='男';EXPLAIN SELECT * FROM PERSON WHERE  PSEX='男'  AND PNAME ="oQlJN";# 创建的复合索引，但是只对第二个索引列单独进行where条件，不会使用索引# 如果创建复合索引，经常使用的列放在前面，并且查询时一定要带上第一列的条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>全文索引</p><ul><li>概述</li><li>通过数值比较、范围过滤等就可以完成绝大多数我们需要的查询，但是，如果希望通过关键字的匹配来进行查询过滤，那么就需要基于相似度的查询，而不是原来的精确数值比较。全文索引就是为这种场景设计的。</li><li>你可能会说，用 like + % 就可以实现模糊匹配了，为什么还要全文索引？like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。</li><li>你可能没有注意过全文索引，不过至少应该对一种全文索引技术比较熟悉：各种的搜索引擎。虽然搜索引擎的索引对象是超大量的数据，并且通常其背后都不是关系型数据库，不过全文索引的基本原理是一样的。</li></ul></li><li><p>删除索引</p><pre class="line-numbers language-MySQL"><code class="language-MySQL"># 语法ALTER TABLE 表名称 DROP INDEX 索引名称；# 示例ALTER TABLE PERSON DROP INDEX INDEX_PERSON_PNAME;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="数据库设计原则"><a href="#数据库设计原则" class="headerlink" title="数据库设计原则"></a>数据库设计原则</h2><h4 id="引入三大范式"><a href="#引入三大范式" class="headerlink" title="引入三大范式"></a>引入三大范式</h4><ul><li><p>必须保证数据库设计的合理性</p></li><li><p>数据库设计关系整个系统的架构，关系到后续的开发效率和运行效率</p></li><li><p>数据库的设计主要包含了设计表结构和表之间的联系</p></li><li><p>如何是合理数据库</p></li><li><p>结构合理</p></li><li><p>冗余较小</p></li><li><p>尽量避免插入删除修改异常</p></li><li><p>如何才能保证数据库设计水平</p><ul><li>遵循一定的规则</li><li>在关系型数据库中这种规则就称为范式</li></ul></li><li><p>什么是范式（NF&#x3D; NormalForm）</p></li><li><p>范式是符合某一种设计要求的总结。</p></li><li><p>要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p></li><li><p>范式的分类</p><ul><li>第一范式</li><li>第二范式</li><li>第三范式</li><li>各个范式是依次嵌套包含的,范式越高，设计质量越高，在现实设计中也越难实现，一般数据库设计，只要达到第三范式，即可避免异常的出现</li></ul></li></ul><h4 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h4><ul><li>要求<ul><li>最基本的范式</li><li>数据库表每一列都是不可分割的基本数据项，同一列中不能有多个值</li><li>简单说就是要确保每列保持原子性</li><li>第一范式的合理遵循需要根据系统的实际需求来定</li></ul></li></ul><h4 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h4><ul><li>要求<ul><li>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。</li><li>即在一个数据库表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</li></ul></li></ul><h4 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h4><ul><li>要求<ul><li>确保数据表中的每一列数据都和主键直接相关，而不能间接相关</li><li>属性不依赖于其他非主属性。</li></ul></li></ul><h4 id="范式的优缺点"><a href="#范式的优缺点" class="headerlink" title="范式的优缺点"></a>范式的优缺点</h4><ul><li><p>优点</p><ul><li>结构合理</li><li>冗余较小</li><li>尽量避免插入删除修改异常</li></ul></li><li><p>缺点</p><ul><li><p>性能降低</p></li><li><p>多表查询比单表查询速度慢</p></li></ul></li></ul><h4 id="数据库的设计应该根据当前情况和需求做出灵活的处理。"><a href="#数据库的设计应该根据当前情况和需求做出灵活的处理。" class="headerlink" title="数据库的设计应该根据当前情况和需求做出灵活的处理。"></a>数据库的设计应该根据当前情况和需求做出灵活的处理。</h4><ul><li>在实际设计中，要整体遵循范式理论。</li><li>大多时候我们是打破这些范式来设计的。</li><li>如果在某些特定的情况下还死死遵循范式也是不可取的，因为可能降低数据库的效率，此时可以适当增加冗余而提高性能。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/15/hello-world/"/>
      <url>/2022/08/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 世界 ！你好 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE</title>
      <link href="/2022/08/14/javase/"/>
      <url>/2022/08/14/javase/</url>
      
        <content type="html"><![CDATA[<h1><center>javase</center></h1><hr><h2 id="编程语法及规则与规范"><a href="#编程语法及规则与规范" class="headerlink" title="编程语法及规则与规范"></a>编程语法及规则与规范</h2><h4 id="编辑阶段的整体注意点"><a href="#编辑阶段的整体注意点" class="headerlink" title="编辑阶段的整体注意点"></a>编辑阶段的整体注意点</h4><ul><li><p>见名知意、注意缩进、成对编程；</p></li><li><p>严格区分大小写，英文大写字母与小写字母意义不一样；</p></li><li><p>都是英文标点符号；</p><p>–&gt; 经典错误：”非法字符”：’\uff09’ –&gt; 使用了中文的标点符号；</p></li><li><p>main方法写法固定，是程序的入口，能被虚拟机识别并执行。</p></li></ul><h4 id="关于定义类的注意点？"><a href="#关于定义类的注意点？" class="headerlink" title="关于定义类的注意点？"></a>关于定义类的注意点？</h4><ul><li><p>使用public修饰的类，该类的名字必须和源文件名字保持一致，否则就会编译错误；</p></li><li><p>在源文件中，我们可以使用class来定义任意多个类，编译后就会生成任意多个字节码文件。</p><p>–&gt; 编译后，没有类都会生成一个字节码文件，并且字节码文件名字就是类名。</p></li><li><p>在源文件中，我们可以定义多个类，但是最多只能有一个类使用public修饰（0或1）。</p></li></ul><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ol><li>单行注释<ul><li>快捷键：ctrl + &#x2F;</li><li>语法：&#x2F;&#x2F;</li></ul></li><li>多行注释<ul><li>快捷键：ctrl + shift + &#x2F;</li><li>语法：&#x2F;* 注释内容 *&#x2F;</li></ul></li><li>文档注释<ul><li>语法：&#x2F;** 注释内容 *&#x2F;</li></ul></li></ol><h4 id="常见的转义字符"><a href="#常见的转义字符" class="headerlink" title="常见的转义字符"></a>常见的转义字符</h4><ul><li>\t –&gt; 制表符。作用：显示多个空格，并且还有对齐的功能；</li><li>\n –&gt; 换行符。作用：具有换行功能。</li><li>\“，编译时，把它当成一个整体，不作为字符串结束的标记；运行时，会忽略反斜杠，只会展示出一个双引号。</li><li>\‘，编译时会把它当成一个整体，运行时只会展示出一个单引号。</li></ul><h4 id="关于字符的使用"><a href="#关于字符的使用" class="headerlink" title="关于字符的使用"></a>关于字符的使用</h4><ol><li><p>方式一：把字符放在字符串内部使用！</p><ul><li>System.out.println(“hello\tworld”);</li></ul></li><li><p>方式二：把字符串单独使用，然后再使用+来拼接。</p><ul><li>System.out.println(“hello” + ‘\t’ + “world”);</li></ul><p><strong>注意：</strong></p><ul><li>int类型和char类型做“+”运算，则做的是“加法操作”。</li><li>String类型和char类型做“+”运算，则做的是“连接符操作”。</li></ul></li><li><p>关于Unicode值得补充</p><ul><li>因为java语言默认采用Unicode编码表，因此每个”字符”都对应一个Unicode值，其中一个Unicode值我们必须掌握</li><li>‘\u0000’代表的是空格字符</li></ul></li></ol><h4 id="理解编译和反编译"><a href="#理解编译和反编译" class="headerlink" title="理解编译和反编译"></a>理解编译和反编译</h4><p>编译：把源文件编译为字节码文件，也就是把”*.java”文件编译为”.class”文件</p><p>反编译：把字节码文件编译为源文件。</p><p><strong>反编译的实现方式：</strong></p><p><strong>方式一：提供javap.exe来实现</strong></p><ul><li>实现：在字节码文件所在目录中，我们通过javap.exe来实现反编译，例如:javap HelloWorld04</li><li>优点：能看到编译时期默认做的操作，例如<strong>能看到编译时期默认提供的无参构造方法</strong>。</li><li>缺点：反编译之后，我们无法看到方法内部的具体实现，也就是看不到方法体。</li></ul><p><strong>方法二：通过jd-gui.exe来实现</strong></p><ul><li>实现：打开jd-gui.exe程序，然后把需要反编译的字节码文件拖拽进入jd-gui.exe程序中即可。</li><li>优点：反编译之后，<strong>我们能够看到方法内部的具体实现，也就是能看到方法体。</strong></li><li>缺点：不能看到编译时期默认做的操作，例如无法看到编译时期默认提供的无参构造方法。</li></ul><p><strong>方法一与方法二可以看作是互补的。</strong></p><h4 id="文件存储的的单位"><a href="#文件存储的的单位" class="headerlink" title="文件存储的的单位"></a>文件存储的的单位</h4><p>实际开发中，我们把字节称之为文件存储的最小单位。</p><p>开发中，<strong>字节有两种表示方式</strong>，分别为：</p><ol><li><p>无符号表示</p><p>（只能表示正数，不能表示负数）</p><ul><li>1个字节无符号表示的数值范围在【0,2^8-1】之间，也就是表示范围在【0,255】之间。</li><li>作用：基本数据类型中，char类型采用的就是无符号来表示。</li></ul></li><li><p>有符号表示</p><p>（不但能表示正数，还能表示负数）</p><ul><li>1个字节有符号表示的数值范围在[-2^ 7,2^7-1]之间，也就是表示范围在[-128,127]之间。</li><li>作用：基本数据类型中，byte、short、int和long类型采用的就是有符号来表示。</li></ul></li><li><p>常见的文件存储单位及其换算公式</p><ul><li>1KB &#x3D; 1024Byte</li><li>1MB &#x3D; 1024KB</li><li>1GB &#x3D; 1024MB</li></ul></li><li><p>问题</p><p>：长度单位的换算使用的是1000，为什么文件存储单位换算使用的是1024呢？</p><ul><li>答：二进制早期有电信号开关演变而来，也就是意味着文件存储的换算肯定使用的是2的多少次方，而2的10次方结果就是1024，也就是2^10是最接近于1000的整数，因此就使用了1024来作为文件存储的换算值。</li></ul></li></ol><h4 id="标识符的作用"><a href="#标识符的作用" class="headerlink" title="标识符的作用"></a>标识符的作用</h4><ul><li>标识符就是给类名、方法名、变量名、常量名和包名命名的规则。</li></ul><h4 id="标识符的规则"><a href="#标识符的规则" class="headerlink" title="标识符的规则"></a>标识符的规则</h4><ol><li>必须由数字、字母、下划线和&amp;组成，并且开头不能是数字。</li><li>标识符不能是关键字或保留字，因为关键字和保留字是给编程语言使用。</li><li>在java语言中，对于标识符的长度没有任何限制，也就是标识符可以任意长。<ul><li>补充：java语言默认采用Unicode编码表，而Unicode编码表几乎包含了全世界所有的文字。</li><li>注意：此处的“字母”我们应该广义地去理解，也就是此处“字母”可以是“英文”，也可以是“中文”。</li><li>建议：给标识符进行命名的时候，我们不建议使用“中文汉字”来进行命名。</li></ul></li></ol><h4 id="命名规范的讲解"><a href="#命名规范的讲解" class="headerlink" title="命名规范的讲解"></a>命名规范的讲解</h4><p>明确：命名的时候不建议使用”中文汉字“，并且还必须做到“见名知意”的要求。</p><p>类名：必须遵守“大驼峰”的命名规范，大驼峰：每个单词首字母都大写。</p><ul><li>例如：HelloWorld、VariableDemo</li></ul><p>方法名、变量名：必须遵守“小驼峰”的命名规则，小驼峰：第一个单词首字符小写，从第二个单词起首字母都大写。</p><ul><li>例如：userName、maxValue</li></ul><p>常量名：必须遵守“字母全部大写，多个单词之间以下划线连接”的命名规范。</p><ul><li>例如：USER、NAME</li></ul><p>包名：必须遵守“单词全部小写，多个单词之间以 ‘.’ 连接，并且必须做到顶级域名倒着写”的命名规范。</p><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h4 id="数据类型的分类"><a href="#数据类型的分类" class="headerlink" title="数据类型的分类"></a>数据类型的分类</h4><ol><li><p><strong>基本数据类型【八大基本数据类型】</strong></p><ul><li><p>整数型：byte、short、int、long</p></li><li><p>浮点数：float、double</p></li><li><p>布尔型：boolean</p></li><li><p>字符型：char</p></li></ul></li><li><p><strong>引用数据类型</strong></p><ul><li>数组、字符串、类和接口等等</li></ul></li><li><p><strong>整数型（有符号表示）</strong></p><ul><li><p>byte，占用1个字节，则表示范围在[-2^7, 2^7-1]之间，–&gt; [-128, 127]。</p></li><li><p>short, 占用2个字节，[-2^15, 2^15-1], –&gt; [-32768,32767]。</p></li><li><p>int, 占用4个字节，[-2^31, 2^31-1], –&gt; 大概在正负21亿之间。</p></li><li><p>long, 占用8个字节，[-2^63, 2^63]。</p></li><li><p><strong>注意：</strong></p><ul><li><p>占用的字节数越大，则表示的数值范围也就越大，开发中我们需要根据存储数值的大小来选择合适的数据类型。</p><p>–&gt; 存储的数值大小不能超出其数据类型的表示范围，否则就会编译错误。</p><p>–&gt; 实际开发中，byte和short几乎不会使用。存储较小的数值使用int，存储较大的数值使用long。</p></li><li><p>开发中，只能使用八进制、十进制、十六进制来表示整数，不能“直接”使用二进制来表示整数。</p><ol><li>int num1 &#x3D; 017：八进制；</li><li>int num1 &#x3D; 23：十进制；</li><li>int num1 &#x3D; 0x2B：十六进制；</li></ol></li><li><p>整数固定值常量默认为int类型,在整数固定值常量的末尾添加”L”【推荐】或”l”，则该常量就变为Long类型。</p></li></ul></li></ul></li><li><p><strong>浮点型（小数）</strong></p><ul><li>float，占用4个字节，我们称之为“单精度类型”，理论上能精确到小数点后7位。</li><li>double，占用8个字节，我们称之为“双精度类型”，理论上精确度是float的两倍。</li></ul><p><strong>注意：</strong></p><ul><li><p>占用的字节数越大，则表示小数的精确度就越高，开发中我们建议使用double类型。</p><p>–&gt; 开发中，float类型很少使用，因为精确度太低，而double类型很常用。</p></li><li><p>小数的表示方式有：1）生活中的表示小数；2）使用科学计数法来表示小数。</p><p>–&gt; 3.14E3，等效于：3140.0 –&gt; “乘以10的3次方”</p><p>–&gt; 3.14E-3，等效于：0.00314 –&gt; “除以10的3次方”</p></li><li><p>注意：使用科学计数法来表示小数的时候，此处的英文字母不区分大小写（E或e）。</p></li><li><p>因为小数存储的区别，因此不建议使用小数来做特别精确的运算，因为得到结果可能不精确。</p><p>–&gt; double sum &#x3D; 0.001 + 0.0002; 理论结果是：0.0003 实际结果：0.000300000000000000000003</p></li><li><p>小数固定值常量默认为double类型，在小数固定值常量末尾添加”F”【推荐】或”f”，则该常量就变为：float类型。</p></li><li><p>浮点型占用的字节数，强调的是存储”小数部分”占用的字节数，并不是强调存储”整数部分”占用的字节数。</p><p> <strong>–&gt; float类型存储”整数部分占用8个字节”，存储”小数部分占用4个字节”，总计至少占用12个字节。</strong>【底层（科学计数法）】</p></li></ul></li><li><p><strong>布尔型(boolean)</strong></p><ul><li><p>明确：布尔类型的固定值常量只有true和false，并且true和false都是关键字。</p><p>–&gt; true：表示为真或条件成立</p><p>–&gt; flase：表示为假或条件不成立</p></li><li><p>使用场合：常用于条件判断，条件成立则返回true，条件不成立则返回false。</p></li><li><p><strong>面试题：请问boolean类型占用几个字节？</strong></p><p>–&gt; 在java规范中，没有明确boolean类型占用几个字节。我个人觉得boolean类型占用x个字节，并说出理由！</p></li></ul></li><li><p><strong>字符型(char，无符号表示)</strong></p><ul><li>明确：字符型占用2个字节数，表示的数值范围在[0,2^16-1]之间，也就是表示范围在[0,65535]之间。</li><li>注意：使用单引号包裹的一个字符串，我们就称之为字符固定值常量。</li></ul></li><li><p><strong>字符串类型？</strong></p><ul><li><p>明确：字符串类型的名字叫做String类型，并且String类型属于”引用数据类型”。</p></li><li><p>注意：使用双引号包裹的任意多个字符，我们就称为“字符串固定值常量”。</p><p>–&gt; 双引号包裹的0个字符，我们就称之为”空字符串”。</p></li></ul></li><li><p><strong>关于”+”的作用</strong></p><ul><li>表示正数。eg:int num &#x3D; +8;</li><li>加法运算，要求两个操作数都必须是数值型。eg:int sum &#x3D; 5 + 8;</li><li>连接符，要求其中一个操作数必须是字符串类型。eg:”hello” + true;</li><li>结论：字符串的连接符操作，则运算完毕后返回的结果肯定属于String类型。</li></ul></li></ol><h4 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h4><ol><li><p>为什么需要学习数据类型的转换?</p><ul><li>因为java是强类型的语言，因此参与“赋值运算”和“算数运算”的时候，要求参与运算的数据类型必须保持一致，否则就需要做数据类型转换。</li></ul></li><li><p>基本数据类型转换的方式有哪些？</p><ul><li>隐式类型转换（自动）</li><li>强制类型转换（手动）</li></ul></li><li><p>哪些基本数据类型可以相互转换？</p><ul><li>除了boolean类型外，其余的基本数据类型都可以相互转换。</li></ul></li><li><p>隐式类型转换（自动）</p><ul><li>原则：低字节向高字节自动提升。</li><li>byte –&gt; short –&gt; int –&gt; long –&gt; float –&gt; double</li><li>char –&gt; int</li></ul><p>赋值运算：</p><ul><li><p>原则：低字节向高字节自动提升。</p></li><li><p>特例：把int类型的常量，赋值给byte、short和char类型的变量或final修饰的常量时，则就是属于隐式类型转换的特例。只需赋值的数据没有超出其数据类型的表示范围即可。</p><p>–&gt; 赋值的数据应该是什么？赋值的数据应该是int类型的常量！</p><p>–&gt; 赋值数据的大小是什么？赋值数据的大小不能超出其数据类型的表示范围。</p></li></ul><p>算术运算</p><p> 原则：两个操作数做运算，如果其中一个操作数为double类型，则另外一个操作数也会隐式转化为double类型；<strong>否则</strong>，如果其中一个操作数为float类型，则另外一个操作数也会隐式转化为float类型，最终计算结果就是float类型；<strong>否则</strong>，如果其中一个操作数为long类型，则另外一个操作数也会隐式转化为long类型，最终计算结果就是long类型;<strong>否则</strong>，这两个操作数都会隐式转化为int类型，最终计算的结果就是int类型。</p></li></ol><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul><li><p>当隐式类型转换无法解决问题时，我们要采用强制类型转换。</p></li><li><p>语法：目标类型 变量 &#x3D; （目标类型） 数据；</p><p>eg: int num &#x3D; (int) 3.14; –&gt; 可以用来小数取整。【<strong>一、想要的精度丢失</strong>】</p></li><li><p><strong>底层：只保留低位字节的二进制，高位字节的二进制就丢弃。</strong></p></li><li><p>注意：使用强制类型转换的时候，可能就丢失精度，使用的时候切记。【<strong>二、不想要的精度丢失</strong>】</p><p>–&gt; int num &#x3D; (int) 3.14; 只保留了整数位，丢失了小数位。</p></li><li><p><strong>强制类型转换后，被强制转换的变量还是原来的数据类型。</strong></p><p>eg: int num; byte num1 &#x3D; (int) num; –&gt; num (int类型)</p></li><li><p>使用强制类型转换的时候，我们必须明确强制转换数据的范围，否则得到的结果就不准确。</p></li></ul><hr><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><ul><li>“&#x3D;”，作用：把等号右边表达式的结果赋值给等号左边的变量或final修饰的常量保存。</li></ul><h4 id="算法运算符的分类"><a href="#算法运算符的分类" class="headerlink" title="算法运算符的分类"></a>算法运算符的分类</h4><ol><li><p>一元运算符（只需要一个操作数参与运算）</p><p>包含：++、–</p></li><li><p>二元运算符（需要两个操作数来参与运算）</p><ul><li><p>包含：+ 、-、*、&#x2F;、%</p></li><li><p>+：表示正数，加法运算，连接符操作；</p></li><li><p>-：表示负数，减法运算；</p></li><li><p>*：乘法运算</p></li><li><p>&#x2F;：除法运算</p></li><li><p>%：取模运算或取余运算</p><p>–&gt; 作用：获得两个整数相除的余数</p><p>eg：0 % 3 &#x3D; 0 –&gt; <strong>注意：0能被任何数整除。</strong></p><p> 1 % 3 &#x3D; 1</p><p>注意：”除法运算”是获得两个整数相除的”整数位结果”，”取模运算”是获得两个整数相除的”余数”。</p><p>使用场合：</p><ul><li><p>判断m能否被n整除，如果m%n的结果为0，则意味着m能被n整除；如果m%n的结果不为0，则意味着m不能被n整除。</p></li><li><p>“任意数 % m”，则得到的结果肯定在[0,m - 1]之间，例如：”任何数 % 3”，则得到的结果肯定是在[0, 2]之间。</p></li></ul></li></ul></li></ol><h4 id="除法运算符的注意事项"><a href="#除法运算符的注意事项" class="headerlink" title="除法运算符的注意事项"></a>除法运算符的注意事项</h4><ul><li>在java语言中，两个整数做除法运算，则得到的结果肯定为整数。</li><li>在java语言中，做除法运算的时候，分母不能为0，否则就会抛出算数异常（ArithmeticException）。</li></ul><h4 id="比较运算的概述"><a href="#比较运算的概述" class="headerlink" title="比较运算的概述"></a>比较运算的概述</h4><ul><li><p>明确：比较运算符返回的结果肯定是boolean类型。</p></li><li><p>如果条件成立，则返回true；如果条件不成立，则返回false。</p></li><li><p>包含：&gt; 、&gt;&#x3D;、&lt;&#x3D;、&#x3D;&#x3D;、!&#x3D;</p></li><li><p>&#x3D;&#x3D;（等于），判断左右两边的结果是否相等。</p><p>–&gt; 如果左右两边属于“基本数据类型”，则比较左右两边的“数据值”是否相等（掌握）。</p><p>–&gt; 如果左右两边属于“引用数据类型”，则比较左右两边的“地址值”是否相等（了解）。</p></li><li><p>!&#x3D;（不等于），判断左右两边的结果是否不相等。</p><p>–&gt; 如果左右两边属于“基本数据类型”，则比较左右两边的“数据值”是否不想等（掌握）。</p><p>–&gt; 如果左右两边属于“引用数据类型”，则比较左右两边的“地址值”是否不相等（了解）。</p></li><li><p>注意点：</p><ol><li>比较运算符是一个整体，中间不允许条件空格！</li><li>注意区分“&#x3D;”和“”的区别，“&#x3D;”属于赋值运算符，“”属于比较运算符。</li></ol></li></ul><h4 id="逻辑运算符的概述"><a href="#逻辑运算符的概述" class="headerlink" title="逻辑运算符的概述"></a>逻辑运算符的概述</h4><ul><li><p>明确：参与逻辑运算的数据必须是boolean类型，并且逻辑运算符返回的结果肯定是boolean类型。</p></li><li><p>包含：&amp;、|、^、&amp;&amp;、||、!</p></li><li><p>&amp;（与运算符），属于二元运算符</p><p>–&gt; 结论：只要两边都为true，则结果就是true。</p><p> 只要有一边为false，则结果就是false。</p><p><strong>辅助记忆</strong>：小明“与”小红来一趟办公室。</p></li><li><p>|（或运算符），属于二元运算符</p><p>–&gt; 结论：只要两边都为false，则结果就是false。</p><p> 只要有一边为true，则结果就是true。</p><p>辅助记忆：小明“或”小红来一趟办公室。</p></li><li><p>^：异或运算，相同为false，不同为true。</p><p>———————–以上三个开发中不常用，但是结论很重要———————-</p><p>———————–以下三个开发中常用，并且结论也很重要———————-</p></li><li><p>&amp;&amp;（短路与），属于二元运算符</p><ol><li><p>结论1：&amp;和&amp;&amp;的执行结果一样。</p></li><li><p>结论2：&amp;&amp;当左侧表达式为false时，右边不执行，结果直接原样返回左侧结果为false。</p><p> &amp;&amp;当左侧表达式为true时，右边执行，结果直接原样返回右侧结果。</p></li></ol><p>||（短路或），属于二元运算符</p><ol><li><p>结论1：|和||的执行结果一模一样；</p></li><li><p>结论2：如果左侧表达式的结果为true，则右边表达式肯定不会执行，并且原样返回左侧表达式的结果(true)。</p><p> 如果左侧表达式的结果为false，则右侧表达式肯定会去执行，并且原样返回右侧表达式的结果(true|false)。</p></li></ol><p>!（非运算），属于一元运算符。</p><p><strong>使用场合：</strong></p><ul><li>如果<strong>两个条件必须成立才能满足需求</strong>，则这两个条件之间使用“&amp;&amp;”来组织关系；</li><li>如果<strong>两个条件其中一个成立既能满足需求</strong>，则这两个条件之间使用”||”来组织关系。</li></ul></li></ul><h4 id="位运算（了解，建议掌握）"><a href="#位运算（了解，建议掌握）" class="headerlink" title="位运算（了解，建议掌握）"></a>位运算（了解，建议掌握）</h4><ul><li><p>明确：参与位运算的数据应该是整数型，并且位运算返回的结果也是整数。</p></li><li><p>包含：&amp;、|、^、~、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</p></li><li><p>&amp;（与位运算），属于二元运算符</p><p>结论：位都为1，则结果就是1；位有一个为0，则结果就是0</p><p>使用场合：学习HashMap集合的时候，验证为啥底层的数组空间长度必须为2的整数次幂。</p></li><li><p>|（或为运算），属于二元运算符</p><p>结论：位都为0，则结果就是0；位有一个为1，则结果就是1</p></li><li><p>^（异或位运算），属于二元运算符</p><p>结论：位相同，则为0；位不同，则为1</p><p>特点：对m连续异或n两次，得到的结果依旧为m</p><p> –&gt; m^n ^ n 的结果为m，n^m ^n的结果为m，n ^ n ^ m的结果为m</p></li></ul><p>使用场合：</p><ol><li>使用异或位运算，我们可以实现对数据的”加密”和”解密”操作。<ul><li>加密：对需要加密的数据异或m，则就得到了加密后的结果。</li><li>解密：对加密后的数据继续异或m，则就得到了解密后的结果。</li></ul></li><li>使用异或位运算，用于交换两个变量的值。<ul><li>优点：效率非常高；</li><li>缺点：复杂、不好理解。</li></ul></li></ol><p>~（非位运算符），属于一元运算符</p><p>结论：二进制位取反的含义。0取反的结果就是1，1取反的结果就是0。</p><p>&lt;&lt; （左移位运算）</p><ul><li><p>结论：对m左移n位，则等效于：m * 2n</p><p>–&gt; 此处m可以是正数，也可以是负数！</p><p>特点：左移运算之后，则低位永远补0即可。</p><p>使用场合：对m做乘以2的操作，则最高效的方式为：m &lt;&lt; 1</p><p>(&gt;&gt;右移位运算)</p><ul><li><p>结论：对m右移n位，则等效于：m&#x2F;2n</p><p>–&gt; 此处m必须是正数，不能为负数！</p><p>特点：正数右移，则高位补0；负数右移，则高位补1</p><p>使用场合：对m做除以2的操作，则最高效的方式为：m&gt;&gt;1</p><p>–&gt; 此处m必须有正好，不能为负数！</p></li></ul><p>(&gt;&gt;&gt;无符号右移)</p><ul><li>无论对正数还是负数做无符号右移的操作，则高位永远补0即可。</li></ul></li></ul><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><ul><li><p>语法：数据类型 变量名 &#x3D; 条件表达式？表达式1 : 表达式2；</p></li><li><p>执行：如果”条件表达式”的结果为true，则执行”表达式1“，也就是”把表达式1*的结果赋值给等号左边的变量来保存。</p><p> 如果”条件表达式“的结果flase，则执行“表达式2”，也就是把“表达式2”的结果赋值给等号左边的变量来保存。</p></li><li><p>注意：if…else选择结构在某些情况下可以被三目运算符代替，毕竟这两者都是做的“二选一”的操作。</p></li></ul><hr><h2 id="循环选择结构"><a href="#循环选择结构" class="headerlink" title="循环选择结构"></a>循环选择结构</h2><h4 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h4><ul><li>代码自上而下，依次执行。</li></ul><h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h4><ul><li><p><strong>if选择结构</strong></p><ol><li>if单选结构<ul><li>概述：if(条件表达式){ &#x2F;&#x2F;当“条件表达式”的结果为true，则执行此处的代码。}</li><li>注意：<ol><li>此处的“条件表达式”返回的结果必须时Boolean型。</li><li>if选择结构依旧包含在顺序执行中，也就是顺序执行中包含了选择执行。</li></ol></li></ul></li><li>if双选结构</li><li>if多选结构<ul><li>在完整的if多选结构中，有且只能执行一个大括号中的代码（多选一）。</li><li>if，最前面，有且只能有一个（1）</li><li>else if，中间位置，可以有任意多个（0，1，2，…，n）</li><li>else，最后面，最多只能有一个（0或1）</li></ul></li><li>if选择结构的总结<ol><li>如果if选择结构中只有一行代码，则我们还可以省略大括号！省略大括号之后，则编译时会默认添加一个大括号，用于包裹if结构中的第一行代码。</li><li>建议：对于初学者而言，不建议省略if选择结构中的大括号，省略大括号之后可能会带来额外的问题。</li></ol></li></ol></li><li><p><strong>switch选择结构</strong></p><ul><li><p>关于switch关键字的注意点：</p><ul><li>此处“表达式”的结果必须是byte、short、int、char、String和枚举(后面学习)类型 ，别的类型都会编译错误！</li><li>“表达式”的结果不能是boolean类型，因此switch选择结构就不能对布尔类型的数据进行匹配！</li></ul></li><li><p>关于case关键字</p><ul><li><p>case关键字后面必须是“常量”,不能为“变量”，从而保证匹配的安全性！</p></li><li><p>在switch选择结构中，case后面不允许有多个“相同的”常量值，否则就会编译错误！</p></li><li><p>在此处“表达式”结果的类型和case后面“常量值”的类型必须保持一致，否则就会编译错误！</p><p>–&gt; 此处的数据类型必须“保持一致”，包含了“隐式类型转换”之后能保持一致。</p><p>–&gt; 因为“表达式”结果不支持boolean类型，因此case后面就不能为boolean类型的数据，也就是不支持区间判断。</p></li></ul></li><li><p>关于break关键字的注意点：</p><ul><li><p>一旦执行break关键字，则就会跳出switch选择结构，执行switch选择结构之后代码。</p></li><li><p>在switch选择结构中，我们可以省略break关键字，省略break关键字之后，则就会发生“穿透”，直到遇到下一个break才会结束“穿透”。</p></li></ul></li><li><p>关于default关键字的注意点：</p><ul><li>当switch选择结构中的所有case都无法匹配成功，则那么才会去执行default中的代码，此处的default类似于if选择结构中的else代码块。</li><li>在switch选择结构中，虽然可以省略default关键字，但是我们不建议省略，除非case都匹配所有的问题。</li></ul></li><li><p>强调：在某个case中定义的变量，则该变量就只能在当前作用域中使用，不能在别的case中使用！</p></li></ul></li></ul><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><ul><li><strong>for循环</strong><ul><li>for循环结构，我们也称为“带名字的代码块”或“带条件的代码块”，因此在“循环体”中定义的变量不能再循环之外使用。</li><li>在循环体定义的变量，每次执行循环体该变量都“出生”，每次循环体执行完毕该变量都“死亡”。</li><li>问题：想要在循环体中，每次操作的都是同一个变量，则该变量应该定义在哪里？–&gt; 必须定义在循环之前！</li><li>“循环条件表达式”返回的结果必须是boolean类型，但是“循环初始化表达式”和“循环后的操作表达式”没有特殊要求</li></ul></li><li><strong>while循环</strong><ul><li>while循环结构：先进行判断，若返回值为true则进行循环，反之则跳过循环</li></ul></li><li><strong>do…while循环</strong><ul><li>do…while循环：先将方法体执行一遍，然后进行判断，若返回值为true则进入循环，反之则跳过循环</li></ul></li></ul><hr><h2 id="方法的调用及内存分析"><a href="#方法的调用及内存分析" class="headerlink" title="方法的调用及内存分析"></a>方法的调用及内存分析</h2><h4 id="调用方法的内存分析（重点）"><a href="#调用方法的内存分析（重点）" class="headerlink" title="调用方法的内存分析（重点）"></a>调用方法的内存分析（重点）</h4><ol><li>栈内存的特点？<ul><li>栈内存具备“先进后出，后进先出”的特点，类似于生活中的“子弹夹”。</li></ul></li><li>调用方法的内存分析？<ul><li>调用方法的时候，则自动就会在栈内中开辟一个“栈帧”，用于执行该方法体中的代码。–&gt;入栈操作</li></ul></li><li>方法调用完毕的内存分析<ul><li>在方法体中一旦执行“return”关键字，则就证明方法调用完毕，那么调用方法时所开辟的“栈帧”就会被摧毁。–&gt; 弹栈操作</li></ul></li><li>问题：调用方法的时候，实参num1和num2与形参num1和num2是否有关系？<ul><li>答案：此处的“实参”和”形参”没有任何关系，仅仅是”名字”相同而已。</li></ul></li></ol><h4 id="方法的使用（重点）"><a href="#方法的使用（重点）" class="headerlink" title="方法的使用（重点）"></a>方法的使用（重点）</h4><ol><li><p>方法的使用原则</p><ul><li>先声明，后调用。</li></ul></li><li><p>方法声明的难点</p><ol><li>明确1：完成该功能，是否需要返回值。–&gt; 返回值类型</li><li>明确2：完成该功能，是否需要外部参数参与方法内部的运算。 –&gt; 形参列表</li></ol></li><li><p><strong>方法的分类</strong></p><ol><li><p>无参无返回值方法</p><ul><li><p>需求：在方法中输出“hello world”。</p></li><li><p>分析：完成该功能，无需返回值，因此返回值类型为void。</p><p> 完成该功能，无需外部参数参与方法内部运算，因此没有形参。</p></li></ul></li><li><p>无参有返回值方法</p><ul><li><p>需求：调用方法获得常量3+4的和。</p></li><li><p>分析：完成该功能，需要返回值，因此返回值类型为int。</p><p> 完成该功能，无需外部参数参与方法内部的运算，因此没有参数</p></li></ul></li><li><p>有参无返回值方法</p><ul><li><p>需求：在方法中输出指定两个int数据之和。</p></li><li><p>分析：完成该功能，无需返回值，因此返回值类型为void。</p><p> 完成该功能，需要外部参数参与内部的运算，也就是需要两个int类型的形参。</p></li></ul></li><li><p>有参有返回值方法</p><ul><li><p>需求：调用方法获得指定两个double数据之和。</p></li><li><p>分析：完成该功能，需要返回值，因此返回值类型为double。</p><p> 完成该功能，需要外部参数参与方法内部的运算，也就是需要两个double类型的形参。</p></li></ul></li></ol></li></ol><h4 id="方法的重载（overload）重点"><a href="#方法的重载（overload）重点" class="headerlink" title="方法的重载（overload）重点"></a>方法的重载（overload）重点</h4><ol><li><p>方法重载的定义</p><ul><li><p>同一个类中，具有相同的方法名，但是参数个数不同或参数类型不同，这就构成了方法的重载！</p></li><li><p>核心：两同，两不同</p><p>–&gt; 两同：同一个类中，具有同名的方法。</p><p>–&gt;两不同：参数个数不同，参数个数不同 或 参数类型不同。</p></li></ul></li><li><p>方法重载的特点</p><ul><li>修饰符不同，没有构成方法重载；</li><li>形参名字不同，没有构成方法重载；</li><li>返回值类型不同，没有构成方法重载。</li></ul></li><li><p>方法重载的好处</p><ul><li>官方：方法重载的出现，使其同一个类中允许定义多个同名的方法，从而避免了方法名被污染。</li><li>通俗：学习方法重载之后，如果同一个类中多个同名的方法发生了编译错误，则首先考虑这些方法是否满足方法重载!</li></ul></li><li><p>重载方法的调用</p><ul><li>调用重载方法的时候，会根据实参的“个数”和“类型”来选择调用合适的方法。</li></ul></li><li><p>目前已经用过的重载方法有哪些？</p><ul><li>print()、println()等等</li><li>问题：通过IDEA工具，如何查看底层的API源码？</li><li>实现：按下Ctrl键，然后鼠标左键单击即可。</li></ul></li></ol><h4 id="调用方法时，实参传递给形参的过程-超级重点"><a href="#调用方法时，实参传递给形参的过程-超级重点" class="headerlink" title="调用方法时，实参传递给形参的过程(超级重点)"></a>调用方法时，实参传递给形参的过程(超级重点)</h4><ol><li><strong>调用方法时，基本数据类型的传递</strong><ul><li>结论：”基本数据类型”的传递，属于”数据值”的传递。</li><li>解释：”实参”赋值给”形参”之后，则”实参”和”形参”就没有任何联系了，我们在方法中修改”形参”的值，则”实参”的值不会改变。</li></ul></li><li><strong>调用方法时，引用数据类型的传递</strong><ul><li><strong>结论：”引用数据类型”的传递，属于”地址值”的传递。</strong></li><li>解释：”实参”赋值给”形参”之后，则”实参”和”形参”保存的地址值就相同，也就意味着”实参”和”形参”指向了同一块存储空间，<strong>我们在方法中修改”形参”指向存储空间的数据，则”实参”指向该存储空间的数据也被修改了。</strong></li></ul></li></ol><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h4><ul><li>数组就是一个存储“相同数据类型”的“有序”集合（容器）。</li><li>明确：所谓数组的声明，指的就是给数组取一个名字，类似于变量的声明。</li><li>语法1：数据类型[] 数组名;</li><li>语法2：数据类型 数组名[];</li><li>注意：开发中，建议使用“语法1”来声明数组，因为“数据类型[]”代表的是“数组类型”。</li></ul><h4 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h4><ol><li><p>明确：所谓数组的创建，指的就是在内存中为数组开辟存储空间。</p></li><li><p>方式一：动态创建数组（仅仅在内存中开辟存储空间，但没有给数组元素指定赋值）</p><ul><li>语法：数据类型[] 数组名 &#x3D; new 数据类型[空间长度];</li></ul></li><li><p>方式二：静态创建数组（不但在内存中开辟存储空间，并且还给数组元素指定赋值）</p><ul><li><p>语法1：数据类型[] 数组名 &#x3D; {数据1,数据2,数据3,…};</p></li><li><p>语法2：数据类型[] 数组名 &#x3D; new 数据类型[]{数据1,数据2,数据3,…};</p></li></ul></li></ol><h4 id="操作数组元素"><a href="#操作数组元素" class="headerlink" title="操作数组元素"></a>操作数组元素</h4><ul><li><p>明确：想要操作数组元素，则必须通过“索引”来实现，因为通过“索引”就能找到元素对应的存储空间，然后就能做出“赋值”和“取值”的操作。</p></li><li><p><strong>数组的注意点</strong></p><ul><li><p>数组存储的是相同数据类型的元素，则意味着每个元素占用的字节数相同。</p></li><li><p>数组是一块连续的存储空间，则意味着相邻两个元素的存储空间是紧挨着的。</p></li><li><p>创建数组的时候，我们必须明确数组的空间长度，并且数组一旦创建成功，则数组的空间长度就不能改变了。</p></li><li><p>给数组元素赋值的时候，赋值“元素的类型”必须和“声明数组的数据类型”保持一致，否则就会编译错误！</p><pre class="line-numbers language-Java"><code class="language-Java">int[] arr = new int[5];arr[0] = 11;  //没问题arr[1] = "abc";  //编译错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>声明数组的时候，我们可以使用“基本数据类型”来声明数组，也可以使用“引用数据类型”来声明数组。</p><pre class="line-numbers language-Java"><code class="language-Java">int[] arr1；    //基本数据类型String[] arr2;   //引用数据类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>通过索引来操作数组元素的时候，操作的索引值必须合法，如果索引值不合法就会抛出数组索引越界异常。</p><p>明确：数组索引的合法取值范围在[0,数组长度-1]之间，如果索引越界就会抛出数组索引越界异常（ArrayIndexOutOfBoundsException）。</p></li></ul></li></ul><h4 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h4><ul><li>明确：基本数据类型没有属性和方法，但是引用数据类型有属性和方法。</li><li>强调：通过数组的“length”属性，我们可以动态的获得数组的空间长度。</li></ul><h4 id="数组元素的默认值"><a href="#数组元素的默认值" class="headerlink" title="数组元素的默认值"></a>数组元素的默认值</h4><p>明确：通过“动态创建数组”的方式，则数组中每个元素都有默认值，并且元素的默认值规则如下：</p><ul><li>整数型（byte、short、int和long）数组元素的默认值为：0</li><li>浮点型（float和double）数组元素的默认值为：0.0</li><li>布尔型（boolean）数组元素的默认值为：false</li><li>字符型（char）数组元素默认值为：’\u0000’ –&gt; 代表空格字符</li><li>引用数据类型（数组、字符串、类和接口）数组元素的默认值为：Null –&gt; 此处是null关键字，代表的是空对象。</li></ul><h4 id="数组元素的遍历"><a href="#数组元素的遍历" class="headerlink" title="数组元素的遍历"></a>数组元素的遍历</h4><ol><li><p>使用普通for循环来实现</p><ul><li>思路：通过普通for循环，获得[0, 数组长度-1]的合法索引取值，然后再通过索引获得数组元素</li><li>优势：遍历的过程中，可以获得数组的合法索引值，因此遍历过程中我们可以操作数组中的元素。</li><li>劣势：语法复杂，效率较低。</li><li>使用场合：遍历数组的过程中，如果想要获得数组的合法索引取值，或者想要在遍历过程中操作数组元素，则“必须”通过普通for循环来实现。</li></ul></li><li><p>使用增强for循环来实现</p><ul><li><p>语法：</p><pre class="line-numbers language-Java"><code class="language-Java">/*for(数据类型 变量名 : 数组或集合){    //循环体}*/int[] arr = {1,23,4,5};//增强for循环for(int element : arr){   System.out.println(element); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>优势：语法简洁，效率较高。</p></li><li><p><strong>劣势：遍历的过程中，不能获得数组的合法索引值，因此遍历过程中我们无法操作数组中的元素。</strong></p></li><li><p>使用场合：遍历数组的过程中，如果<strong>无需获得数组的合法索引取值</strong>，也就是遍历数组过程中<strong>无需操作数组元素，</strong>则建议通过增强for循环来实现。</p></li><li><p><strong>快速使用增强for循环来遍历数组：数组名.for + enter</strong></p></li><li><p><strong>强调：通过length属性获得数组空间长度，则该操作的效率是非常低，因此在循环中切记不要使用length属性来获得数组空间长度。</strong></p></li><li><p>**建议定义一个数组长度变量来循环</p></li></ul></li></ol><h4 id="栈内存的概述"><a href="#栈内存的概述" class="headerlink" title="栈内存的概述"></a>栈内存的概述</h4><ul><li><p>存储：局部变量</p><p>–&gt; “基本数据类型”的局部变量，则在栈内存中存储的是”数据值”。</p><p>–&gt; “引用数据类型”的局部变量，则在栈内存中存储的是”地址值”。</p><p>特点：</p><ul><li>栈内存具备”先进后出”或”后进先出”的特点，类似于生活中的”子弹夹”。</li><li>栈内存是一块连续的存储空间，由虚拟机分配，效率高！</li><li>栈内存由虚拟机来管理，也就是无需程序员来手动管理内存。</li><li>虚拟机会为每个线程创建一个栈内存，用于存放该线程执行方法的信息。</li></ul></li><li><p>存储：对象（数组）</p><p>特点：</p><ul><li>堆内存不是一块连续的存储空间，分配灵活，但是效率低。</li><li>堆内存理论上需要程序员来手动管理，但是实际上交由”垃圾回收机制”来管理。</li><li><strong>虚拟机中只有一个堆内存，被所有的线程共享。</strong></li></ul></li></ul><h4 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h4><p>需求：将数组元素反转，原数组{5, 12, 54,7676,9}，反转后为：{9, 676, 54, 12, 5}。</p><p>要求：使用两种方式来实现</p><ol><li>方式一：<strong>创建一个新的数组，用于保存反转之后的结果。</strong><ul><li>缺点：<ul><li>需要创建新的数组，浪费了存储空间。</li><li>需要完整遍历整个数组，浪费了执行时间。</li></ul></li></ul></li><li>方式二：<strong>使用“首尾元素交换位置”的思路来实现。</strong><ul><li>优点：<ul><li>无需创建新的数组，节约了存储空间。</li><li>只需遍历数组长度的一半，节约了执行时间。</li></ul></li></ul></li></ol><h4 id="数组工具类"><a href="#数组工具类" class="headerlink" title="数组工具类"></a>数组工具类</h4><ul><li>问题：在前面的学习中，我们把操作数组的静态方法放到了不同的类中，因此想要调用这些静态方法的时候，我们首先得明确该方法在那个类中，然后才能通过“类名”来调用这些静态方法，因此调用这些方法的时候非常不方便。</li><li>解决：定义一个“数组工具类”，然后把操作数组的静态方法都放到该“数组工具类”中。</li></ul><ol><li><p>Arrays工具类的概述</p><ul><li>Arrays工具类在”java.util”包中，因此我们使用Arrays工具类的时候，必须通过import关键字导入Arrays类，然后才能使用Arrays工具类。</li><li>Arrays工具类我们称之为“数组相关的工具类”，在Arrays类中提供了很多操作数组的“静态方法”，因此我们调用这些方法的时候，直接通过类名.来调用。</li></ul></li><li><p>Arrays工具类的方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作用：把数组转换为字符串并返回，也就是获得数组中的元素，然后把这些元素拼接成字符串并返回。</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作用：数组的填充操作，把arr数组中的所有元素设置为val</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作用：给数组元素执行“排序”操作，默认为“升序”排序</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作用：对“指定范围”的数组元素执行“升序”排序</span><span class="token comment" spellcheck="true">//范围：从fromIndex索引位置开始（包含），到toIndex索引位置结束（不包含）。</span><span class="token comment" spellcheck="true">//注意：fromIndex取值范围在[0,数组长度-1]之间，toIndex取值范围在[0,数组长度]之间，并且必须满足toIndex大于fromIndex</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    作用：二分查找，查询key在arr数组中的索引位置。    返回值：如果查询元素在数组中存在，则返回该元素在数组中的索引位置；如果查询的元素在数组中不存在，则返回负数即可。*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    作用：对“指定范围”的数组元素执行二分查找操作，此处要求arr数组为升序排序。    范围；从fromIndex索引位置开始（包含），到toIndex索引位置结束（不包含）。    注意：fromIndex取值范围在[0, 数组长度-1]，toIndex取值范围在[0,数组长度]之间，并且必须满足toIndex大于fromIndex。    返回值：如果查询元素在数组中存在，则返回该元素在数组中的索引位置；如果查询的元素在数组中不存在，则返回负数即可。*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> newLength<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    作用：从索引为0的位置开始拷贝，一共拷贝newLength个数组元素并返回。    注意：此处newLength取值范围在[0,数组长度]之间。*/</span>Public <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOfRange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> to<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    作用：拷贝指定索引范围的数组元素    范围：从from索引位置开始（包含），到to索引位置结束（不包含）。    注意：from取值范围在[0,数组长度 - 1]之间，to取值范围在[0,数组长度]之间，并且必须满足to大于from*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    作用：判断arr1和arr2两个数组是否相等。    返回值：如果arr1和arr2的地址值相等或arr1和arr2的数组元素一一对应，则都返回true，否则一律返回false。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="方法的可变参数（掌握）"><a href="#方法的可变参数（掌握）" class="headerlink" title="方法的可变参数（掌握）"></a>方法的可变参数（掌握）</h4><p>1、可变参数的引入</p><ul><li><p>需求：定义一个方法，用于获得指定两个int类型数据之和。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="可变参数的语法"><a href="#可变参数的语法" class="headerlink" title="可变参数的语法"></a>可变参数的语法</h4><ul><li><p>语法：数据类型 … 可变参数名</p></li><li><p>eg：int … arr</p></li><li><p><strong>可变参数的注意点</strong></p></li><li><p>“可变参数”必须存在于“形参列表”中，并且“可变参数”必须在形参列表“最末尾”。</p><p>–&gt; 也就是说，方法的形参列表中最多只能定义一个可变参数（0或1）</p></li><li><p>在方法体中，我们可以把可变参数当成“数组”来使用，本质上可变参数就是数组的另外一种语法表现形式。</p><p>–&gt; eg：调用方法的是，实参为”int类型的数组”，则方法的形参可以为“int类型的可变参数”。</p></li><li><p><strong>可变参数的使用场合</strong></p><ul><li>定义一个方法的时候，参数的类型都相同，但是参数的个数不确定时。</li></ul></li></ul><h4 id="数组的核心特点"><a href="#数组的核心特点" class="headerlink" title="数组的核心特点"></a>数组的核心特点</h4><ul><li><p>数组是一块连续的存储空间，则意味着相邻两个元素的存储空间是紧挨着的。</p></li><li><p>数组存储的是相同数据类型的元素，则意味着每个元素占用的字节数相同。</p></li><li><p>常见数组则必须明确数组的空间长度，数组一旦创建成功，则数组的空间长度就不能改变。</p></li><li><p><strong>根据索引操作【改和查】</strong></p><ul><li><p>结论：根据索引操作元素效率非常高，甚至是所有数据结构中效率最高的。</p></li><li><p>依据：数组是一块连续的存储空间，则意味着相邻两个元素的存储空间是紧挨着。</p><p>–&gt; 数组存储的是相同数据类型的元素，则意味着每个元素占用的字节数相同。</p><p>–&gt; <strong>寻址公式：首地址 + 索引值 * 每个元素占用的字节数</strong></p></li></ul></li><li><p><strong>根据索引删除元素【删】</strong></p><ul><li><p>结论：根据索引删除元素的效率非常低，因为需要大量的挪动数组元素。</p></li><li><p>依据：数组是一块连续的存储空间，则意味着相邻两个元素的存储空间是紧挨着。</p><p>–&gt; 常见数组则必须明确数组的空间长度，数组一旦创建成功，则数组的空间长度就不能改变了</p></li></ul></li><li><p><strong>根据索引插入元素【增】</strong></p><ul><li><p>结论：根据索引插入元素的效率非常低，因为需要大量挪动数组元素+扩容操作。</p></li><li><p>依据：数组时一块连续的存储空间，则意味着相邻两个元素的存储空间时紧挨着。</p><p>–&gt; 常见数组则必须明确数组的空间长度，数组一旦创建成功，则数组的空间长度就不能改变啦。</p></li></ul></li></ul><h4 id="二维数组（矩阵，较难）"><a href="#二维数组（矩阵，较难）" class="headerlink" title="二维数组（矩阵，较难）"></a>二维数组（矩阵，较难）</h4><ol><li><p>二维数组的定义</p><ul><li>数组中的每个元素都是一堆数组，这样的数组我们就称之为“二维数组”。</li></ul></li><li><p>二维数组的声明</p><ul><li><p>明确：所谓二维数组的声明，指的就是给二维数组取一个名字，类似于“变量的声明”。</p></li><li><p>语法1：</p><pre class="line-numbers language-Java"><code class="language-Java">//数据类型[][] 数组名；int[][] arr1;String[][] arr2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>语法2：</p><pre class="line-numbers language-Java"><code class="language-Java">//数据类型[] 数组名[];int[] arr1[]String[] arr2[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>注意：实际开发中，我们建议使用”语法1”来声明二维数组，因为“数据类型 [ ] [ ] ”代表的是“二维数组类型”。</p></li></ul></li><li><p>二维数组的创建</p><ul><li><p>明确：所谓二维数组的创建，指的就是在堆内存中为二维数组开辟存储空间。</p></li><li><p><strong>方式一：创建“等长”的二维数组（动态）</strong></p><pre class="line-numbers language-Java"><code class="language-Java">//语法：数据类型[][] 数组名 = new 数据类型[m][n];// m: 设置二维数组得空间长度//n：设置一维数组的空间长度int[][] arr1 = new int[3][3];String[][] arr2 = new String[3][4];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>方式二：创建“不等长”的二维数组（动态）</strong></p><pre class="line-numbers language-Java"><code class="language-Java">//语法：数据类型[][] 数组名 = new 数据类型[m][];//m:设置二维数组的空间长度int[][] arr1 = new int[3][];String[][] arr2 = new String[4][];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>方式三：静态创建的二维数组（静态）(等长|不等长)</strong></p><pre class="line-numbers language-Java"><code class="language-Java">//数据类型[][] 数组名 = {{数据1,数据2}, {数据3,数据4},...}     int[][] arr1 = {{11,22,33},{55,66,77},{13,56,78}};String[][] arr2 = {{"aa","bb"},{"cc","dd","yt"}};//数据类型[][] 数组名 = new 数据类型[][]{{数据1,数据2}, {数据3,数据4},...};     int[][] arr1 = new int[][]{{11,22,33},{55,66,77},{13,56,78}};String[][] arr2 = new String[][]{{"aa","bb"},{"cc","dd","yt"}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>注意：通过大括号创建出来的二维数组，我们无法直接作为方法的”实参”和”返回值”，因为编译器不认识大括号创建的二维数组。</strong></p></li></ul></li></ol><hr><h2 id="异常及断点调试"><a href="#异常及断点调试" class="headerlink" title="异常及断点调试"></a>异常及断点调试</h2><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><ol><li><p><strong>debug调试的作用</strong></p><ul><li>查看代码的执行顺序，分析变量值的变化，从而找到问题的并解决问题。</li></ul></li><li><p><strong>debug的调试步骤</strong></p><ul><li><p>第一步：在代码可能出现问题的位置，我们在该位置打一个断点。</p><p>–&gt; 在该代码行号左侧位置，我们单击打一个断点（红色圆圈）</p></li><li><p>第二步：开启debug调试来执行程序，则代码就会停留在打断点的位置。</p><p>–&gt;方式一： 点击类名或main方法左侧绿色按钮，然后选中”Debug Xxx.main()”即可。</p><p>–&gt; 方式二：在代码编辑区域，我们鼠标右键然后选中”Debug Xxx.main()”即可。</p><p>–&gt; 方式三：已经执行程序后，我们点击工具栏或控制台左侧的”debug按钮”。</p></li><li><p>明确：开启debug调试之后，则就会出现debug窗口，debug窗口的作用如下：</p><p><strong>Debugger</strong></p><ul><li>Frames：显示代码停留的位置（包、类、方法和行号）</li><li>Variables：显示当前方法已经执行过的变量的值</li></ul><p><strong>Console</strong></p><ul><li>显示输出的内容或获取输入的内容。</li></ul></li><li><p>第三步：控制代码的执行，也就是通过Debug窗口来控制代码的执行。</p><ol><li>F8：执行下一行代码。</li><li>F7：进入执行方法体中的代码。</li><li>shift + F8：结束当前方法，回到方法的调用位置。</li><li>Alt + F9：直接执行到下一个断点的位置。</li><li>Alt + F8：计算并执行某行未执行代码的运算结果。</li></ol></li><li><p>第四步：结束debug调试。</p><p>首先，取消断点（单击取消）；然后，结束程序（点击红色按钮）；最后，关闭debug窗口。</p></li></ul></li></ol><h4 id="异常的概述"><a href="#异常的概述" class="headerlink" title="异常的概述"></a>异常的概述</h4><ol><li>什么是异常？<ul><li>程序在执行过程中，发生的各种不正常情况，我们就称之为“异常”。</li><li>例如：算数异常、数组索引越界异常、空指针异常和类型转换异常等等</li></ul></li><li>什么是异常类？<ul><li>用于封装和描述各种不正常情况的类，我们就称之为“异常类”。</li><li>例如：ArithmeticException、ArrayIndexOutOfBoundsException、NullPointerException和ClassCastException等等。</li></ul></li><li>学习异常的好处？<ul><li><strong>a)学习异常之后，就能够实现把“正常逻辑代码”和“错误逻辑代码”相分离。</strong></li><li>b)没有学习异常，则某些情况下无论我们如何处理，则都可能无法满足需求。</li></ul></li><li><strong>异常的处理机制？</strong><ul><li>在java语言中，使用面向对象的思想来处理异常。在可能出现问题的位置，我们创建并抛出一个异常对象，该异常对象中封装了异常的详细描述信息（异常类名、异常位置和异常原因），从而实现“正常逻辑代码”和“错误逻辑代码”相分离。</li></ul></li></ol><h4 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h4><ol><li>算数异常（ArithmeticException）<ul><li>原因：做除法操作的时候，如果分母为零，则就会抛出算数异常。</li></ul></li><li>数组索引越界异常（ArrayIndexOutOfBoundsException）<ul><li>原因：根据索引操作数组元素的时候，如果操作的索引值越界，则就会抛出数组索引越界异常。</li></ul></li><li>空指针异常（NullPointerException）<ul><li>原因：我们对空对象做操作，则就会抛出空指针异常。</li></ul></li></ol><h4 id="异常的体系"><a href="#异常的体系" class="headerlink" title="异常的体系"></a>异常的体系</h4><ol><li><p>异常体系的引入</p><ul><li>在程序执行的过程中，可能会发生各种各样的不正常情况，因此我们就需要很多的异常类来封装和描述这些不正常情况，我们对这些异常类进行“向上提取”，那么就得到了异常的继承体系。</li></ul></li><li><p>异常体系的概述</p><ul><li><p><strong>所有Java类的老祖宗为Object类，所有不正常情况类的老祖宗就是Throwable类，那么Throwable类的继承体系如下：</strong></p><pre class="line-numbers language-Java"><code class="language-Java">/*Throwable          --> 所有不正常情况类的老祖宗 |-- Error         --> 所有错误类的老祖宗 |-- Exception     --> 所有异常类的老祖宗 *///注意：a)如何查看某个类的继承体系呢？？？选中该类，然后使用“ctrl + h”来查看继承体系。    // b)所有错误类的后缀都以“Error”来结尾，所有异常类的后缀都以“Exception”来结尾。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>Throwable的概述</p><ul><li><strong>Throwable类是所有不正常情况类的老祖宗，Error类和Exception类都属于Throwable的子类，因此Error类和Exception类都能使用Throwable提供的方法。</strong></li></ul></li><li><p>Error类的概述</p><ul><li><strong>Error类是所有“错误类”的老祖宗，并且Error类继承于Throwable类，因此Error类能使用Throwable类提供的所有方法。</strong></li><li><strong>Error描述的是“资源耗尽”或“虚拟机内部错误”等不正常情况，因此开发中遇到这样的不正常情况，我们程序员是无法解决的（不结束程序的前提来解决），也就是程序员只能先结束程序，然后再去重新修改代码来搞定这种不正常情况</strong>。</li></ul></li><li><p>Exception类的概述</p><ul><li>Exception类是所有“异常类”的老祖宗，并且Exception类继承于Throwable类，因此Exception类能使用Throwable类提供的所有方法。</li><li><strong>Exception类描述的是“程序员能够解决”的不正常情况，开发中我们遇到了Exception异常，则需要拼尽全力去解决该异常（不结束程序的前提来解决）。</strong></li><li><strong>Error属于程序员无法解决的不正常情况，而Exception属于程序员能够解决的不正常情况。</strong></li></ul></li><li><p><strong>Error与Exception的区别</strong></p><ul><li>我开着车走在路上，一头猪冲在路中间，我刹车，这叫一个异常。</li><li>我开着车在路上，发动机坏了，我停车，这叫错误。</li><li>发动机什么时候坏？我们普通司机能管吗？不能。发动机什么时候坏是汽车厂发动机制造商的事。</li></ul></li></ol><h4 id="自定义异常类（掌握）"><a href="#自定义异常类（掌握）" class="headerlink" title="自定义异常类（掌握）"></a>自定义异常类（掌握）</h4><ol><li><p>自定义异常类的引入</p><ul><li>问题：给学生年龄复制的时候，则赋值的年龄不能为负数。</li><li>解决：如果赋值的年龄为负数，则无论我们给年龄赋值任何数据都不合理，那么最好的方案就是如果年龄不合法就抛出异常。</li><li>问题：如果赋值的年龄不合法，则应该抛出“学生年龄不合法异常”，该如何实现？？？</li><li><strong>解决：使用“自定义异常类”来解决。</strong></li></ul></li><li><p>什么时候使用自定义异常类</p><ul><li>当Java语言提供的异常类无法满足我们的需求，则我们就可以使用“自定义异常类”来满足需求。</li></ul></li><li><p>自定义异常类的要求</p><ul><li><p><strong>要求1：自定义异常类必须继承于异常体系中的类，一般继承于Exception类或RuntimeException类。</strong></p><p>–&gt; <strong>只有继承于异常体系的中的类，该类才具备可抛型，也就是才能使用throw和throws关键字。</strong></p></li><li><p>要求2：自定义异常类必须提供两个构造方法，其中一个为无参构造方法，<strong>另外一个为字符串参数的有参构造方法。</strong></p><p> –&gt; <strong>使用字符串参数的有参构造方法，我们可以用于封装和保存异常出现的原因，从而传递给父类的异常来保存。</strong></p></li></ul></li></ol><h4 id="异常产生的过程"><a href="#异常产生的过程" class="headerlink" title="异常产生的过程"></a>异常产生的过程</h4><ul><li>如果在方法体中抛出了异常，而我们在方法体中又没有处理该异常，则就会把该异常继续抛给方法的上层调用者，也就是抛给方法的上层调用者来处理。</li><li>如果方法的上层调用者依旧没有处理该异常，那么就会继续把该异常抛给方法的上层调用者来处理，以此类推，如果方法的上层调用者都没有处理该异常，那么最终就把该异常抛给了main方法的调用者（虚拟机），而虚拟机也不会处理该异常，那么程序就终止啦。</li></ul><h4 id="手动抛出异常（throw）"><a href="#手动抛出异常（throw）" class="headerlink" title="手动抛出异常（throw）"></a>手动抛出异常（throw）</h4><ol><li>在可能出现异常的位置，我们创建并抛出一个异常对象，该异常对象中包含了异常的详细描述信息（异常类名、异常位置和异常原因），从而实现了“正常逻辑代码”和“错误逻辑代码”相分离。</li><li>注意：throw关键字只能在方法体中使用，也就是我们只能在方法体中来手动抛出一个异常。</li></ol><h4 id="异常的分类（重点）"><a href="#异常的分类（重点）" class="headerlink" title="异常的分类（重点）"></a>异常的分类（重点）</h4><ol><li><p>异常的分类的引入？</p><ul><li><p>问题：“学生年龄越界异常类”继承于Exception类和RuntimeException类的区别?</p></li><li><p>答案：“学生年龄越界异常类”继承于Exception类，则抛出“学生年龄越界异常”就会出现<strong>编译错误。</strong></p><p> “学生年龄越界异常类”继承于RuntimeException类，则抛出 “学生年龄越界异常”就<strong>不会出现编译错误。</strong></p></li></ul></li><li><p>异常的分类的概述</p><ul><li><p><strong>运行时异常</strong></p><p>–&gt; 包含：RuntimeException类及其所有子类。</p><p>–&gt; 特点：程序编译时，不强制我们对抛出的异常进行处理（可以处理，也可以不处理）</p></li><li><p>编译时异常</p><p>–&gt;包含：Exception类及其所有子类（排除运行时异常）。</p><p>–&gt;特点：程序编译时，强制我们对抛出的异常进行处理（必须处理，否则就会编译错误）。</p></li></ul></li><li><p>异常的处理的方式</p><ul><li><p><strong>声明异常（throws）</strong></p><p>–&gt; 属于“消极”的处理方式，本质上并没有处理该异常。</p></li><li><p><strong>捕捉异常（try…catch…finally）</strong></p><p>–&gt;属于“积极”的处理方式，本质上已经解决了该异常。</p></li></ul></li><li><p>不正常情况的分类补充</p><ul><li><p><strong>可检查异常（CheckedException）</strong></p><p>–&gt;包含：编译时异常</p><p>–&gt;特点：<strong>程序在编译时期，能够检查出程序中出现的不正常情况。</strong></p></li><li><p><strong>不可检查异常（UnCheckedException）</strong></p><p>–&gt;包含：Error和运行时异常</p><p>–&gt;特点：<strong>程序在编译时期，不能够检查出程序中出现的不正常情况。</strong></p></li></ul></li></ol><h4 id="声明异常（throws）"><a href="#声明异常（throws）" class="headerlink" title="声明异常（throws）"></a>声明异常（throws）</h4><ol><li><p>声明异常的概述</p><ul><li>声明异常属于“消极”的处理方式，本质上并没有解决该异常。</li><li>程序中出现了异常，此时我们又无法处理该异常，那么就使用声明异常来处理。</li></ul></li><li><p>声明异常的使用？</p><ul><li>当方法中“可能”会出现异常，此时我们又无法处理该异常，那么就可以使用“声明异常”来处理。也就是在方法声明的末尾，使用throws关键字将方法体中可能抛出的异常声明出来，然后报告给方法的调用者，交给方法的调用者来处理。</li></ul></li><li><p>声明异常的语法</p><pre class="line-numbers language-Java"><code class="language-Java">[修饰符] 返回值类型 方法名(形参列表) throws 异常类1, 异常类2, 异常类3, ... {    // 方法体     return [返回值];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="捕捉异常类（try…catch…finally）"><a href="#捕捉异常类（try…catch…finally）" class="headerlink" title="捕捉异常类（try…catch…finally）"></a>捕捉异常类（try…catch…finally）</h4><ol><li><p>捕捉异常的概述</p><ul><li>捕捉异常属于“积极”的处理方式，本质上就已经处理了该异常。</li><li>当程序中可能出现异常，此时我们恰好能解决该异常，则就使用捕捉异常来处理。</li></ul></li><li><p>try…catch组合</p><ul><li><p>语法</p><pre class="line-numbers language-Java"><code class="language-Java">try{    //书写可能出现异常的代码}catch(异常类 对象){    //用于处理捕获到的异常。}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行：如果try代码块中没有出现异常，则try代码块中的代码正常执行完毕，然后就直接执行try…catch之后的代码。 <strong>如果try代码块中出现了异常，则catch代码块就会立刻捕获到该异常，然后就执行catch代码中的代码，最后再执行try…catch之后的代码。</strong></p></li></ul></li><li><p>try…多catch组合</p><ul><li><p>语法：</p><pre class="line-numbers language-Java"><code class="language-Java">try{    //书写可能出现异常的代码}catch(异常类 对象){    //用于处理捕获到的异常}catch(异常类 对象){    //用于处理捕获到的异常}...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>作用：<strong>使用try…多catch组合，我们可以实现对try代码块中出现的异常进行“针对性”的处理。</strong></p></li><li><p>注意：</p><ol><li><p><strong>使用捕捉异常的时候，建议使用“Ctrl + Alt + T”快捷键来生成try…catch…finally代码。</strong></p><ul><li>选择中可能出现异常的代码，然后使用使用“Ctrl + Alt + T”快捷键来捕捉异常的代码。</li></ul></li><li><p>在JDK1.8之后，则我们还以可以这样来处理：</p><pre class="line-numbers language-Java"><code class="language-Java">catch (NullPointerException | ArrayIndexOutOfBoundsExceptionexception) {    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>以上操作不建议使用，因为使用以上操作无法实现对try代码块中出现的异常进行针对性的处理。</strong></li></ul></li><li><p>使用try…多catch组合的时候，建议把子类异常catch放在前面，把父类异常catch放在后面，否则就会编译错误。</p><ul><li><strong>捕获异常的时候，属于“从上往下”来顺序匹配，如果父类异常catch放前面，则后面的子类异常catch将永远无法执行。</strong></li></ul></li><li><p>try…多catch…finally组合</p><ul><li><p>语法：</p><pre class="line-numbers language-Java"><code class="language-Java">try{    //书写可能出现异常的代码}catch(异常类 对象){// 用于处理捕获到的异常}catch(异常类 对象){// 用于处理捕获到的异常}…finally{// 无论是否出现异常，则都会执行finally中代码}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol></li></ul></li></ol><h4 id="方法重写之异常（掌握）"><a href="#方法重写之异常（掌握）" class="headerlink" title="方法重写之异常（掌握）"></a>方法重写之异常（掌握）</h4><ol><li><p>原则：子类重写方法声明的异常类型必须小于等于父类被重写方法声明的异常类型【辈分】。</p><p>–&gt;此处说的异常，指的是编译时异常，而运行时异常不用管！</p></li><li><p>要求：a)如果父类被重写方法没有声明异常，则子类重写方法也不能声明异常。</p><p>b)如果父类被重写方法声明了异常，则子类重写方法声明的异常类型必须小于等于父类被重写方法声明的异常类型（辈分）。</p></li></ol><h4 id="异常链（了解）"><a href="#异常链（了解）" class="headerlink" title="异常链（了解）"></a>异常链（了解）</h4><ol><li><p>解释：在catch代码块中，我们抛出一个描述更加详细的异常，这就是异常链。</p><pre class="line-numbers language-Java"><code class="language-Java">// 分母为零异常类class DenominatorZeroException extends Exception {    public DenominatorZeroException() { }    public DenominatorZeroException(String message) {        super(message);    }}public class Test03 {    /**     * 功能：获得两个数相除的结果     * 问题：a)除法运算，如果分母为0，则不应该返回任何结果，而此处却返回了结果为0。     *      b)除法运算，如果分母为0，则抛出算数异常，那么意味着异常描述不够清晰。     * 解决：使用“异常链”来解决。     */    public static int division(int fenZi, int fenMu) throws DenominatorZeroException {        // 1.定义一个变量，用于保存运算的结果        int result = 0;        // 2.执行除法运算，并处理了可能出现的算数异常        try {            result = fenZi / fenMu;        }        catch (ArithmeticException exception) {            // 需求：在此处，我们需要抛出一个描述更加详细的异常            throw new DenominatorZeroException("分母为零异常，fenMu：" + fenMu);        }        // 3.返回除法运算的结果        return result;    }    public static void main(String[] args) {        try {            int result = division(5, 0);            System.out.println(result);        } catch (DenominatorZeroException e) {            e.printStackTrace();        }        System.out.println("over");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h4 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h4><ul><li><p>封装（堆功能method的封装）</p></li><li><p>典型：c语言</p></li><li><p>特点：以线性的思维来思考解决问题，强调一步一步的实现。</p><p>–&gt; 强调程序员是一个“实施者”，类似于公司中的“小职员”。</p></li><li><p><strong>优点：效率高。</strong></p></li><li><p><strong>缺点：程序的复用性、可维护性和可扩展性较低</strong>。</p></li><li><p>使用场合：适用于“小型”的程序，例如：计算器、嵌入式开发等等</p></li></ul><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul><li><p>封装（对数据field和功能method做的封装）、继承和多态。</p></li><li><p>典型：C++、C#、java等。</p></li><li><p>特点：以非线性的思维来思考解决问题，强调宏观上的把控。</p><p>–&gt; 强调程序员是一个“指挥官”，类似于公司中的“小老板”。</p></li><li><p><strong>优点：程序的复用性、可维护性和可扩展性较高。</strong></p></li><li><p><strong>缺点：效率低。</strong></p></li><li><p>使用场合：适用于“大型”的程序，例如：京东、淘宝、微信等等。</p></li></ul><h4 id="面向对象编程的特点"><a href="#面向对象编程的特点" class="headerlink" title="面向对象编程的特点"></a>面向对象编程的特点</h4><ul><li><strong>宏观</strong>上采用面向对象的思维来把控，<strong>微观</strong>实施上依旧采用的是面向过程，即<strong>：面向对象中包含了面向过程。</strong></li></ul><h4 id="类和对象（理解）"><a href="#类和对象（理解）" class="headerlink" title="类和对象（理解）"></a>类和对象（理解）</h4><ol><li><p>对象（instance）</p><ul><li>从编程的角度来理解：万物皆对象。</li><li>eg：教室里面的每个学生、每个凳子、每张椅子。。。</li><li><strong>每个对象都是“独一无二”的，类似于每个同学都是“独一无二”的。</strong></li></ul></li><li><p>类（class）</p><ul><li>从编程的角度来理解：类就是对一类事物的抽象，抽象就是提取这一类事物的共同属性和行为，这样就形成了类。</li><li>eg:班上的每个同学都有姓名、年龄和成绩等属性，每个同学都有吃饭、睡觉和学习等行为，则我们对班上的同学进行向上提取，那么就得到了学生类。</li></ul></li><li><p>类和对象</p><ul><li><p>从编程的角度来分析：我们以类为模板，然后实例化出对象。</p><p>–&gt; <strong>先有类，后有对象。</strong></p><p>–&gt; <strong>类是对象的模板，对象是类的实例。</strong></p><p>eg：我们以小汽车图纸（类）为模板，然后生产出一辆一辆的小汽车（对象）。</p></li></ul></li></ol><h4 id="如何定义类"><a href="#如何定义类" class="headerlink" title="如何定义类"></a>如何定义类</h4><p>语法：[修饰类] class类名{ &#x2F;&#x2F;书写的代码 }</p><p>注意：</p><ul><li>使用class关键字修饰的就是类，也就是类必须使用class来修饰。</li><li><strong>类名必须满足“标识符”的命名规则，必须满足“大驼峰”的命名规范，并且最好“见名知意”。</strong></li><li>使用“public”关键字修饰的类，则类名必须和源文件名字保持一致，否则就会出现编译错误。</li></ul><h4 id="类中的组成"><a href="#类中的组成" class="headerlink" title="类中的组成"></a>类中的组成</h4><ul><li>数据（属性），我们使用“变量”来存储类中封装的数据，类中的变量有：<ol><li>成员变量：又称之为“实例变量”或“非静态变量”，因为是从属于“对象”的。</li><li>静态变量：又称之为“类变量”，从属于“类”的。</li></ol></li><li>功能（行为），我们使用“方法”来封装类中的功能。<ol><li>成员方法，又称之为“实例方法”或“非静态方法”，从属于“对象”的。</li><li>静态方法，又称之为“类方法”，从属于“类”的。</li></ol></li></ul><h4 id="成员变量的概述"><a href="#成员变量的概述" class="headerlink" title="成员变量的概述"></a>成员变量的概述</h4><ul><li><p><strong>定义位置：在类中，代码块和方法体之外。</strong></p></li><li><p>定义语法：[修饰符] 数据类型 变量名；</p><p>–&gt;定义成员变量的时候，则不允许使用static关键字来修饰。</p></li><li><p>操作成员变量的语法：对象.成员变量名</p><p>–&gt; 通过 “对象.成员变量名” 就能找到该成员变量的存储空间，然后就能对该成员变量取值和赋值的操作。</p><p>–&gt; 在成员方法中，想要操作当前类的成员变量，则我们可以直接通过“成员变量名”来操作。</p><p>–&gt; 定义成员方法的时候，则不允许使用static关键字来修饰。</p><p><strong>调用成员方法的语法：对象.成员变量名(实参列表);</strong></p><p> –&gt; 注意：<strong>在成员方法中，想要调用当前类的成员方法，则我们可以直接通过“成员变量名(实参列表);”来实现。</strong></p></li></ul><h4 id="实例化对象的概述"><a href="#实例化对象的概述" class="headerlink" title="实例化对象的概述"></a>实例化对象的概述</h4><ul><li><p>语法</p><pre class="line-numbers language-Java"><code class="language-Java">类型 对象 = new 类名(实参列表);Student stu = new Student();Scanner input = new Scanner(System.in);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="成员变量的默认值"><a href="#成员变量的默认值" class="headerlink" title="成员变量的默认值"></a>成员变量的默认值</h4><ul><li>明确：“成员变量”和“数组元素”都有默认值，并且默认值规则一样。</li><li>整数型（byte、short、int和long）成员变量的默认值为：0；</li><li>浮点型（float和double）成员变量的默认值为：0.0;</li><li>布尔型（boolean）成员变量的默认值为：false；</li><li>字符型（char）成员变量的默认值为：’\u0000’ –&gt; 代表的是空格字符</li><li>引用数据类型（数组、字符串、类和接口等等）成员变量的默认值为：null</li></ul><h4 id="成员变量的初始化"><a href="#成员变量的初始化" class="headerlink" title="成员变量的初始化"></a>成员变量的初始化</h4><ul><li><strong>最先执行“默认初始化”，然后执行“显示初始化”，最后执行“指定初始化”。</strong></li></ul><h4 id="创建对象时的内存分析"><a href="#创建对象时的内存分析" class="headerlink" title="创建对象时的内存分析"></a>创建对象时的内存分析</h4><ul><li><strong>结论：</strong>以类为模板来创建对象，则只需要为类中的成员变量在堆内存中开辟存储空间，<strong>而成员方法是调用的时候自动在栈内存中开辟栈帧。</strong></li><li><strong>注意：</strong>每个对象都是“独一无二”的，<strong>因为每次创建对象都会在堆内存中开辟存储空间。</strong></li></ul><h4 id="成员变量和局部变量的对比"><a href="#成员变量和局部变量的对比" class="headerlink" title="成员变量和局部变量的对比"></a>成员变量和局部变量的对比</h4><ol><li>定义位置区别<ul><li>成员变量：在类中，代码块和方法体之外。</li><li>局部变量：在类中，代码块或方法体之内。</li></ul></li><li>存储位置区别<ul><li>成员变量：存储在“堆内存”中。</li><li>局部变量：存储在“栈内存”中。</li></ul></li><li>生命周期区别<ul><li>成员变量：随着对象的创建而“出生”，随着对象的销毁而“死亡”。</li><li>局部变量：定义变量的时候“出生”，所在作用域执行完毕就“死亡”。</li></ul></li><li>默认值的区别<ul><li>成员变量：成员变量有默认值，并且默认值规则和数组元素默认值规则一模一样。</li><li>局部变量：局部变量没有默认值，因为只声明未赋值的局部变量，则不能做取值操作。</li></ul></li><li>修饰符的区别<ul><li>成员变量：可以被public、protected、private、static、final等修饰符修饰。</li><li>局部变量不能被public、protected、private、static修饰，只能被final修饰。</li></ul></li></ol><h4 id="成员变量和局部变量的使用"><a href="#成员变量和局部变量的使用" class="headerlink" title="成员变量和局部变量的使用"></a>成员变量和局部变量的使用</h4><ul><li>明确：当成员变量和局部变量同名的时候，则默认采用的是“就近原则”，也就是“谁离的近，就执行谁”。</li><li>问题：当成员变量和局部变量同名的时候，我们该如何区分？</li><li>解决：局部变量采用“就近原则”来区分，成员变量使用“this”关键字来区分。</li></ul><h4 id="通过new关键字来创建对象，则创建出来的对象分为两种"><a href="#通过new关键字来创建对象，则创建出来的对象分为两种" class="headerlink" title="通过new关键字来创建对象，则创建出来的对象分为两种"></a>通过new关键字来创建对象，则创建出来的对象分为两种</h4><ol><li>匿名对象，指的就是“没有名字的对象”，例如：new Tiger();</li><li>非匿名对象，指的就是“有名字的对象”，例如：Tiger tiger &#x3D; new Tiger();</li><li>开发中，匿名对象很少使用，但是以下两种场合建议使用匿名对象来实现。<ul><li>创建出来的对象，仅仅只调用一次成员方法，则该对象就建议使用匿名对象来实现。</li></ul></li></ol><h4 id="构造方法（构造器或构造函数）"><a href="#构造方法（构造器或构造函数）" class="headerlink" title="构造方法（构造器或构造函数）"></a>构造方法（构造器或构造函数）</h4><ul><li><p>语法</p><pre class="line-numbers language-Java"><code class="language-Java">[修饰符] 类名(形参列表){    //方法体}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>注意：【构造方法的特点】</strong></p><ol><li><p>构造方法中没有“返回值类型”，因为在构造方法中不允许有“返回值”。</p><p>–&gt; 构造方法中没有“返回值”，则构造方法中只有“return;”，那么我们就省略”return;”。</p></li><li><p>构造方法的名字必须为“类名”，也就是构造方法名采用”大驼峰”来命名。</p><p>–&gt; 构造方法名采用“大驼峰”，而成员方法名和静态方法名采用“小驼峰”。</p></li><li><p>构造方法就是一个“特殊”的方法，并且构造方法应该通过new关键字来调用。</p></li><li><p><strong>构造方法专门给成员变量做初始化，也就是构造方法不为静态变量做初始化。</strong></p></li><li><p>构造方法可以没有（默认一个无参构造方法），也可以有多个构造方法，他们之间构成重载关系。</p></li><li><p>如果定义有参构造方法，则无参构造方法被自动屏蔽。</p></li><li><p>构造方法不能被继承。</p></li><li><p>构造方法不能手动调用，在创建类实例的时候自动调用构造方法。</p></li></ol></li><li><p><strong>创建对象的步骤</strong></p><p>分析“new Student();”的执行顺序，也就是分析创建对象的执行步骤：</p><ol><li>创建对象，并给成员变量开辟存储空间；</li><li>给成员变量做“默认初始化”；</li><li>给成员变量做“显式初始化”；</li><li>调用构造方法，给成员变量做“指定初始化”。</li></ol></li><li><p><strong>创建对象的时候，是谁来完成的呢？</strong></p><ul><li>new关键字负责创建对象，构造方法负责给成员变量做指定初始化操作，创建对象的时候new关键字和构造方法缺一不可。</li></ul></li><li><p><strong>构造方法的作用</strong></p><ol><li>创建对象的时候new关键字和构造方法缺一不可（了解）。</li><li><strong>通过构造方法来给成员变量做指定初始化操作，从而实现代码的复用【核心】。</strong></li></ol></li><li><p><strong>无参构造方法的概述</strong></p><ul><li>作用：用于给成员变量做初始化操作，例如在无参构造方法中给int类型数组做开辟存储空间的操作。</li><li>注意：<strong>如果某个类中没有显式地提供构造方法，则程序编译时会默认为这个类提供一个无参构造方法。</strong></li></ul></li><li><p><strong>有参构造方法的概述</strong></p><ul><li>作用：用于给成员变量做初始化操作，例如<strong>在有参构造方法中我们将形参的值赋值给成员变量来保存。</strong></li><li>注意：<ol><li>建议形参的名字和成员变量名保持一致，然后在构造方法中通过this来操作成员变量。</li><li>如果一个类显式地提供了构造方法，则程序编译时就不会为该类提供默认的无参构造方法了。</li><li>建议每个类都应该提供无参构造方法，避免在继承体系中子类找不到父类的无参构造方法。</li></ol></li></ul></li><li><p><strong>构造方法的重载</strong></p><ul><li>构造方法依旧可以实现方法的重载，<strong>调用构造方法的时候会根据实参的“个数”和“类型”来选中调用合适的构造方法。</strong></li></ul></li></ul><h4 id="this关键字（重点）"><a href="#this关键字（重点）" class="headerlink" title="this关键字（重点）"></a>this关键字（重点）</h4><ol><li><p><strong>this关键字的概述</strong></p><ul><li>创建一个对象成功之后，则<strong>虚拟机</strong>就会<strong>动态地创建一个引用</strong>，该引用<strong>指向的就是新创建出来的对象</strong>，并且该引用的名字就是this。</li></ul></li><li><p><strong>this关键字指的是什么？</strong></p><ul><li><p>在构造方法中，this指的是什么？</p><p><strong>在构造方法中，this指的是“新创建出来的对象”。</strong></p></li><li><p>在成员方法中，this指的是什么？</p><p>在成员方法中，this指的是“方法的调用者对象”。</p></li></ul></li><li><p><strong>this关键字的作用</strong></p><ol><li><p><strong>操作成员变量，语法：对象.成员变量名</strong></p><ul><li>如果成员变量和局部变量的名字相同，则我们必须通过this关键字来操作成员变量，使用就近原则来操作局部变量。</li><li>如果成员变量和局部变量的名字不同，则我们可以通过this关键字来操作成员变量，也可以忽略this关键字来操作成员变量。<ul><li>–&gt; 忽略this关键字来操作成员变量，则编译时会默认添加this关键字来操作。</li></ul></li></ul></li><li><p><strong>调用成员方法，语法：对象.成员变量名(实参列表);</strong></p><ul><li><p>调用当前类的别的成员方法时，我们可以通过this关键字来调用，也可以忽略this关键字来调用。</p><p>–&gt; 忽略this关键字来调用成员方法，则编译时会默认添加this关键字来操作。</p></li></ul></li><li><p><strong>调用构造方法，语法：this(实参列表);</strong></p><ul><li><p>作用：调用“当前类”的别的构造方法，此处仅仅调用方法并不创建对象，从而实现了代码的复用。</p></li><li><p>注意：</p><ol><li><p><strong>“this(实参列表)”只能存在于构造方法中，并且必须在构造方法有效代码的第一行。</strong></p><p>–&gt; “this(实参列表)”必须在构造方法有效代码的第一行，则意味着一个构造方法中最多只能有一个“this(实参列表)”。（0或1）</p></li><li><p><strong>构造方法切记不能“递归”调用，否则就会陷入死循环，从而造成程序编译错误！</strong></p><p>–&gt; 在构造方法中，我们不允许通过“this(实参列表)”来自己调用自己，否则就会编译错误！</p></li><li><p><strong>在一个类中，不可能所有的构造方法中都存在“this(实参列表)”,因为这样肯定会陷入死循环。</strong></p><p><strong>–&gt; 一个类中，可以定义多个构造方法，但是至少有一个构造方法中没有“this(实参列表)”。</strong></p></li></ol></li></ul></li></ol></li></ol><h4 id="静态变量（重点）"><a href="#静态变量（重点）" class="headerlink" title="静态变量（重点）"></a>静态变量（重点）</h4><ol><li><p><strong>静态变量的引入</strong></p><ul><li>需求：班上所有同学的姓名、年龄和成绩等属性，并且所有的学生都共享同一个教室和饮水机。</li><li>解决：定义一个Student类，然后在Student类中定义姓名、年龄、成绩、教室和饮水机等成员变量即可。</li></ul></li><li><p><strong>静态变量的概述</strong></p><ul><li>在类中，代码块和方法体之外，使用static关键字修饰的变量，我们就称之为“静态变量”。</li></ul></li><li><p><strong>静态变量的特点</strong></p><ol><li><p>静态变量优先于对象存在，随着类的加载就已经存在了。</p></li><li><p>一个类中，每个静态变量都只有一份，为类和对象所共享。</p></li><li><p>我们可以通过“类名”来操作静态变量，也可以通过“对象”来操作静态变量。</p><p><strong>语法1：类名.静态变量 –&gt; 建议</strong></p><p>语法2：对象.静态变量 –&gt; 不建议</p></li></ol></li><li><p><strong>类的加载过程分析</strong></p><ul><li><p>第一次使用某个类的时候，就会加载该类的信息进入方法区，如果该类中存在静态变量，则还会在方法区中为该静态变量开辟存储空间并设置默认值。</p></li><li><p><strong>问题1：什么时候执行加载类的操作呢？</strong></p><p>–&gt; 第一次使用某个类的时候，则就会执行加载类的操作。</p></li><li><p><strong>问题2：一个类会加载几次呢？</strong></p><p>–&gt; 每个类都只会加载一次，因为第一次使用某个类的时候就执行加载类的操作。</p></li><li><p><strong>问题3：什么是方法区？方法区存储的内容是什么？？</strong></p><p> <strong>–&gt; 方法区就是一块存储空间，并且方法区属于堆内存中的一部分，方法区用于存储类的信息、静态变量等等内容。</strong></p></li><li><p><strong>问题4：静态变量什么时候开辟存储空间呢？</strong></p><p>–&gt; 加载类的时候，则就会把该类中的静态变量在方法区中开辟存储空间，<strong>也就意味着静态变量优先于对象存在。</strong></p></li><li><p><strong>问题5：一个类中的静态变量，会开辟几次存储空间？</strong></p><p>–&gt; 因为类只会加载一次，<strong>因此每个类中的静态变量就只有一份，也就是每个静态变量只会开辟一次存储空间。</strong></p></li><li><p><strong>问题6：静态变量的默认值是什么？</strong></p><p>–&gt; 静态变量和成员变量都有默认值，并且他们的默认值规则一模一样。</p></li></ul></li></ol><h4 id="成员变量和静态变量的对比"><a href="#成员变量和静态变量的对比" class="headerlink" title="成员变量和静态变量的对比"></a>成员变量和静态变量的对比</h4><ol><li>存储位置区别<ul><li>成员变量：存储在堆内存中。</li><li>静态变量：存储在方法区中。</li></ul></li><li>生命周期<ul><li>成员变量：随着对象的创建而“出生”，随着对象的销毁而”死亡”。</li><li>静态变量：随着类的加载而“出生”，随着程序执行完毕而“死亡”。</li></ul></li><li>创建次数的区别：<ul><li>成员变量：对象创建多少次，则成员变量就创建多少次。</li><li>静态变量：因为类只会加载一次，因次静态变量就只会创建一次。</li></ul></li><li>调用语法区别<ul><li>成员变量：必须通过”对象”来调用。</li><li>静态变量：可以通过“类名”来调用，也可以通过“对象”来调用。</li></ul></li></ol><h4 id="成员变量和静态变量的使用"><a href="#成员变量和静态变量的使用" class="headerlink" title="成员变量和静态变量的使用"></a>成员变量和静态变量的使用</h4><ul><li>成员变量：如果存储的是“特有数据”，则就使用成员变量来存储。</li><li>静态变量：如果存储的是“共享数据”，则就是用静态变量来存储。</li></ul><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ol><li><p><strong>代码块的分类</strong></p><ul><li>局部代码块</li><li>静态代码块</li><li>构造代码块(非静态代码块)</li></ul></li><li><p><strong>局部代码块的概述</strong></p><ul><li>定义位置：在类中，代码块或方法体的内部。</li><li>定义个数：任意多个。</li><li>执行顺序：从上往下，顺序执行。</li><li>注意事项：<ol><li>在局部代码块中定义的变量，则该变量就只能在当前作用域中使用，不能在代码块之外使用。</li></ol></li></ul></li><li><p><strong>静态代码块的概述</strong></p><ul><li><p>定义位置：在类中，代码块和方法体之外（必须使用static来修饰）。</p></li><li><p>定义个数：任意多个</p></li><li><p>执行顺序：从上往下，顺序执行</p></li><li><p>注意事项：a）加载某个类的时候，就会执行该类中的静态代码块，并且静态代码块只会执行一次。</p><p> –&gt;执行时间：加载类的时候，就会执行该类中的静态代码块。</p><p> –&gt; 执行次数：因为类只会加载一次，因此静态代码块就只会执行一次。</p><p> b）在静态代码块中，我们可以直接操作当前类的静态内容，但是不能直接操作当前类的成员内容和this。</p><p> –&gt; 原因：加载类的时候，就会执行该类中的静态代码块，则执行静态代码块的时候对象都还未创建。</p><p> c）加载类的时候，静态变量和静态代码块属于“从上往下，顺序执行”，建议把静态变量定义在静态代码块之前。</p><p> –&gt; 注意：在静态代码块中，我们“未必”能直接操作当前的静态变量。</p><p> d）在静态代码块中定义的变量，则该变量就只能在当前作用域中使用，不能再代码块之外使用。</p><p>使用场合：<strong>开发中，我们经常再静态代码块中完成对静态变量的初始化操作（常见）。</strong></p><p> –&gt;例如：创建工厂、加载数据库初始信息等等。</p></li></ul></li><li><p><strong>构造代码块的概述</strong></p><ol><li>定义位置：在类中，代码块和方法体之外（不能使用static来修饰）</li><li>定义个数：任意多个</li><li>执行顺序：从上往下，顺序执行。</li><li>注意事项：<ul><li>创建对象的时候，则就会执行该类中的构造代码块，对象创建了多少次则构造代码块就执行多少次。<ul><li>执行时间：创建对象的时候，则就会执行该类中的构造代码块。</li><li>执行次数：对象创建了多少次，则该类中的构造代码块就执行多少次。</li></ul></li><li>在构造代码块中，我们不但能直接操作当前类的静态内容，并且还能直接操作当前类的成员内容和this。<ul><li>原因：执行代码块的时候，此时对象都已经创建完毕，因此就能操作当前类的成员内容和this。</li></ul></li><li>创建对象的时候，成员变量和构造代码块属于“从上往下，顺序执行”，建议把成员变量定义在构造代码块之前。<ul><li>注意：在构造代码块中，我们“未必”能直接操作当前类的成员变量。</li></ul></li><li><strong>在构造代码块中定义的变量，则该变量就只能在当前作用域中使用，不能在代码块之外使用。</strong></li><li>使用场合：开发中，我们偶尔会在构造代码块中完成对成员变量的初始化操作。（不常见）<ul><li>可以将各个构造方法中公共的代码提取到构造代码块。</li><li>匿名内部类不能提供构造方法，此时初始化操作可以放到构造代码块中。</li></ul></li></ul></li></ol></li><li><p><strong>静态代码块、构造代码块和构造方法执行顺序？</strong></p><p>–&gt; 静态代码块 &gt; 构造代码块 &gt; 构造方法</p></li></ol><h4 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h4><ol><li><p>包的作用</p><ul><li>我们使用包来管理类，也就是类应该放在包中。</li><li><strong>包的出现，为类提供了多层的命名空间，也即是类的完整名字为”包名.类名”。</strong></li><li>注意：不同的包中，我们可以定义同名的类；同一个包中，我们不允许定义同名的类。</li></ul></li><li><p>如何定义包</p><ul><li><p>包名必须满足“标识符”的命名规则，必须满足<strong>“单词全部小写，多个单词之间以’.’链接，并且做到顶级域名倒着写”</strong>的命名规范。</p></li><li><p><strong>问题：以下两个包是否存在父子关系？【没有】</strong></p><p>–&gt; com.bjpowernode.demo com.bjpowernode.demo.test</p></li></ul></li><li><p>如何使用包</p><p>–&gt; <strong>在源文件有效代码第一行，使用package关键字来声明当前源文件中的类在那个包中。</strong></p><p>注意：通过IDEA新建的源文件，则源文件有效代码的第一行默认就有包声明；<strong>如果通过DOS命令来运行IDEA创建的源文件，则必须删除源文件中的包声明。</strong></p></li><li><p>java语言提供的包</p><ul><li><strong>java.lang 包含一些java语言的核心类，如String、Math、System等；</strong></li><li>java.awt 包含了构成抽象窗口工具集(abstract window toolkits)的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)；</li><li>java.net 包含执行与网络相关的操作的类；</li><li>java.io 包含能提供多种输入、输出功能的类；</li><li>java.util 包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。</li></ul></li><li><p><strong>类的访问方式</strong></p><ul><li><p><strong>简化访问</strong></p><ul><li><p>解释：当我们需要访问“java.lang”或“当前包”中的类时，则就可以直接使用“类名”来实现简化访问。</p></li><li><p>例如：访问“当前包”中的类</p><p>–&gt; Tiger tiger &#x3D; new Tiger(“老虎”, 18);</p></li><li><p>例如：访问“java.lang”中的类</p><p>–&gt; String str &#x3D; “hello world”;</p></li></ul></li><li><p><strong>带包名访问</strong></p><ul><li><p>解释：当我们需要访问“当前包”之外的类时（排除java.lang包中的类），则我们就必须通过“包名.类名”的方式来访问。</p></li><li><p>例如：访问”p1包”中的类</p><p>–&gt; com.bjpowernode.p1.staticblock.student stu &#x3D; new com.bjpowernode.p1.staticblock.student();</p></li><li><p>例如：访问“java.util”中的类</p><p>–&gt; java.util.Scanner input &#x3D; new java.util.Scanner(System.in);</p></li></ul></li></ul></li><li><p><strong>import关键字的概述</strong></p><ul><li><p><strong>解释：当我们需要访问“当前包”之外的类（排除java.lang包中的类），则必须通过“带包名”的方式来访问，则此访问方式太麻烦，想要实现简化访问，则就可以先通过import关键字导入需要访问的类，然后再通过“类名”来实现简化访问。</strong></p></li><li><p>例如：访问“p1包”中的类</p><p>–&gt; import com.bjpowernode.p1.staticblock.student;</p><p>–&gt; Student stu &#x3D; new Steudent();</p></li><li><p>例如：访问”java.util”中的类</p><p>–&gt; import java.util.Scanner;</p><p>–&gt; Scanner input &#x3D; new Scanner(System.in);</p></li></ul></li><li><p><strong>import关键字的注意点</strong></p><ul><li><p><strong>如果需要使用某个包中的多个类时，则我们可以通过”*”通配符来导入这个包中的所有类。</strong></p><p>–&gt; 注意：开发中，不建议使用“*”来导入某个包中的所有类，因此此方式效率非常低。</p></li><li><p><strong>如果需要使用不同包中的同名类时，则其中一个类必须通过“带包名”的方式来访问。</strong></p><p>–&gt; 原因：通过import关键字导入多个不同包的同名类，则在源文件中使用导入的类时，无法区分。</p></li><li><p><strong>在JDK1.5之后，还新增了静态导入，也就是能导入某个类中的静态属性和静态方法。</strong></p><p>–&gt; 例如：导入Math类中的静态属性</p><ol><li>第一步：import static java.lang.Math.PI;</li><li>第二步：System.out.println(PI);</li></ol><p>–&gt; 例如：导入Math类中的静态属性和静态方法</p><ol><li>第一步：import static java.lang.Math.*;</li><li>第二部：System.out.println(PI);</li></ol></li></ul></li></ol><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ol><li><p>问题：具备那三大特性的编程语言，我们才称之为面向对象语言？</p><p><strong>–&gt; 封装、继承、多态</strong></p></li><li><p><strong>封装的引入</strong></p><ul><li><p>问题1：给学生年龄赋值的时候，赋值的年龄不能为负数！</p><p>–&gt; 使用“setter和getter”方法来解决</p></li><li><p>问题2：<strong>相同的代码在不同的包中，可能会发生编译错误！</strong></p><p>–&gt; 使用“权限修饰符”来解决</p></li></ul></li><li><p><strong>编程中的封装</strong></p><ul><li><strong>核心：对于使用者而言，只需掌握其公开的访问方式，无需了解内部的具体实现细节。</strong></li></ul></li><li><p><strong>封装的层次</strong></p><ul><li>面向过程：对功能做的封装，也就是使用方法来完成的封装。</li><li><strong>面向对象：对数据和功能做的封装，也就是使用类来完成的封装。</strong></li></ul></li><li><p><strong>封装的好处</strong></p><ul><li>封装的出现，提高了代码的安全性【了解】。</li><li><strong>封装的出现，提高了代码的复用性【核心】。</strong></li></ul></li></ol><h4 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h4><ol><li><p>private，私有的，权限：只能在“<strong>当前类</strong>”中访问，因此我们称之为“类可见性”。</p></li><li><p>default，<strong>默认的，权限：</strong>只能在“<strong>当前类 + 当前包</strong>”中访问，因此我们称之为“包可见性”。</p><p>–&gt; 注意：在权限修饰符中，没有default关键字，省略权限修饰符默认就是包可见性。</p></li><li><p>protected，受保护的，权限：只能在“<strong>当前类 + 当前包 + 别的包中的子类包</strong>”中访问，因此我们称之为“子类可见性”。</p></li><li><p>public，公开的，权限：只能在“<strong>当前类 + 当前包 + 加别的包</strong>”中访问，因此我们称之为“项目可见性”。</p></li></ol><ul><li><strong>权限大小【由低到高】：private &lt;&lt; default &lt;&lt; protected &lt;&lt; public</strong></li></ul><h4 id="权限修饰符的使用"><a href="#权限修饰符的使用" class="headerlink" title="权限修饰符的使用"></a>权限修饰符的使用</h4><ul><li><p><strong>明确：实际开发中，“默认的”和“受保护的”很少使用，但是“私有的”和“公开的”却很常用。</strong></p></li><li><p><strong>private：default、protected和public都能修饰”成员变量”和“静态变量”。</strong></p><p>–&gt; 成员变量：因为存储都是“特殊数据”，因此使用private修饰。</p><p>–&gt; 静态变量：因为存储是“共享数据”，因此使用public来修饰。</p></li><li><p><strong>private：default、protected和public都能修饰”成员方法”和“静态方法”。</strong></p><p>–&gt; 如果该方法需要外界访问，则就把该方法使用public来修饰。</p><p>–&gt; 如果该方法无需外界访问，也就是只为当前类服务，那么久把该方法使用private来修饰。</p></li><li><p><strong>private：default、protected和public都能修饰“构造方法”。</strong></p><p>–&gt; 如果该类需要被外界实例化，则该类的构造方法就采用public来修饰;</p><p>–&gt; 如果该类无需被外界实例化，则该类的构造方法就采用private来修饰。</p><p><strong>注意：工具类中只有静态内容，因此工具类就无需被实例化，那么工具类的构造方法都采用了private修饰，eg：Arrays和Math等等。</strong></p></li><li><p><strong>定义类的时候，类只允许使用public和default，不允许使用private和protected来修饰。</strong></p><p>–&gt;使用public修饰的类（公开权限），则该类就能在整个项目中使用。</p><p>–&gt; 使用default修饰的类（默认权限），则该类就只能在当前包中使用。</p></li><li><p><strong>使用权限修饰符，则不允许修饰局部变量、局部代码块、静态代码块和构造代码块。</strong></p></li></ul><h4 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h4><ol><li>setter和getter方法的概述<ul><li>成员变量一律私有化（private），避免外界直接去访问成员变量，然后提供公开的setter和getter方法来操作私有的成员变量。</li></ul></li><li><strong>setter方法的概述</strong><ul><li>作用：用于给私有的成员变量做<strong>赋值操作</strong>，<strong>并且还能对赋值的数据做检查和处理。</strong></li></ul></li><li><strong>getter方法的概述</strong><ul><li>作用：<strong>用于获取私有成员变量的值（取值操作），并且还能对获得的数据做统一的处理。</strong></li></ul></li><li><strong>setter和getter的注意点</strong><ul><li>通过构造方法给成员变量赋值，如果赋值的数据需要做检查和处理，则在构造方法中就必须调用setter方法来实现赋值操作。</li><li><strong>给boolean类型成员变量提供getter方法的时候，此时getter方法的名字前缀必须是“is”开头，而不是能以“get”来开头。</strong></li><li><strong>给类提供“构造方法”和“setter和getter方法”的时候，则建议使用“alt + insert”快捷键来实现，而不建议手动写代码来实现。</strong></li></ul></li></ol><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ol><li><p><strong>继承的引入</strong></p><ul><li>问题：讲师类和学生类中都有相同的name和age两个成员变量，都有相同的eat()和sleep()两个成员方法，因此需要实现代码的复用。</li><li>解决：使用“继承”来实现。</li></ul></li><li><p><strong>继承的本质</strong></p><ul><li>就是提取一系列类中相同的成员变量和成员方法，这样就得到了一个父类，从而形成了继承关系。</li><li>即：<strong>向上提取。</strong></li></ul></li><li><p><strong>继承语法</strong></p><pre class="line-numbers language-Java"><code class="language-Java">[修饰符] class 父类{}[修饰符] class 子类 extends 父类{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>继承的特点</strong></p><ul><li>子类不但能继承父类的成员变量和成员方法，并且子类还可以有自己特有的成员变量和成员方法。</li><li>即：<strong>子类对父类做的扩展。</strong></li></ul></li><li><p><strong>继承的好处</strong></p><ul><li>继承的出现，提高了代码的复用性，从而提高了开发的效率。</li><li>继承的出现，让类与类之间产生了联系，为后面学习“多态”打下了技术铺垫。</li><li><strong>强调：继承是一把“双刃剑”，父类代码一旦发生了变化，则就会影响所有的子类，使用继承的时候慎重。【高耦合】</strong></li></ul></li><li><p><strong>哪些内容子类不能继承</strong></p><ul><li>父类私有的内容，子类不能继承。</li><li>父类的构造方法，子类不能继承。</li><li><strong>父类静态的内容，虽然子类能够使用，但父类静态内容“不参与”继承。</strong></li><li><strong>强调：继承强调的是“对象”之间的关系，因此成员内容能参与继承，但是静态内容不参与继承。</strong></li></ul></li><li><p><strong>继承的注意点</strong></p><ul><li><p><strong>java语言采用的是“单继承”，C++语言采用的是“多继承”。</strong></p><ul><li><strong>单继承：</strong>一个子类只能有一个直接父类。</li><li><strong>多继承：</strong>一个子类可以有多个直接父类。</li></ul></li><li><p>AA类继承于BB类，BB类继承于CC类，CC类继承于DD类，。。。，从而就形成了“继承链”。</p><p>–&gt; 此处BB类，CC类和DD类都是AA类的“父类”，<strong>只有BB类属于AA类的“直接父类”。</strong></p></li><li><p><strong>java语言中，一个子类只能有一个直接父类，但是一个父类可以有多个直接子类。</strong></p></li><li><p><strong>如果一个类没有显式地使用extends关键字，则该类就默认继承于”java.lang.Object”类。</strong></p><p>–&gt; <strong>所有的java类都可以使用object类提供的方法。【最终继承的都是object类】</strong></p></li></ul></li></ol><h4 id="方法重写（方法复写，override）"><a href="#方法重写（方法复写，override）" class="headerlink" title="方法重写（方法复写，override）"></a>方法重写（方法复写，override）</h4><ol><li><p><strong>方法重写的引入</strong></p><ul><li>eg：智能机是对功能机做的扩展，也就是应该让“智能机类”继承于“功能机类”，也就意味着“父类”和“子类”中都有show()方法，从而就形成了“方法重写”。</li></ul></li><li><p><strong>什么是方法重写呢？</strong></p><ul><li>在子类中，我们定义一个和父类“几乎”一模一样的方法，这就形成了“方法重写”。</li></ul></li><li><p><strong>什么时候使用方法重写？</strong></p><ul><li>当父类提供的方法无法满足子类的需求，则在子类中就可以重写父类提供的方法，从而满足开发的需求。</li></ul></li><li><p><strong>父类的哪些方法子类不能重写？</strong></p><ul><li>父类的构造方法，子类不能重写。</li><li>父类的静态方法，子类不能重写。</li><li>父类私有的成员方法，子类不能重写。</li></ul></li><li><p><strong>方法重写的注意点</strong></p><ul><li><p>通过子类对象来调用重写方法，则默认调用的是子类重写的方法，而不是调用父类被重写的方法。</p></li><li><p>保证子类的某个方法肯定是重写方法，则可以在该方法声明之前添加“@Override”注解，从而保证该方法肯定是重写方法。</p><p>–&gt; 如果某个方法声明之前添加了“@Override”注解，则该方法就必须是重写方法，否则就会编译错误。</p></li><li><p><strong>在子类重写方法中，如果想要调用父类被重写的方法，则必须通过super关键字来调用（this和super使用类似）</strong></p></li></ul></li><li><p><strong>方法重写的具体要求</strong></p><ul><li><p><strong>&#x3D;&#x3D;，子类重写方法的“方法名”和“形参列表”必须和父类被重写方法的“方法名”和“形参列表”相同。</strong></p><p>–&gt; 此处“形参列表”必须相同，指的是“形参个数”和“形参类型”必须相同，<strong>形参名字不同不影响。</strong></p></li><li><p><strong>“&gt;&#x3D;”，子类重写方法的修饰符权限必须大于等于父类被重写方法的修饰符权限【权限】。</strong></p><p>–&gt; 修饰符权限：public &gt; protected &gt; default &gt; private</p><p><strong>–&gt; 注意：子类就不能重写父类采用了static或private来修饰的方法。</strong></p></li><li><p><strong>“&lt;&#x3D;”，子类重写方法的“返回值类型”必须小于等于父类被重写方法的“返回值类型”【辈分】。</strong></p><p>–&gt; 如果父类被重写方法的返回值类型为void、基本数据类型和String类型，则子类重写方法的返回值类型必须和父类被重写方法的返回值类型保持一致（&#x3D;&#x3D;）。</p><p>–&gt; 如果父类被重写方法的返回值类型为引用数据类型（排除String类型），则子类重写方法的返回值必须小于等于被重写方法的返回值类型。（&lt;&#x3D;，辈分）。</p></li></ul></li></ol><h4 id="方法重载和方法重写的区别"><a href="#方法重载和方法重写的区别" class="headerlink" title="方法重载和方法重写的区别"></a>方法重载和方法重写的区别</h4><ol><li><p><strong>整体区别</strong></p><ul><li><p>英文名字区别</p><p>方法重载：overload</p><p>方法重写：override</p></li><li><p>使用位置区别</p><p>方法重载：同一个类中使用。</p><p>方法重写：<strong>必须在继承体系中使用。</strong></p></li><li><p>具体作用区别</p><p>方法重载：允许在同一类中定义多个同名的方法，从而避免了方法名被污染。</p><p>方法重写：父类提供的方法如果无法满足子类需求，则子类就可以重写父类提供的方法。</p></li><li><p>修饰符的区别</p><p>方法重载：修饰符不同，不构成方法重载。</p><p>方法重写：<strong>子类重写方法的“修饰符权限”必须大于等于父类被重写方法的“修饰符权限”【权限】。</strong></p></li><li><p>返回值类型的区别</p><p>方法重载：返回值类型不同。不构成方法重载。</p><p>方法重写：<strong>子类重写方法的“返回值类型”必须小于等于父类被重写方法的“返回值类型”【辈分】。</strong></p></li><li><p>方法名的区别</p><p>方法重载：方法名必须相同。</p><p>方法重写：方法名必须相同。</p></li><li><p><strong>形参列表的区别</strong></p><p>方法重载：<strong>形参个数不同 或 形参类型不同，形参名字不同不影响。</strong></p><p>方法重写：<strong>形参个数 和 形参类型必须相同。</strong></p></li></ul></li></ol><h4 id="重写toString-方法（理解）"><a href="#重写toString-方法（理解）" class="headerlink" title="重写toString()方法（理解）"></a>重写toString()方法（理解）</h4><ol><li><strong>请问print()和println()方法的作用</strong><ul><li><strong>通过输出语句，都能把输出的内容转化为字符串类型，然后把转化为字符串类型的结果输出到控制台。</strong></li></ul></li></ol><h4 id="super关键字-重点"><a href="#super关键字-重点" class="headerlink" title="super关键字(重点)"></a>super关键字(重点)</h4><ol><li><p><strong>super关键字的概述</strong></p><ul><li>创建一个对象成功之后，则虚拟机就会动态地创建一个引用，该引用指向的就是“新创建出来的对象”，并且该引用的名字就是this。</li><li>创建一个子类对象成功之后，则虚拟机还会动态创建一个引用，该引用指向的就是“当前对象的直接父类对象”，并且该引用的名字就是super。</li><li>总结：this指的就是“当前对象”，super指的就是“当前对象的直接父类对象”。并且this可以单独使用，但是super不能单独使用。</li></ul></li><li><p><strong>super关键字的作用</strong></p><ul><li><strong>强调：this和super指的都是“对象”，并且this和super使用场合是相同的（构造方法、成员方法和构造代码块）。</strong></li><li>操作父类的成员变量，语法： super.父类成员变量名</li><li>调用父类的成员方法，语法：super.父类成员方法(实参列表);</li><li>调用父类的构造方法，语法：super(实参列表);</li></ul></li><li><p><strong>this和super的区别</strong></p><ul><li>this的特点：先在当前类找，找不到再去父类找。</li><li>super的特点：直接去父类找，而不会在当前类找。</li></ul></li><li><p><strong>super关键字的注意点</strong></p><ul><li><p>在子类重写方法中，如果想要调用父类被重写的方法，则必须通过super关键字来实现。</p></li><li><p>当局部变量，子类的成员变量和父类的成员变量同名的时候，则该如何去区分呢？</p><p><strong>局部变量采用“就近原则”，子类成员变量通过“this”来操作，父类成员变量通过“super”来操作。</strong></p></li><li><p><strong>父类私有的成员变量，在子类中即使使用super关键字也无法操作，只能通过setter和getter方法来操作父类私有成员变量。</strong></p></li></ul></li></ol><h4 id="super-实参列表-的概述"><a href="#super-实参列表-的概述" class="headerlink" title="super(实参列表)的概述"></a>super(实参列表)的概述</h4><ul><li><strong>在子类构造方法中，如果想要显式地调用父类的某个构造方法，则必须通过“super(实参列表)”来实现，从而实现了代码的复用。</strong></li><li><strong>在子类构造方法中，如果没有显式地调用别的构造方法，则默认就会调用父类的无参构造方法，也就是编译时会默认添加“super();”语句。</strong></li></ul><h4 id="super-实参列表-的注意点"><a href="#super-实参列表-的注意点" class="headerlink" title="super(实参列表)的注意点"></a>super(实参列表)的注意点</h4><ul><li><strong>“super(实参列表)”只能存在于构造方法中，并且必须在构造方法有效代码的第一行。</strong></li><li><strong>建议每个类都应该有自己的无参构造方法，避免在继承体系中子类找不到父类的无参构造方法。</strong></li></ul><h4 id="this-实参列表-和super-实参列表-的区别"><a href="#this-实参列表-和super-实参列表-的区别" class="headerlink" title="this(实参列表)和super(实参列表)的区别"></a>this(实参列表)和super(实参列表)的区别</h4><ul><li>this(实参列表)的特点：<strong>调用“当前类”的别的构造方法，并且必须在构造方法有效代码的第一行。</strong></li><li>super(实参列表)的特点：<strong>调用“父类”中的某个构造方法，并且必须在构造方法有效代码的第一行。</strong></li><li>结论：<strong>因为“this(实参列表)”和“super(实参列表)”都必须在构造方法有效代码的第一行，因此构造方法中不允许同时存在“this(实参列表)”和“super(实参列表)”。</strong></li></ul><h4 id="继承体系下，创建子类对象的步骤分析"><a href="#继承体系下，创建子类对象的步骤分析" class="headerlink" title="继承体系下，创建子类对象的步骤分析"></a>继承体系下，创建子类对象的步骤分析</h4><ol><li>第一步：加载类（先加载父类，后加载子类）<ul><li>先执行父类的静态代码块，然后执行子类的静态代码块。</li></ul></li><li>第二步：创建对象（先创建父类对象，后创建子类对象）<ul><li>首先，执行父类的构造代码块，接着执行父类的构造方法。</li><li>然后，执行子类的构造代码块，接着执行子类的构造方法。</li></ul></li></ol><h4 id="继承体系下，创建子类对象的内存分析"><a href="#继承体系下，创建子类对象的内存分析" class="headerlink" title="继承体系下，创建子类对象的内存分析"></a>继承体系下，创建子类对象的内存分析</h4><ul><li><strong>创建一个子类对象，则默认还会创建他的父类对象，并且创建的这些对象之间属于“包含”关系。</strong></li><li><strong>也就是说，子类对象中包含了父类对象，那么子类对象和父类对象的“首地址”肯定是相同的。</strong></li></ul><h4 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h4><ol><li>组合的引入<ul><li>需求：有一台电脑，电脑中包含鼠标、键盘和CPU等。</li><li>实现：定义电脑类（Computer），然后再定义鼠标类（Mouse）、键盘类（KeyBoard）和CPU类（CPU），然后把鼠标、键盘和CPU作为电脑类的“成员变量”即可，这就形成了“组合”关系。</li></ul></li><li>继承和组合<ul><li>相同点<ul><li><strong>都能让类与类之间产生联系，都能实现代码的复用。</strong></li></ul></li><li>不同点<ul><li><strong>继承描述的是“is a”的关系</strong>，例如：Tiger is Animal, Student is a Person等等。</li><li><strong>组合描述的是“has a”的关系</strong>，例如：Computer has a Mouse,Computer has a keyBoard等等。</li></ul></li></ul></li></ol><h4 id="final关键字的概述"><a href="#final关键字的概述" class="headerlink" title="final关键字的概述"></a>final关键字的概述</h4><ol><li>final关键字的含义<ul><li>最终的、不可变的</li></ul></li><li>final关键字能修饰的内容？<ul><li>final关键字能修饰类、变量（局部变量、成员变量和静态变量）和方法（成员方法和静态方法），但是不能修饰构造方法和代码块。</li></ul></li></ol><h4 id="final关键字的特点"><a href="#final关键字的特点" class="headerlink" title="final关键字的特点"></a>final关键字的特点</h4><ol><li><p>使用final关键字修饰的类，</p><p>则该类就不能被继承。</p><ul><li>使用final修饰的类，则改类肯定是一个子类，例如String、Math和System都采用了final修饰。</li></ul></li><li><p>使用final关键字修饰的方法（成员方法和静态方法），则该方法就不能被重写。</p><ul><li>如果某个成员方法不想被子类重写，则该方法就采用final来修饰即可，例如Object类中的很多方法都采用了final修饰。</li></ul></li><li><p>使用final关键字修饰的变量（局部变量、成员变量和静态变量），则该变量就变为常量了。</p><ul><li>常量名必须符合“标识符”的命名规则，必须符合“字母全部大写，多个单词之间以下划线连接”的命名规范。</li><li>使用final修饰的静态变量，要么做显式初始化，要么在静态代码块中初始化，否则就会编译错误。</li><li>使用final修饰的成员变量，要么做显式初始化，要么在构造代码块中初始化，要么在构造方法中初始化，否则就会编译错误。</li></ul></li><li><p><strong>使用final关键字，我们不能修饰构造方法、局部代码块、构造代码块和静态代码块。</strong></p></li></ol><h4 id="final修饰引用数据类型变量的特点"><a href="#final修饰引用数据类型变量的特点" class="headerlink" title="final修饰引用数据类型变量的特点"></a>final修饰引用数据类型变量的特点</h4><ul><li><strong>引用数据类型的变量采用final修饰后，则该变量就变为常量了，因此常量保持的地址值不能更改，但是该常量指向堆内存中的成员变量值可以更改。</strong></li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li><p><strong>使用多态的前提？</strong></p><ul><li><p><strong>前提1：继承是实现多态的前提。</strong></p><p>–&gt; 让所有的动物类都继承于Animal类，也就是Animal类是所有动物类的父类！</p></li><li><p><strong>前提2：子类必须重写父类方法。</strong></p><p>–&gt; 所有的动物类都重写了Animal类的eat()方法，毕竟每个动物吃的东西都不同。</p></li><li><p><strong>前提3：父类引用指向子类对象。</strong></p><p>–&gt; Admin类中的feedAnimal()方法的形参为“Animal”类型，调用该方法时的实参为“Animal类的子类对象”，此处就用到了“父类引用指向子类对象”。</p><p>–&gt; 调用feedAnimal()方法的代码为“admin.feedAnimal(new Dog());”，则实现赋值给形参的操作就等效于：Animal animal &#x3D; new Dog();</p></li></ul></li><li><p><strong>使用多态的场合</strong></p><ul><li><p><strong>场合一：方法的形参为父类类型，则实参就可以是该父类的任意子类对象。</strong></p><p>–&gt; 例如：管理员给动物们喂食的案例</p></li><li><p><strong>场合二：返回值类型为父类类型，则返回值就可以是该父类的任意子类对象。</strong></p><p>–&gt; 例如：简单工厂模式的案例</p></li></ul></li></ul><h4 id="多态情况下，操作成员变量的特点"><a href="#多态情况下，操作成员变量的特点" class="headerlink" title="多态情况下，操作成员变量的特点"></a>多态情况下，操作成员变量的特点</h4><ol><li>编译时：检查“编译时类型”，也就是检查编译时类型中是否有该成员变量。</li><li>运行时：检查“编译时类型”，也就是操作了编译时类型中的成员变量。</li><li><strong>总结：多态情况下操作成员变量，则编译和运行都检查“编译时类型”。</strong></li></ol><h4 id="abstract的引入"><a href="#abstract的引入" class="headerlink" title="abstract的引入"></a>abstract的引入</h4><ol><li>需求：在动力节点中，有讲师和助教两个工种，他们都具备工作的能力。</li><li>实现：定义讲师类（Teacher）和助教类（Assistant），然后分别提供work()的方法。</li><li>问题：讲师类和助教类都有work()方法，也就是讲师类和助教类都有相同的代码，因此我们需要实现代码的复用。</li><li>解决：使用“继承”来实现。定义一个员工类（Employee），并且给员工类提供work()方法，然后让讲师类和助教类继承于员工类，并重写员工类中的work()方法。</li><li>问题1：世界上没有任何一个工种就叫做员工，因此员工类不应该被实例化！<ul><li>–&gt; 使用“抽象类”来解决，也就是把员工类设置为抽象类即可。</li></ul></li><li>问题2：为了避免讲师和助教偷懒，因为要求讲师类和助教类必须重写员工类的work()方法！<ul><li>–&gt; 使用“抽象方法”来解决，也就是把员工类的work()方法设置为抽象方法。</li></ul></li></ol><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ol><li><p>什么是抽象类</p><ul><li><strong>使用abstract关键字修饰的类，则我们就称之为“抽象类”。</strong></li></ul></li><li><p><strong>抽象类的组成</strong></p><ul><li>a)在抽象类中，依旧可以拥有成员变量和静态变量。</li><li>b)在抽象类中，依旧可以拥有成员方法和静态方法，<strong>并且还可以有任意多个抽象方法。</strong></li><li>c)在抽象类中，依旧可以拥有构造方法，该构造方法用于给抽象类中的成员变量做指定初始化操作。</li><li>d)在抽象类中，依旧可以拥有构造代码块和静态代码块。</li><li><strong>总结：抽象类就是一个特殊的类，抽象类对比普通类新增了任意多个抽象方法。</strong></li></ul></li><li><p><strong>抽象类的特点</strong></p><ul><li><p><strong>a)抽象类不能被实例化，因为抽象类中包含了抽象方法。</strong></p></li><li><p>b)抽象类肯定是一个父类，<strong>只有实现类“实现”了抽象类中的所有抽象方法，则该实现类才能被实例化，否则该实现类就是一个抽象类。</strong></p><p><strong>实现：子类重写父类的抽象方法，我们就称之为“实现”。</strong></p><p>重写：子类重写父类的普通方法，我们就称之为“重写”。</p></li><li><p><strong>c)抽象类可以作为方法的“形参类别”和“返回值类型”，也就是抽象类也可以实现多态。</strong></p></li><li><p><strong>d)实现类与抽象类之间属于“extends”的关系，并且属于“单继承”。</strong></p></li></ul></li></ol><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><ol><li>什么是抽象方法？<ul><li><strong>使用abstract关键字修饰的方法，我们就称之为“抽象方法”。</strong></li></ul></li><li>抽象方法的特点<ul><li>a)抽象方法<strong>只有方法声明</strong>，没有方法内部的具体实现，也就是<strong>没有方法体。</strong></li><li><strong>b)抽象方法只能存在于“抽象类”和“接口”中，不能存在于“普通类”中。</strong></li></ul></li><li>关于abstract关键字的补充？<ul><li>a)<strong>请问abstract关键字和哪一个关键字是反义词？</strong>？？final</li><li>b)<strong>请问abstract关键字不能和哪些关键字共存呢？</strong>？？final、private、static</li></ul></li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h4 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h4><ol><li>接口的引入<ul><li>需求：让飞机、炮弹、小鸟和超人进行飞行表演！</li><li>实现：定义飞机类（Plane）、炮弹类（Peng）、小鸟类（Bird）和超人类（SuperMan），然后为每个类提供showFly()的方法。</li><li>问题：飞机类、炮弹类、小鸟类和超人类都有showFly()方法，也就是这些类中有相同的代码，那么我们就需要实现代码的复用，如何实现？</li><li>解决：使用“继承”来解决。定义一个Flyable类，然后给Flyable类提供showFly()的方法，接着让飞机类、炮弹类、小鸟类和超人类“继承”于Flyable类，并重写Flyable类中的showFly()方法。</li><li>问题：继承描述的是“is a”的关系，也就是描述“相同体系”的基本行为，此处飞机、炮弹、小鸟和超人属于不同体系，因此使用继承不合适</li><li>解决：使用“接口”来解决。定义一个Flyable接口，然后给Flyable接口提供showFly()方法，接着让飞机类、炮弹类、小鸟类和超人类“实现”于Flyable接口，并实现Flyable接口中的showFly()方法。</li><li><strong>总结：接口描述的是“is like a”的关系，也就是描述“不同体系”的相同行为，此处飞机、炮弹、小鸟和超人属于不同体系，因此使用接口很合适。</strong></li></ul></li></ol><h4 id="接口的概述"><a href="#接口的概述" class="headerlink" title="接口的概述"></a>接口的概述</h4><ol><li><p>接口的定义</p><ul><li><strong>明确：接口使用interface关键字来修饰，并且interface和class属于平级的，因此interface和class不能共存！</strong></li></ul></li><li><p>接口的组成</p><ul><li><p>a)接口中的<strong>属性</strong>，<strong>默认全部是“全局静态常量”，也就是默认使用了“public static final”来修饰。</strong></p></li><li><p>b)接口中的<strong>方法，默认全部是“全局抽象方法”，也就是默认使用了“public abstract”来修饰。</strong></p><p><strong>在JDK1.8之后，接口中还新增了“全局静态方法”和“default修饰的全局默认方法”。</strong></p></li><li><p>c)<strong>在接口中，不允许存在构造方法，因为接口中都没有成员变量，因此就无需存在构造方法。</strong></p></li><li><p><strong>d)在接口中，不允许存在静态代码块和构造代码块。</strong></p></li></ul></li><li><p>接口的特点</p><ul><li>a)<strong>接口不能被实例化，因为接口中存在抽象方法，并且接口中没有构造方法。</strong></li><li>b)<strong>接口可以作为方法的“形参类型”和“返回值类型”</strong>，也就是<strong>接口能够实现多态。</strong></li><li>c)接口与接口之间属于“extends”的关系，并且<strong>接口还属于“多继承”。</strong></li><li>d)<strong>抽象方法只能存在于“抽象类”和“接口”中，不能存在于“普通类”中。</strong></li></ul></li></ol><h4 id="实现类的概述"><a href="#实现类的概述" class="headerlink" title="实现类的概述"></a>实现类的概述</h4><ol><li><p>实现类的定义</p><ul><li>明确：<strong>实现类和接口之间属于“implements”的关系，而不是属于“extends”的关系。</strong></li></ul></li><li><p>实现类的特点</p><ul><li>a)<strong>实现类只有“实现”了接口中的所有抽象方法，则该实现类才能被实例化，否则该实现类就是一个抽象类。</strong></li><li>b)<strong>实现类可以先继承一个父类，然后再去实现多个接口，实现多个接口的操作我们就称之为“接口的多实现”。</strong></li></ul></li><li><p>抽象类和接口的总结</p><ol><li><p>普通类、抽象类和接口的特点</p><ul><li><strong>接口的抽象程度最高，抽象类的抽象程度次之，普通类的抽象程度最低。</strong></li></ul></li><li><p>抽象类和接口的对比</p><ul><li><p>相同点</p><ol><li>都是向上提取的结果，因此都不能被实例化。</li><li>都是向上提取的结果，因此都包含了抽象方法。</li></ol></li><li><p>不同点</p><ol><li><p>接口与接口之间属于“extends”的关系，并且属于“多继承”。</p><p>抽象类与抽象类之间属于“extends”的关系，并且属于“单继承”。</p></li><li><p>实现类与接口之间属于“implements”的关系，并且属于“多实现”。</p><p>实现类与抽象类之间属于“extends”的关系，并且属于“单继承”。</p></li><li><p>接口描述的是“is like a”的关系，也就是描述“不同体系”的相同行为。</p><p>抽象类描述的是“is a”的关系，也就是描述“相同体系”的基本行为。</p></li><li><p>接口中只有“全局静态常量”和“全局抽象方法”，JDK1.8之后新增了“全局静态方法”和“default修饰的全局默认方法”。</p><p>抽象类就是一个特殊类，抽象类对比普通类新增了任意多个抽象方法。</p></li></ol></li></ul></li></ol></li></ol><h4 id="单继承和多继承的概述？"><a href="#单继承和多继承的概述？" class="headerlink" title="单继承和多继承的概述？"></a>单继承和多继承的概述？</h4><ol><li>单继承：java、C#等等<ul><li>解释：一个子类只能有一个直接父类，类似于一个儿子只有一个亲爹。</li><li>优势：简单、安全。</li><li>劣势：只能继承一个父类的内容，则子类功能不够强大。</li></ul></li><li>多继承：C++<ul><li>解释：一个子类可以有多个直接父类，类似于一个儿子可以有多个亲爹。</li><li>优势：可以继承多个父类的内容，则子类功能非常强大。</li><li>劣势：复杂、不安全。</li></ul></li></ol><h4 id="接口的多实现的概述"><a href="#接口的多实现的概述" class="headerlink" title="接口的多实现的概述"></a>接口的多实现的概述</h4><ol><li>需求：要求子类不但简单又安全，同时还要求子类功能非常强大，如何实现？<ul><li>不但要集合单继承和多继承的优势，并且还要摒弃单继承和多继承的劣势。</li><li><strong>实现：先让子类继承于某个父类，然后再让该子类实现多个接口，实现多个接口的操作就称之为“接口的多实现”。</strong></li><li>通过以上的实现方式，我们就模拟了C++的多继承操作，并且还摒弃了C++多继承的劣势。</li></ul></li></ol><h4 id="内部类的概述"><a href="#内部类的概述" class="headerlink" title="内部类的概述"></a>内部类的概述</h4><ol><li><p>什么是内部类</p><ul><li><strong>在OutClass类的内部，我们再定义InnerClass类就是内部类。</strong></li></ul></li><li><p>内部类的定义位置？</p><ul><li>位置一：在类中，代码块或方法体的内部。</li><li>位置二：在类中，代码块和方法体的外部。</li></ul></li><li><p>什么时候使用内部类？</p><ul><li>描述一个事物的时候，我们发现该事物内部还有别的事物，此时就可以使用内部类来实现。</li><li>例如：描述小汽车的时候，我们发现小汽车内部还有发动机，此时的发动机就是一个内部类。</li></ul></li><li><p>内部类的分类？</p><ul><li><strong>成员内部类（掌握）</strong>、<strong>静态内部类（掌握）</strong>、局部内部类（了解）和<strong>匿名内部类（重点）</strong>。</li></ul></li><li><p>内部类编译的特点？</p><ul><li><p>在OuterClass类的内部，我们再定义InnerClass类，此时我们对程序进行编译，<strong>则就会获得两个字节码文件</strong></p><p>–&gt; <strong>OuterClass.class</strong> 外部类的字节码文件，也就是OuterClass类的字节码文件</p><p>–&gt; <strong>OuterClass$InnerClass.class</strong> 内部类的字节码文件，也就是InnerClass类的字节码文件</p></li></ul></li><li><p>操作内部类的特点？</p><ul><li>想要操作内部类，则必须通过外部类来实现，也就是内部类是依附于外部类的。</li></ul></li></ol><h4 id="成员内部类（掌握）"><a href="#成员内部类（掌握）" class="headerlink" title="成员内部类（掌握）"></a>成员内部类（掌握）</h4><p>明确：学习成员内部类的时候，我们建议<strong>把“成员内部类”当成“成员变量”来理解。</strong></p><ol><li><p>定义位置</p><ul><li>在类中，代码块和方法体之外。</li></ul></li><li><p>定义语法</p><ul><li><pre class="line-numbers language-Java"><code class="language-Java">[修饰符] class 外部类{    //成员内部类    [修饰符] class 内部类{    //内部类中的代码    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>成员内部类的实例化方式？</p><ul><li>情况一：<strong>在外部类的内部，我们实例化成员内部类对象（掌握）</strong></li><li>情况二：<strong>在外部类的外部，我们实例化成员内部类对象。（了解）</strong></li></ul></li></ol><h4 id="静态内部类-掌握"><a href="#静态内部类-掌握" class="headerlink" title="静态内部类(掌握)"></a>静态内部类(掌握)</h4><p>明确：学习静态内部类的时候，我们把“静态内部类”当成“静态变量”来理解。</p><ol><li><p>定义位置</p><ul><li>在类中，代码块和方法之外。</li></ul></li><li><p>语法</p><pre class="line-numbers language-Java"><code class="language-Java">[修饰符] class 外部类{    //静态内部类    [修饰符] static class 内部类{        //书写静态内部类的代码    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注意事项</p><ul><li><p>a)定义静态内部类的时候，我们可以使用private、protected、public、final和abstract来修饰，并且还<strong>必须使用static来修饰</strong></p></li><li><p>b)在静态内部类中，我们不但能定义成员变量、成员方法、构造方法和构造代码块，并且还<strong>能定义静态变量、静态方法和静态代码块。</strong></p></li><li><p>c)<strong>想要操作静态内部类，则直接通过外部类名来操作即可</strong>，因为静态内部类是依附于外部类的，此处联想“静态变量”来理解即可。</p><p><strong>在外部类的成员位置，我们可以直接操作当前类中的静态内部类；在外部类的静态位置，我们可以直接操作当前类中的静态内部类。</strong></p></li><li><p>d)<strong>在静态内部类中，我们可以直接操作外部类的静态变量和静态方法，但是不能直接操作外部类的成员变量和成员方法。</strong></p><p>静态内部类是依附于外部类的，也就是<strong>只要外部类加载完毕，则就能操作当前类中静态内部类。</strong></p></li><li><p>e)想要操作静态内部类中的静态变量和静态方法，则我们还可以通过以下方式来直接操作：</p><ol><li><strong>操作静态变量</strong>：外部类.静态内部类.静态变量名；</li><li><strong>操作静态方法</strong>：外部类.静态内部类.静态方法名(实参列表);</li></ol></li></ul></li><li><p><strong>静态内部类的实例化方式？</strong></p><ul><li><strong>情况一：在外部类的内部，我们实例化静态内部类对象（掌握）</strong></li><li>情况二：在外部类的外部，我们实例化静态内部类对象（了解）</li></ul></li><li><p><strong>成员内部类和静态内部类的总结</strong></p><ul><li><strong>成员内部类：如果内部类需要依附于外部类对象，则该内部类就必须为成员内部类。</strong></li><li><strong>静态内部类：如果内部类只需依附于外部类即可，并且需要在该内部类中定义静态内容，则该内部类就必须定义为静态内部类。</strong></li></ul></li></ol><h4 id="局部内部类（了解）"><a href="#局部内部类（了解）" class="headerlink" title="局部内部类（了解）"></a>局部内部类（了解）</h4><p>明确：学习局部内部类，则我们把“局部内部类”当成“局部变量”来理解。</p><ol><li><p>定义位置</p><ul><li>在类中，代码块或方法体的内部。</li></ul></li><li><p>注意事项</p><ul><li><p>a)定义局部内部类的时候，我们不能使用private、protected、public和static修饰，但是<strong>可以使用final和abstract来修饰。</strong></p></li><li><p>b)在局部内部类中，我们<strong>只能定义成员变量、成员方法、构造方法和构造代码块</strong>，但是<strong>不能定义静态变量、静态方法和静态代码块。</strong></p></li><li><p>c)局部内部类只能在“当前作用域”中使用，不能在代码块或方法体之外使用，此处我们可以联想局部变量的“生命周期”来理解。</p></li><li><p>d)<strong>在局部内部类中，我们“肯定”能操作外部类的静态变量和静态方法，但是“未必”能操作外部类的成员变量和成员方法。</strong></p><p>在局部内部类中，是否能操作外部类的成员变量和成员方法，<strong>关键是看该局部内部类在哪个位置中定义的。</strong></p></li><li><p>e)<strong>在局部内部类中，想要操作外部的局部变量，则该局部变量必须采用final来修饰，从而保证数据的安全性。</strong></p><p><strong>在局部内部类中，如果操作了外部的局部变量，则该局部变量的生命周期就延长了，也就是该局部变量的生命周期和局部内部类对象的生命周期保持一致了。</strong></p></li><li><p><strong>补充：在JDK1.8之后，如果在局部内部类中使用了外部的局部变量，则该局部变量默认就会采用final来修饰，从而保证数据的安全性。</strong></p></li></ul></li></ol><h4 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h4><ol><li><p>匿名内部类的概述</p><ul><li><strong>匿名内部类本质就是一个“局部内部类”，也就是一个“没有名字”的局部内部类，也就是一个特殊的局部内部类。</strong></li></ul></li><li><p>匿名内部类的语法</p><pre class="line-numbers language-Java"><code class="language-Java">[修饰符] class 外部类 {       {            // 位置一：创建一个继承于某个父类的局部内部类对象，该局部内部类没有名字。            // 第一步：定义了一个继承于某个父类的局部内部类，并且该局部内部类没有名字。            // 第二步：创建该局部内部类对象，也就是常见了一个没有名字的局部内部类对象。            new 父类名() {               // 书写匿名内部类中的代码            };       }        [修饰符] 返回值类型 方法名(形参列表) {            // 位置二：创建一个实现于某个接口的局部内部类对象，该局部内部类没有名字。           // 第一步：定义一个实现于某个接口的局部内部类，并且该局部内部类没有名字           // 第二步：创建该局部内部类对象，也就是常见了一个没有名字的局部内部类对象            new 接口名() {                // 书写匿名内部类中的代码            };        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>匿名内部类的注意点</p><ul><li>a)匿名内部类就是一个特殊的局部内部类，因此局部内部类的要求对于匿名内部类依旧生效。</li><li>b)<strong>在匿名内部类中，我们不能定义构造方法，因为匿名内部类都没有类名，而构造方法名必须为类名。</strong></li><li>c)<strong>在匿名内部类中，我们不建议定义自己“特有”的成员变量和成员方法，因为这样不方便我们去操作。</strong></li><li><strong>注意：在匿名内部类中，我们一般用于重写父类或接口中的抽象方法。</strong></li></ul></li></ol><hr><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ol><li><p>包装类的引入</p><ul><li><strong>世界上没有任何一门语言是完全面向对象的，因为面向对象语言中都包含了“基本数据类型”，为了方便“基本数据类型”和“引用数据类型”之间的转换，因此就诞生了“包装类”。</strong></li></ul></li><li><p>包装类的概述？</p><ul><li><p>明确：每一种基本数据类型都对应一个包装类，因此Java语言中提供的包装类至少有8种。</p><pre class="line-numbers language-Java"><code class="language-Java">byte        Byteshort        Shortint          Integerlong        Longfloat        Floatdouble        Doublechar        Characterboolean    Boolean//注意：除了int类型和char类型之外，其余基本数据类型对应的包装类名都是“首字母大写”即可。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Number类的概述</p><ul><li><p>java.lang.Number属于一个抽象类，所有的“数值型包装类”都属于Number的实现类，也就意味着所有的数值型包装类都能使用Number抽象类所提供的方法，并且Number抽象类常见的方法如下：</p><pre class="line-numbers language-Java"><code class="language-Java">public byte byteValue() { ... }       --> 把数值型包装类对象转化为byte类型public short shortValue() { ... }     --> 把数值型包装类对象转化为short类型public abstract int intValue();       --> 把数值型包装类对象转化为int类型public abstract long longValue();     --> 把数值型包装类对象转化为long类型public abstract float floatValue();   --> 把数值型包装类对象转化为float类型public abstract double doubleValue(); --> 把数值型包装类对象转化为double类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul></li><li><p>包装类的作用</p><ul><li><p>作为和基本数据类型对应的类型存在，方便涉及到对象的操作，如Object[]、集合等的操作。</p></li><li><p>包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法(这些操作方法的作用是在基本数据类型、包装类对象、字符串之间提供相互之间的转化)。</p><pre class="line-numbers language-Java"><code class="language-Java">public class Test01 {    public static void main(String[] args) {        System.out.println("int类型表示的最大值：" + Integer.MAX_VALUE);        System.out.println("int类型表示的最小值：" + Integer.MIN_VALUE);        System.out.println("byte类型表示的最大值：" + Byte.MAX_VALUE);        System.out.println("byte类型表示的最小值：" + Byte.MIN_VALUE);        /*// 问题：数组的定义？？？数组就是一个存储“相同数据类型”的“有序”集合（容器）。        // 涉及到的技术：向上转型+自动装箱        Object[] arr = {123, 3.14, true, 'a', "abc", new Test01()};        System.out.println(Arrays.toString(arr));*/    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h4 id="基本数据类型和包装类之间的转换"><a href="#基本数据类型和包装类之间的转换" class="headerlink" title="基本数据类型和包装类之间的转换"></a>基本数据类型和包装类之间的转换</h4><ol><li><p><strong>包装类的底层</strong></p><ul><li><strong>所谓的包装类，则底层中定义了一个对应基本数据类型的“私有常量”来保存数据，包装类其实就是对基本数据类型的数据执行封装的操作。</strong></li><li>例如：在Integer包装类中，其底层定义了一个int类型的“私有常量”来保存数据，也就是Integer包装类就是对int类型数据执行的封装操作。</li></ul></li><li><p><strong>基本数据类型转化为包装类</strong></p><ul><li><p>方式一：通过构造方法来实现</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Integer</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作用：把基本数据类型转化为包装类对象。</span><span class="token keyword">public</span> <span class="token function">Integer</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token keyword">throws</span> NumberFormatException <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//作用：把字符串的内容转化为包装类对象。</span>          <span class="token comment" spellcheck="true">//注意：当字符串存储的内容和对应的基本数据类型的数据格式不匹配的时候，则就会抛出“数值格式化异常”</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>方式二：通过valueOf()静态方法来实现</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//作用：把基本数据类型转化为包装类对象。</span>       <span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token keyword">throws</span> NumberFormatException <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//作用：把字符串的内容转化为包装类对象。</span>          <span class="token comment" spellcheck="true">//注意：当字符串存储的内容和对应的基本数据类型的数据格式不匹配的时候，则就会抛出“数值格式化异常”。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>注意事项</strong></p><ol><li><p><strong>针对Character类型，字符串不能转化为Character类型的包装类对象，因为Character类没有提供字符串参数的构造方法和字符串参数的valueOf()方法。</strong></p></li><li><p>针对Boolean类型，只有字符串为“true”（不区分大小写）的时候，转化为包装对象的值才为true，否则一律都为false。</p></li><li><p><strong>数值型的包装类中（不包含Character和Boolean），形参字符串的内容为必须为数值型，否则抛出NumberFormatException异常。</strong></p></li></ol></li></ul></li><li><p><strong>包装类转化为基本数据类型？</strong></p><ul><li><p><strong>情况一：数值型包装类</strong></p><p>–&gt; 数值型包装类都是Number抽象类的实现类，因此数值型包装类使用Number抽象类提供的方法，我们就可以实现把“数值型包装类对象”转化为“数值型”。</p></li><li><p><strong>情况二：非数值型包装类</strong></p><p>–&gt; 针对Character类型，我们可以使用Character类中提供的charValue()方法，从而将“Character对象”转化为对应的“char类型”。</p><p>–&gt; 针对Boolean类型，我们可以使用Boolean类中提供的booleanValue()方法，从而将“Boolean对象”转化为对应的“boolean类型”。</p></li></ul></li></ol><h4 id="自动装箱和自动拆箱（超级重点）"><a href="#自动装箱和自动拆箱（超级重点）" class="headerlink" title="自动装箱和自动拆箱（超级重点）"></a>自动装箱和自动拆箱（超级重点）</h4><ol><li><p><strong>自动装箱和自动拆箱的概述</strong></p><ul><li>在JDK1.5之前，想要实现“基本数据类型”和“包装类”之间的转换，则必须通过调用包装类的方法来手动完成，此操作比较麻烦。</li><li>在JDK1.5之后，想要实现“基本数据类型”和“包装类”之间的转换，则我们可以通过自动装箱和自动拆箱来完成，此操作非常简单。</li></ul></li><li><p><strong>自动装箱机制的概述？</strong></p><ul><li>解释：当基本数据类型处于需要对象的环境中，则就会触发自动装箱机制，也就是自动会把基本数据类型转化为对应的包装类对象。</li><li>底层：当触发自动装箱机制的时候，则默认就会调用包装类的valueOf(xxx x)静态方法，从而将基本数据类型转化为包装类对象。</li></ul></li><li><p><strong>自动拆箱机制的概述？</strong></p><ul><li>解释：当包装类对象处于需要基本数据类型的环境中，则就会触发自动拆箱机制，也就是自动会把包装类对象转化为对应的基本数据类型。</li><li>底层：当触发自动拆箱机制的时候，则默认就会调用包装类的xxxValue()成员方法，从而将包装类对象转化为对应的基本数据类型。</li><li>例如：int num &#x3D; new Integer(123); –底层–&gt; int num &#x3D; new Integer(123).intValue();</li></ul></li><li><p><strong>自动装箱的缓存问题？</strong></p><ul><li>解释：当“整数型”的数据取值范围在[-128, 127]之间的时候，如果触发了自动装箱机制，则就会从“缓存池”中取出一个包装类对象并返回，也就是不会创建新的包装类对象并返回。</li><li>当“整数型”的数据取值范围在[-128, 127]之外的时候，如果触发了自动装箱机制，则就会直接创建一个新的包装类对象并返回，也就是不会从缓存池中取出包装类对象来返回。</li></ul></li><li><p><strong>自动拆箱的空指针问题？</strong></p><ul><li><p>解释：<strong>当触发自动拆箱机制的时候，则默认就会调用包装类的xxxValue()成员方法，如果该包装对象为null，那么触发自动拆箱机制就会抛出空指针异常。</strong></p><p>–&gt; <strong>例如：Integer integer &#x3D; null; int num &#x3D; integer; &#x2F;&#x2F; 等效于： int num &#x3D; integer.intValue();</strong></p></li></ul></li></ol><h4 id="基本数据类型和字符串之间的转换"><a href="#基本数据类型和字符串之间的转换" class="headerlink" title="基本数据类型和字符串之间的转换"></a>基本数据类型和字符串之间的转换</h4><ol><li><p><strong>字符串转化为基本数据类型（重要）</strong></p><ul><li><p>明确：<strong>使用包装类提供的parseXxx(String str)的静态方法来实现。</strong></p><pre class="line-numbers language-java"><code class="language-java">Byte    <span class="token keyword">static</span> <span class="token keyword">byte</span> <span class="token function">parseByte</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//将字符串参数解析为带符号的十进制byte 。</span>Short    <span class="token keyword">static</span> <span class="token keyword">short</span> <span class="token function">parseShort</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//将字符串参数解析为带符号的十进制short 。</span>Integer<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//将字符串参数解析为带符号的十进制int。</span>Long    <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">parseLong</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">//将字符串参数解析为带符号的十进制long。</span>Float    <span class="token keyword">static</span> <span class="token keyword">float</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//返回一个新 float值，该值被初始化为用指定字符串表示的值。</span>Double    <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">parseDouble</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//返回一个新 double值，该值被初始化为用指定字符串表示的值。</span> Boolean<span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">parseBoolean</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//将字符串参数解析为boolean值。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注意事项：</p><ul><li>1.<strong>不能把字符串转化为char类型，因为Character包装类中没有提供parseChar(String value)方法。</strong></li><li>2.针对Boolean类型，只有字符串为“true”的时候（不区分大小写），转化为基本类型的值才为true，否则都为false。</li><li>3.<strong>整数型包装类，字符串中的内容必须是十进制整数；浮点型包装类中，字符串中的内容必须为十进制整数或浮点数，否则抛出NumberFormatException异常。</strong></li></ul></li></ul></li><li><p>基本数据类型转化为字符串（了解）</p><ul><li><p>明确：<strong>把基本数据类型转换为字符串，我们可以使用“+”连接符来实现，也可以使用包装类提供的方法来实现。</strong></p><pre class="line-numbers language-java"><code class="language-java">所有包装类String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                返回对象的字符串表示形式。Byte    <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">byte</span> b<span class="token punctuation">)</span>    把<span class="token keyword">byte</span>类型转化为字符串返回。Short    <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">short</span> s<span class="token punctuation">)</span>    把<span class="token keyword">short</span>类型转化为字符串返回。Integer<span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>    把<span class="token keyword">int</span>类型转化为字符串返回。Long    <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">long</span> i<span class="token punctuation">)</span>    把<span class="token keyword">long</span>类型转化为字符串返回。Float    <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">float</span> f<span class="token punctuation">)</span>    把<span class="token keyword">float</span>类型转化为字符串返回。Double    <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">)</span>把<span class="token keyword">double</span>类型转化为字符串返回。Boolean<span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> b<span class="token punctuation">)</span>把<span class="token keyword">boolean</span>类型转化为字符串返回。Character<span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span>    把<span class="token keyword">char</span>类型转化为字符串返回。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h2 id="String类讲解"><a href="#String类讲解" class="headerlink" title="String类讲解"></a>String类讲解</h2><h4 id="字符串常量池的概述"><a href="#字符串常量池的概述" class="headerlink" title="字符串常量池的概述"></a>字符串常量池的概述</h4><ul><li><strong>加载类的时候</strong>，如果该类中有双引号创建的字符串，则就<strong>把该字符串在常量池中开辟存储空间并存储，并且常量池中存储的字符串都是唯一的。</strong></li><li><strong>执行程序的时候</strong>，如果遇到了双引号创建的字符串，则<strong>直接去常量池中取出该字符串并使用即可，也就是不会再次去创建一个新的字符串。</strong></li></ul><h4 id="String类的概述"><a href="#String类的概述" class="headerlink" title="String类的概述"></a>String类的概述</h4><ul><li>在字符串中，存储的是任意多个字符，这些字符以char类型的数组来存储的。<strong>在String类中，char类型的数组默认采用了final来修饰</strong>，也就意味着<strong>char类型的数组不能扩容</strong>，也就是<strong>字符串中存储的字符内容不可改变，因此我们称String为“不可变的Unicode编码序列”，简称“不可变字符串”。</strong>并且，<strong>String类还采用了final修饰，则意味着String类不能被继承。</strong></li></ul><h4 id="String类的部分常用方法"><a href="#String类的部分常用方法" class="headerlink" title="String类的部分常用方法"></a>String类的部分常用方法</h4><ul><li><p>length()方法</p><pre class="line-numbers language-Java"><code class="language-Java"> public int length() { ... }//作用：获得字符串的长度，也就是获得底层char类型数组的空间长度。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>charAt()方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">char</span> <span class="token function">charAt</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作用：根据索引获得字符串中的字符。</span><span class="token comment" spellcheck="true">//注意：index取值范围在[0, 字符串长度-1]之间，超出范围则就会抛出StringIndexOutOfBoundsException异常</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>indexOf()方法</p><ul><li>明确：“从前往后”查找某个“字符”或“子串”在“主串”中的索引位置，如果查找的“字符”或“字串”不存在，则返回-1</li></ul><pre class="line-numbers language-Java"><code class="language-Java">int indexOf(int ch)                //返回指定字符第一次出现在字符串内的索引。int indexOf(int ch, int fromIndex)    //返回指定字符第一次出现在字符串内的索引，以指定的索引开始搜索。int indexOf(String str)            //返回指定子字符串第一次出现在字符串内的索引。int indexOf(String str, int fromIndex)//返回指定子串的第一次出现在字符串中的索引，从指定的索引开始搜索。//注意：此处indexOf()方法的底层使用“字符串匹配算法”来实现，常见的字符串匹配算法有：BF算法和KMP算法。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>lastIndexOf()方法</p><ul><li>明确：“从后往前”查找某个“字符”或“子串”在“主串”中的索引位置，如果查找的“字符”或“字串”不存在，则返回-1</li></ul><pre class="line-numbers language-Java"><code class="language-Java">int lastIndexOf(int ch)                //返回指定字符最后一次出现在字符串内的索引。int lastIndexOf(int ch, int fromIndex)    //返回指定字符最后一次出现在字符串内的索引，以指定的索引开始搜索。int lastIndexOf(String str)            //返回指定子字符串最后一次出现在字符串内的索引。int lastIndexOf(String str, int fromIndex)//返回指定子串的最后一次出现在字符串中的索引，从指定的索引开始搜索。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>startsWith()方法</p><pre class="line-numbers language-Java"><code class="language-Java">public boolean startsWith(String prefix) { ... }// 作用：判断某个字符串是否以prefix开头。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>endsWith()方法</p><pre class="line-numbers language-Java"><code class="language-Java">public boolean endsWith(String suffix) { ... }//作用：判断某个字符串是否以suffix结尾<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>contains()方法</p><pre class="line-numbers language-Java"><code class="language-Java">public boolean contains(CharSequence s) { ... }//作用：判断字符串中是否包含某个子串（开头、中间和结尾）//注意：此处CharSequence是一个接口，该接口的实现类有String、StringBuffer和StringBuilder<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>字符串大小写转换</p><ul><li>明确：字符串大小写转换，针对“英文字母”有效，针对“中文汉字”无效。</li></ul><pre class="line-numbers language-Java"><code class="language-Java">String toUpperCase()//返回一个新的字符串，该字符串中所有英文字符转换为大写字母。String toLowerCase()//返回一个新的字符串，该字符串中所有英文字符转换为小写字母。//注意：执行注册或登录操作的时候，就需要使用字符型大小写转换来校对验证码。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>忽略字符串前后空格</p><pre class="line-numbers language-Java"><code class="language-Java">public String trim()  //忽略字符串前后端的空格，中间的空格不用忽略<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>字符串的截取操作</p><pre class="line-numbers language-Java"><code class="language-Java">String substring(int beginIndex)            //从beginIndex开始截取字符串，到字符串末尾结束。// 注意：此处beginIndex的取值范围在[0, 字符串长度-1]之间。    String substring(int beginIndex, int endIndex)//从beginIndex开始截取字符串，到字符索引endIndex-1结束。    //注意：beginIndex的取值范围在[0, 字符串长度-1]之间，endIndex的取值范围在[0, 字符串长度]之间，并且endIndex必须大于beginIndex<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>字符串的替换操作</p><pre class="line-numbers language-Java"><code class="language-Java">// 通过用newChar字符替换字符串中出现的所有oldChar字符，并返回替换后的新字符串。String replace(char oldChar, char newChar)    //将与字面目标序列匹配的字符串的每个子字符串替换为指定的字面替换序列。String replace(CharSequence target, CharSequence replacement)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>字符串拼接的操作</p><ul><li>明确：我们可以使用“+”连接符来实现字符串的评价操作，也可以使用String类提供的“String concat(String str)”方法来实现。</li></ul><pre class="line-numbers language-Java"><code class="language-Java">public class Test02 {    public static void main(String[] args) {        // 需求：完成字符串的拼接操作        String str1 = "hello" + "world";        System.out.println(str1); // 输出：helloworld        String str2 = "hello".concat("world");        System.out.println(str2); // 输出：helloworld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>isEmpty方法</p><pre class="line-numbers language-Java"><code class="language-Java">//作用：判断字符串是否为空，也就是判断底层的char类型数组空间长度是否为0 public boolean isEmpty() { ... }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>equals方法</p><pre class="line-numbers language-Java"><code class="language-Java">boolean equals(Object anObject)    //判断字符串内容是否相同，区分字母大小写。boolean equalsIgnoreCase(String str)//判断字符串内容是否相同，忽略字母大小写。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>valueOf方法</p><pre class="line-numbers language-Java"><code class="language-Java">String类提供了valueOf(xxx x)    //这个静态方法，该方法用于将其他的数据类型转化为字符串。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="StringBuffer类的概述"><a href="#StringBuffer类的概述" class="headerlink" title="StringBuffer类的概述"></a>StringBuffer类的概述</h4><ul><li>StringBuffer类继承于AbstractStringBuilder抽象类，StringBuffer类底层维护者一个char类型的数组，并且该char类型的数组没有使用final修饰，也就意味着该char类型的数组可以自动扩容，也就是该char类型数组存储的元素可以改变，因此我们就称StringBuffer类为“可变的Unicode编码序列”，简称“可变字符串”。并且，StringBuffer类采用了final修饰，也就意味着StringBuffer不能被继承。</li></ul><h4 id="String类和StringBuffer类特点"><a href="#String类和StringBuffer类特点" class="headerlink" title="String类和StringBuffer类特点"></a>String类和StringBuffer类特点</h4><ol><li><p>相同点：</p><ul><li>a)底层都维护者一个char类型的数组，也就是存储的都是字符，因此都属于“字符串”。</li><li>b)这个两个类都采用了final修饰，也就意味着String和StringBuffer都不能被继承。</li></ul></li><li><p>不同点：</p><ul><li><p>String类底层的char类型数组使用了final修饰，因此String类存储的字符内容不可改变，我们就称之为“不可变字符串”。</p><p>–&gt; 通过String类提供的方法来操作字符串中的内容时，都不是直接基于char类型数组做的操作，那么都会返回一个新的字符串。</p></li><li><p>StringBuffer类底层的char类型数组没有使用final修饰，因此StringBuffer类存储的字符内容可以改变，我们就称之为“可变字符串”。</p><p>–&gt; 通过StringBuffer类提供方法来操作字符串中的内容，都是直接基于char类型数组做的操作，因此就可以无需返回新的字符串。</p></li></ul></li></ol><h4 id="StringBuffer类的构造方法"><a href="#StringBuffer类的构造方法" class="headerlink" title="StringBuffer类的构造方法"></a>StringBuffer类的构造方法</h4><pre class="line-numbers language-Java"><code class="language-Java">StringBuffer()                //构造一个没有字符的字符串缓冲区，初始容量为16个字符（有用）。StringBuffer(CharSequence seq)//构造一个包含与指定的相同字符的字符串缓冲区CharSequence 。StringBuffer(int capacity)    //构造一个没有字符的字符串缓冲区和指定的初始容量。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="StringBuffer类的方法"><a href="#StringBuffer类的方法" class="headerlink" title="StringBuffer类的方法"></a>StringBuffer类的方法</h4><ul><li><p>明确：如果StringBuffer类提供方法的返回值类型为StringBuffer或AbstractStringBuilder，则该返回值就是“当前方法的调用者对象”。</p><ol><li><p>添加方法</p><pre class="line-numbers language-Java"><code class="language-Java">//作用：在可变字符串末尾添加内容。public AbstractStringBuilder append(Type type) { ... }// 作用：在可变字符串索引为offset位置插入字符串内容。 public AbstractStringBuilder insert(int offset, Type type) { ... }  //注意：此处offset的取值范围在[0, 可变字符串长度]之间，超出范围则就会抛出“字符串索引越界异常”。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>替换的方法</p><pre class="line-numbers language-Java"><code class="language-Java">//作用：把可变字符串索引为index的字符替换为ch即可。 public synchronized void setCharAt(int index, char ch) { ... } //  注意：此处index的取值范围在[0, 可变字符串长度 - 1]之间，超出范围则就会抛出“字符串索引越界异常”。 //作用：把可变字符串索引为[start, end)之间的元素替换为str即可。 public synchronized StringBuffer replace(int start, int end, String str) { ... } //注意：此处start的取值范围[0, 可变字符串长度 - 1]之间，end的取值范围在[0, 可变字符串长度]之间，并且end必须大于start。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除的方法</p><pre class="line-numbers language-Java"><code class="language-Java">//作用：删除可变字符串中索引为index的字符。public synchronized StringBuffer deleteCharAt(int index) { ... }// 注意：此处index的取值范围在[0, 可变字符串长度 - 1]之间，超出范围则就会抛出“字符串索引越界异常”。//作用：删除索引为[start, end)范围之间的元素。 public synchronized StringBuffer delete(int start, int end) {  ... } //注意：此处start的取值范围[0, 可变字符串长度 - 1]之间，end的取值范围在[0, 可变字符串长度]之间，并且end必须大于start。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查找的方法</p><pre class="line-numbers language-Java"><code class="language-Java">charAt(int index)                    //返回 char在指定索引在这个序列值。indexOf(String str)                //返回指定子字符串第一次出现的字符串内的索引。indexOf(String str, int fromIndex)    //返回指定子串的第一次出现的字符串中的索引，从指定的索引开始。lastIndexOf(String str)            //返回指定子字符串最右边出现的字符串内的索引。lastIndexOf(String str, int fromIndex)//返回指定子字符串最后一次出现的字符串中的索引，从指定的索引开始。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>反转的方法</p><pre class="line-numbers language-Java"><code class="language-Java">public synchronized StringBuffer reverse() 把可变字符串中的内容进行反转操作<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>操作字符串长度的方法</p><pre class="line-numbers language-Java"><code class="language-Java">// 作用：获得可变字符串的长度 public synchronized int length() { ... }// 作用：修改可变字符串的长度。public synchronized void setLength(int newLength) { ... }//注意：如果“设置的长度”大于“可变字符串的长度”，则默认做“扩容操作”。//如果“设置的长度”小于“可变字符串的长度”，则默认做“剪切操作”。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>字符串截取的方法</p><pre class="line-numbers language-Java"><code class="language-Java">substring(int start)        //返回一个新的 String ，其中包含此字符序列中当前包含的字符的子序列。substring(int start, int end)//返回一个新的 String ，其中包含此序列中当前包含的字符的子序列。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>转化为String类的方法</p><pre class="line-numbers language-Java"><code class="language-Java">// 作用：把StringBuffer对象转化为String类型。public synchronized String toString() { ... }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol></li></ul><h4 id="StringBuilder类的概述"><a href="#StringBuilder类的概述" class="headerlink" title="StringBuilder类的概述"></a>StringBuilder类的概述</h4><ul><li>StringBuilder类继承于AbstractStringBuilder抽象类，StringBuilder类底层维护者一个char类型的数组，并且该char类型的数组没有使用final修饰，也就意味着该char类型的数组可以自动扩容，也就是StringBuilder类存储的字符内容可以改变，因此我们就称呼StringBuilder类为“可变的Unicode编码序列”，简称“可变字符串”。并且，StringBuilder类采用final修饰，也就意味着StringBuilder不能被继承。</li></ul><h4 id="StringBuffer类和StringBuilder类的特点"><a href="#StringBuffer类和StringBuilder类的特点" class="headerlink" title="StringBuffer类和StringBuilder类的特点"></a>StringBuffer类和StringBuilder类的特点</h4><ol><li>相同点<ul><li>a)底层都包含char类型的数组，并且该char类型的数组都没使用final修饰，因此都称之为“可变字符串”。</li><li>b)这两个类都采用了final关键字来修饰，也就意味着StringBuffer类和StringBuilder类都不能被继承。</li><li>c)都继承于AbstractStringBuilder抽象类，并且这两个类拥有的方法都相同，因此使用方法属于类似的。</li></ul></li><li>不同点<ul><li>StringBuffer：线程安全的，会做线程同步检查，因此效率较低（不常用）。</li><li>StringBuilder：线程不安全的，不会做线程同步检查，因此效率较高（常用）。</li></ul></li></ol><h4 id="使用“-”连接符完成字符串拼接操作的底层分析（重点）"><a href="#使用“-”连接符完成字符串拼接操作的底层分析（重点）" class="headerlink" title="使用“+”连接符完成字符串拼接操作的底层分析（重点）"></a>使用“+”连接符完成字符串拼接操作的底层分析（重点）</h4><ol><li>情况一：两个字符串都是常量时，使用“+”来完成拼接操作<ul><li>底层：因为常量保存的内容不可改变，也就是编译时期就能确定常量的值，因此为了提高字符串的拼接效率，所以就在编译时期就完成了拼接操作。</li></ul></li><li>情况二：其中一个为字符串变量时，使用“+”来完成拼接操作<ul><li>底层：因为编译时期无法确定变量的值，因此其中一个为字符串变量的拼接操作，那么肯定不是在编译时期完成，而是在运行时期来完成的，并且实现步骤如下。</li></ul></li></ol><h4 id="三种字符串的拼接效率（重点）"><a href="#三种字符串的拼接效率（重点）" class="headerlink" title="三种字符串的拼接效率（重点）"></a>三种字符串的拼接效率（重点）</h4><ol><li><p>System.currentTimeMillis()方法的概述？</p><ul><li>作用：获得“当前时间”距离1970年1月1日凌晨的毫秒数。</li><li>–&gt; 公式：1秒 &#x3D; 1000毫秒</li><li>使用：计算完成某个功能所需要的耗时，则就可以使用该方法来实现。</li><li>–&gt; 耗时：结束时间 - 开始时间</li></ul></li><li><p>三种字符串的拼接效率？</p><ul><li><p><strong>StringBuilder的拼接效率最高，StringBuffer的拼接效率次之，String的拼接效率最低。</strong></p></li><li><p>注意：<strong>如果需要大量执行字符串的拼接操作，则建议使用StringBuilder类来完成拼接操作。</strong></p></li></ul></li></ol><h4 id="链式调用语法（了解）"><a href="#链式调用语法（了解）" class="headerlink" title="链式调用语法（了解）"></a>链式调用语法（了解）</h4><p>理解：每个成员方法体中都返回this，也就是每个成员方法体中都返回该方法的调用者对象。</p><ol><li>问题：在目前已经学习的类中，哪些类支持链式调用语法呢？？？<ul><li>答案：StringBuilder和StringBuffer</li></ul></li></ol><hr><h2 id="properties类"><a href="#properties类" class="headerlink" title="properties类"></a>properties类</h2><h4 id="properties的概述"><a href="#properties的概述" class="headerlink" title="properties的概述"></a>properties的概述</h4><ul><li>Properties类是属于集合，叫做属性集</li><li>Properties类是Hashtable的子类，所以存储的数据也是kv格式</li><li>Properties类中的key和value只能是String类型</li><li>Properties 类是一个持久的属性集，Properties可保存在流中或从流中加载。</li></ul><h4 id="常用方法："><a href="#常用方法：" class="headerlink" title="常用方法："></a>常用方法：</h4><ol><li><p>操作属性：</p><pre class="line-numbers language-Java"><code class="language-Java">String getProperty(String key)      用指定的键在此属性列表中搜索属性。 String getProperty(String key, String defaultValue)      用指定的键在属性列表中搜索属性。 Object setProperty(String key, String value)      调用 Hashtable 的方法 put。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>持久化方法，将数据保存到文件中</p><pre class="line-numbers language-Java"><code class="language-Java">void store(OutputStream out, String comments)      以适合使用 load(InputStream) 方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。 void store(Writer writer, String comments)      以适合使用 load(Reader) 方法的格式，将此 Properties 表中的属性列表（键和元素对）写入输出字符。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>读取持久化的数据</p><pre class="line-numbers language-Java"><code class="language-Java">void load(InputStream inStream)    从输入流中读取属性列表（键和元素对）。  void load(Reader reader)    按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>练习</p><pre class="line-numbers language-Java"><code class="language-Java">public class Demo01 {    public static void main(String[] args) throws IOException {        // 创建属性集对象        Properties prop = new Properties();        // 设置属性        prop.setProperty("name","张三");        prop.setProperty("age","20");        prop.setProperty("sex","男");        /*        * 将属性集持久化:(Writer writer, String comments)        *  第二个参数是 文件的注释信息        *  properties文件的注释格式是：  # 注释文字        *        *  属性集有字节的文件格式，扩展名是 .properties        * 数据格式是  key=value        *        */        prop.store(new FileWriter("day23/user.properties"),"用户的信息");        // 读取properties文件的数据        Properties prop01 = new Properties();        // 将文件数据加到到Properties属性集中        prop01.load(new FileReader("day23/user.properties"));        // 获取属性,如果属性不存在就返回null//        String name = prop01.getProperty("name");        /*        * getProperty(String key, String defaultValue)        *  如果属性存在就返回对应的值；如果属性不存在就返回默认值defaultValue        */        String name = prop01.getProperty("name1","不存在");        System.out.println(name);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h2><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li><p>java.util.Date() 我们称为时间类，程序中我们通过new对象保存时间（单位为毫秒）</p><ul><li><p>Date()类的构造方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>…<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>作用：获得保存“当前时间”的Date对象。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">long</span> date<span class="token punctuation">)</span> <span class="token punctuation">{</span>…<span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>作用：获得保存“指定时间”的Date 对象（表示的就是“指定时间”距离1970年1月1日凌晨的毫秒数）</li></ul></li></ul></li><li><p>Date()类的成员方法：</p><ul><li>Long getTime();返回当前时间距离1970年1月1日凌晨的毫秒数。（获得时间）</li><li>void setTime(long time);使用给指定的毫秒时间值设置现有的Date对象。（修改时间）</li></ul></li><li><p>SimpleDateFormat 类的引入</p><ul><li>Java.text.SimpleDateFormat类属于DateFormat抽象类的实现类，开发中用来实现“Date对象”保存时间和“字符串”保存时间之间的相互转换。</li></ul></li><li><p>测试代码</p></li></ul><pre class="line-numbers language-Java"><code class="language-Java">public class Test01 {    public static void main(String[] args) throws IOException {        //获取当前时间        Date date = new Date();        System.out.println(date);        SimpleDateFormat sf = new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒");        System.out.println(sf.format(date));        //将date对象保存的时间转换为calendar对象保存的时间        Calendar calendar = Calendar.getInstance();        calendar.setTime(date);        System.out.println(calendar);        //将calendar对象保存的时间转换为date对象保存的时间        Date date1 = calendar.getTime();        String s = sf.format(date1);        System.out.println(s);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="时间日期转换格式"><a href="#时间日期转换格式" class="headerlink" title="时间日期转换格式"></a>时间日期转换格式</h4><ul><li><p>当出现y时，会将y替换成年。</p></li><li><p>当出现M时，会将M替换成月。</p></li><li><p>当出现d 时，会将d替换成日。</p></li><li><p>当出现h时，会将h替换成时(12小时制)。</p></li><li><p>当出现H时，会将H替换成时(24小时制)。</p></li><li><p>当出现m时，会将m替换成分。</p></li><li><p>当出现s 时，会将s替换成秒。</p></li><li><p>当出现s 时，会将s替换成毫秒。</p></li><li><p>当出现D时，获得当前时间是今年的第几天。</p></li><li><p>当出现w时，获得当前时间是今年的第几周。</p></li><li><p>当出现w时，获得当前时间是本月的第几周。</p></li></ul><h4 id="时间类的构造方法"><a href="#时间类的构造方法" class="headerlink" title="时间类的构造方法"></a>时间类的构造方法</h4><ul><li><p>SimpleDateFormat类的构造方法：</p><pre class="line-numbers language-Java"><code class="language-Java">public SimpleDateFormat（String pattern）{…}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>作用：实例化SimpleDateFormat对象，并且还能设置指定的格式规则</li></ul></li><li><p>Public SimpleDateFormat类的成员方法：（重点方法）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">format</span><span class="token punctuation">(</span>Date date<span class="token punctuation">)</span><span class="token punctuation">{</span>…<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>作用：把Date对象保存的时间转换为字符串保存时间。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Date <span class="token function">parse</span><span class="token punctuation">(</span>String source<span class="token punctuation">)</span> <span class="token keyword">throws</span> ParseException<span class="token punctuation">{</span>…<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>作用：把字符串保存的时间转换为Date对象保存的时间</li></ul></li></ul><h4 id="时间日期的其他常用类"><a href="#时间日期的其他常用类" class="headerlink" title="时间日期的其他常用类"></a>时间日期的其他常用类</h4><ul><li><p>Calendar类（日历类）</p><ul><li>Java,util.Calendar类，通过Calendar可以表示年、月、日、是、分、秒的一个具体时间，而且还提供了日期相关的计算功能。</li></ul></li><li><p>Calendar类的实例化？？？</p><ul><li>Calendar类是一个抽象类，无法实例化，而是调用Calendar类的“Calendar getInstance()”静态方法来获得一个保存“当前时间”的</li></ul></li><li><p>Calendar对象。</p><ul><li>Calendaer 类中提供的字段，默认全部是int类型的“全局静态常量”。</li><li>calendar. YEAR获取年份</li><li>calendar . MONTH获取月份，o表示1月，1表示2月，…，11表示12月</li><li>calendar . DAY_OF_MONTH获取本月的第几天</li><li>calendar . DAY_OF_YEAR获取本年的第几天</li><li>calendar . HOUR_OF_DAY 小时，24小时制calendar. HOUR小时，12小时制</li><li>calendar.MINUTE 获取分钟</li><li>calendar.sECOND获取秒</li><li>calendar.MILLISECOND获取毫秒</li><li>calendar .DAY_OF_WEEK 获取星期几，1表示星期日，2表示星期一，…，7表示星期六</li></ul></li></ul><h4 id="时间日期的计算及转换"><a href="#时间日期的计算及转换" class="headerlink" title="时间日期的计算及转换"></a>时间日期的计算及转换</h4><ul><li><p>计算的方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//根据字段来“增加”或“减少”数据（在“年或月..”增加或者减少多少）。</span>Public <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> field<span class="token punctuation">,</span><span class="token keyword">int</span> amount<span class="token punctuation">)</span><span class="token punctuation">{</span>…<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>转换方法：</p></li><li><p>明确：开放中，经常设计到Date对象保存时间和Calendar对象保存时间之间的相互转换。</p><pre class="line-numbers language-java"><code class="language-java">Public <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setTime</span><span class="token punctuation">(</span>Date date<span class="token punctuation">)</span><span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作用：把Date对象保存时间转换为calendar对象保存的时间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><hr><h2 id="枚举（enum）"><a href="#枚举（enum）" class="headerlink" title="枚举（enum）"></a>枚举（enum）</h2><ul><li><p>枚举语法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token keyword">enum</span> 枚举名｛          枚举值<span class="token number">1</span>，枚举值<span class="token number">2</span>，枚举值<span class="token number">3</span>，…<span class="token punctuation">.</span><span class="token punctuation">.</span>      ｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>使用语法：枚举名.枚举值</p></li><li><p>注意：在switch选择结构中，我们使用“枚举值”的时候必须省略“枚举名”。</p></li></ul></li><li><p>枚举的底层？<br>在Java中枚举本质上就是一个被final修饰的类，并且继承了Java.long.Enum抽象类<br>类型的枚举中的所有枚举值，默认都是类型的全局静态常量。</p></li><li><p>对枚举进行反编译，发现枚举中还提供了values（）的全局静态方法，调用该方法就能返回枚举中的所有枚举值（用数组来存储）。</p></li></ul><hr><h2 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h2><h4 id="System的常用方法"><a href="#System的常用方法" class="headerlink" title="System的常用方法"></a>System的常用方法</h4><pre class="line-numbers language-java"><code class="language-java">    数组拷贝：<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">arraycopy</span><span class="token punctuation">(</span>object src<span class="token punctuation">,</span><span class="token keyword">int</span> srcPos<span class="token punctuation">,</span>object dest<span class="token punctuation">,</span><span class="token keyword">int</span> destPos<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span>        输出当前时间的毫秒数：<span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        终止当前程序，退出Java虚拟机：<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span>当s等于<span class="token number">0</span>时退出<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h4><pre class="line-numbers language-java"><code class="language-java">    <span class="token function">charAt</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span>         返回指定索引处的 <span class="token keyword">char</span> 值    <span class="token function">concat</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span>        将指定字符串连接到此字符串的结尾    <span class="token function">contains</span><span class="token punctuation">(</span>CharSequence s<span class="token punctuation">)</span>        判断是否包含次字符串：    <span class="token function">copyValueOf</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span>        返回数组中表示次字符的字符串    <span class="token function">copyValueOf</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span>        返回数组中指定下标的字符串    <span class="token function">endsWith</span><span class="token punctuation">(</span>String suffix<span class="token punctuation">)</span>        判断字符串是否以 指定字符串结尾    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Math类的常用方法"><a href="#Math类的常用方法" class="headerlink" title="Math类的常用方法"></a>Math类的常用方法</h4><pre class="line-numbers language-Java"><code class="language-Java">    Math.PI;        取圆周率：    Math.abs(基本数据类型 a);        取绝对值：    Math.cbrt(double a);        立方根：    Math.ceil(double a);        向上取整：    Math.floor(double a);        向下取整：     Math.max(int a,int b);        取两个数中的最大值：    Math.min(int a,int b);        取两个数中的最小值    Math.random();        [0，1)之间的随机数    Math.round(double a);        四舍五入：    Math.round(float a);        四舍五入：    （long）Math.fioor(数值+0.5)        注意：四舍五入的计算规则：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="UUID类"><a href="#UUID类" class="headerlink" title="UUID类"></a>UUID类</h4><ul><li>表示通用的唯一标识符（UUID）类。表示一个128位的值</li></ul><hr><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li>就是方法体中直接或间接的调用方法自身</li><li>使用递归：<br>1.必须创建方法。<br>2.必须有结束条件，（不然就会形成死递归，导致栈溢出）。<br>3.构造函数不能使用递归。</li><li>递归的思想：<br>将一个大的问题拆分成几个小问题，所有小问题解决了，大问题就解决了。</li><li>注意：循环能够解决的问题递归一定能够解决，反之则不一定。<br>如果循环嵌套层次过多，则可以使用递归，但是递归效率比循环效率更低。</li></ul><hr><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h4 id="集合Collection接口的继承结构图"><a href="#集合Collection接口的继承结构图" class="headerlink" title="集合Collection接口的继承结构图"></a>集合Collection接口的继承结构图</h4><p><img src="/images/Javase/list.png" alt="list.png"></p><h4 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h4><ul><li><p>实现的接口：</p><ul><li>collection接口，List接口，Deque接口（双端队列）</li></ul></li><li><p>链表之单向链表</p><ul><li><p>一个节点由数据位和地址位组成，数据位就是存储元素，地址位就是下一个节点的地址。</p><p><img src="/images/Javase/linkde1.png" alt="linked1"></p></li></ul></li><li><p>链表之双向链表</p><ul><li><p>一个节点由两个地址位和一个数据位，数据位存储元素，地址位一个地址位指向前一个节点的地址，一个指向下一个节点的地址。</p><p><img src="/images/Javase/linkde2.png" alt="linkde2"></p></li></ul></li><li><p>链表的特点：</p><ul><li>链表是由节点链接而成的</li><li>链表在内存中不是一段连续的内存空间，添加一个节点就在内存中新开一个空间存储节点</li><li>链表的增删效率高，查改的效率低。</li><li>非线程安全，安全性低，效率高。</li></ul></li></ul><h4 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h4><ul><li>向量类<br> 1. List的实现类<br> 2. 底层数据结构：动态数组<br> 3. 增删效率低，查改效率高<br> 4. 线程安全的，安全性高，效率低（几乎不用）</li></ul><h4 id="泛型（genericity）"><a href="#泛型（genericity）" class="headerlink" title="泛型（genericity）"></a>泛型（genericity）</h4><ul><li><p>泛型：又叫参数化类型，就是应用数据类型作为参数了。（泛型也有形参和实参）</p><ul><li>泛型的形参：仅仅表示这是一个泛型，没有具体的数据类型。（可以用 E T…）</li><li>泛型的实参：在创建对象时定义实参，约束集合的数据类型。</li></ul></li><li><p>注意：只有引用数据类型才能作为泛型。</p></li><li><p>泛型的作用：约束集合中的元素的数据类型，将元素类型的检测从运行时提升到编译时。</p></li><li><p>泛型的方法：（该方法没什么实际运用，了解语法即可）</p><ul><li>泛型方法的定义上一定有&lt;泛型的形参&gt;的方法才是泛型方法</li></ul></li><li><p>泛型方法的语法格式：</p><pre class="line-numbers language-Java"><code class="language-Java">修饰符 <泛型> 返回值类型  方法名（参数列表）｛｝<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​</p></li><li><p>泛型通配符：？（没什么鸟用，了解即可）</p><ul><li><?>这里的？就是泛型通配符。</li><li>泛型通配符？：表示所有泛型实参，就是可以表示泛型所有的具体类型</li><li><E>：这里的E表示的是泛型所有的形参。</li></ul></li><li><p>泛型通配符主要配合泛型的限定来使用</p></li><li><p>泛型的限定：</p><ul><li>上限：&lt;? extends T&gt; 表示？只能是T类及其子类</li><li>下限：&lt;? super T&gt;表示？只能是T类及其父类</li><li>注意：T 表示一个类（自定义类也行）</li></ul></li><li><p>泛型擦除：</p><ul><li>源代码中使用的泛型，在经过编译后，代码中就看不大泛型，就是泛型擦除。</li><li>（泛型擦除不是泛型丢失了，而是在编译后的字节码文件中使用单独的标识来存储泛型了）</li></ul></li></ul><h4 id="set接口"><a href="#set接口" class="headerlink" title="set接口"></a>set接口</h4><ul><li>是collection接口的子接口。</li><li>特点：元素不能重复，元素重复是否有序和实现类有关。</li></ul><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul><li>HsahSet是set接口的实现类。<ol><li>元素不能重复</li><li>元素无序，特别是它不保证该顺序恒久不变。</li><li>底层的数据结构是HashMap&lt;k,v&gt;,HashMap的底层结构是哈希表</li></ol></li><li>哈希表：也叫散列表，是根据关键码值（key）而直接进行访问的数据结构</li><li>哈希表是一个数组。</li><li>哈希表中的数据会产生哈希冲突（碰撞）<ul><li>哈希冲突：不同的key，hashCode值一样，哈希表中的索引就一样，这就是哈西冲突。</li></ul></li></ul><h4 id="LinedHashSet类"><a href="#LinedHashSet类" class="headerlink" title="LinedHashSet类"></a>LinedHashSet类</h4><ul><li>是HashSet的子类<ul><li>底层为 链表+哈希表</li></ul></li><li>特点：元素唯一且有序。</li></ul><h4 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h4><ul><li><p>TreeSet类是set接口的实现类</p></li><li><p>treeSet元素不重复</p></li><li><p>底层结构是TreeSetMap，treeMap的底层是红黑树</p></li><li><p>treeSet是根据元素进行排序</p></li><li><p>排序方法：</p><ol><li><p>使用自然排序接口（Comparable）实现排序：</p><ul><li><p>需要元素类实现该接口并且（添加泛型），才能实现排序功能</p></li><li><p>（设置排序规则：返回值&lt; 0 倒序，返回值 &#x3D; 0 元素相同，返回值 &gt; 0 正序）</p></li><li><p>缺点：扩展性差，不易修改</p></li></ul></li><li><p>使用比较器排序接口（Comparator）实现排序：</p><ul><li><p>不需要元素类实现该接口，需要构造一个类实现该接口，在构造的类中写入比较条件。</p></li><li><p>优点：和比较的类解耦合，满足ocp原则，可以做多种排序要求。</p></li></ul></li><li><p>注意：当利用无参构造创建对象时，调用的是自然排序。用有参构造new了一个比较器时，调用比较器排序。</p></li></ol></li></ul><h4 id="Map-lt-K-V-gt-接口"><a href="#Map-lt-K-V-gt-接口" class="headerlink" title="Map&lt;K,V&gt;接口"></a>Map&lt;K,V&gt;接口</h4><ul><li><p>HashMap实现类 , Hashtable实现类 , TreeMap实现类</p></li><li><p>map的结构继承图：</p></li></ul><p><img src="/images/Javase/map.png" alt="map"></p><ul><li><p>注意:根据以上的继承关系我们知道Map接口和Collection接口是没有关系的。</p><ul><li><p>但是在开发中我们还是把Map叫做Map集合;因为Map接口也是java集合框架的成员。</p></li><li><p>此接口是Java Collections Framework的成员。</p></li></ul></li></ul><h4 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h4><ul><li><p>是Map 接口的实现类</p></li><li><p>底层是哈希表</p></li><li><p>线程不安全的，安全性低，效率高</p></li><li><p>允许使用null键，null值。</p></li><li><p>哈希表中的数组初始容量是16，当Map中的元素达到容量的0.75倍就会扩容。0.75是map的负载因子。这个数在时间和空间上都是相对最合适的</p></li><li><p>扩容：新容量&#x3D;旧容量的2倍。</p></li><li><p>容量必须满足：&lt;&#x3D; 2的30次方。</p></li></ul><h4 id="LinkdHashMap类"><a href="#LinkdHashMap类" class="headerlink" title="LinkdHashMap类"></a>LinkdHashMap类</h4><ul><li>保证了存储元素时的有序性。</li></ul><h4 id="TreeMap类"><a href="#TreeMap类" class="headerlink" title="TreeMap类"></a>TreeMap类</h4><ol><li>是Map接口的实现类</li><li>底层是红黑树。</li><li>红黑树的数据结构是约束key的</li><li>可以对Map中的key排序</li><li>也有“自然排序”和“比较器排序”两种。</li></ol><h4 id="集合的部分方法扩展"><a href="#集合的部分方法扩展" class="headerlink" title="集合的部分方法扩展"></a>集合的部分方法扩展</h4><ul><li><p>集合的添加元素</p><ul><li><p>Collections中的静态方法addAll方法可以将指定的多个元素全部加到集合中</p><pre class="line-numbers language-Java"><code class="language-Java">Collections.addAll("集合名",添加的元素,添加的元素,.......);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>集合的forEach遍历方法</p><ul><li><p>在forEach中new一个Consumer接口，consumer接口也是函数表达式，里面的抽象方法是没有返回值，有一个参数。</p></li><li><p>这是lambda表达式：（lambda内容见下）</p><pre class="line-numbers language-java"><code class="language-java">集合名<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>简写方法</p><pre class="line-numbers language-java"><code class="language-java">集合名<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>集合的排序</p><ul><li><p>使用list.sort()方法中，传入Comparator接口类型的参数， Comparator接口是函数表达式，里面的抽象方法：返回值是int类型，有两个参数。</p><pre class="line-numbers language-Java"><code class="language-Java">list.sort((x,y) -> x-y);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>lambda表达式：Comparator.comparing（元素对象：：元素属性）（根据属性升序）（根据存储的元素，是基本数据类型，还是存储的对象，来确定是否调用方法的）</p><pre class="line-numbers language-Java"><code class="language-Java">list.sort(Comparator.comparing(a -> a.方法));list.sort(Comparator.comparing(对象::方法));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li></ul><hr><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h4 id="IO流的思维导图"><a href="#IO流的思维导图" class="headerlink" title="IO流的思维导图"></a>IO流的思维导图</h4><p><img src="/images/Javase/io.png" alt="io"></p><h4 id="io流的引入"><a href="#io流的引入" class="headerlink" title="io流的引入"></a>io流的引入</h4><ul><li>我们要将数据以文件的形式永久的保存到硬盘上，而要将数据写入文件中；或者从文件中读取数据，就需要使用io流<ul><li>IO流：<ul><li>io：输入输出</li><li>流：数据流，连续不断的数据</li></ul></li></ul></li></ul><h4 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h4><ul><li><p>根据流向的不同分为：</p><ul><li><p>输入流：读数据，将数据读取到程序中</p></li><li><p>输出流：写数据，将程序中的数据写到文件中</p></li></ul></li><li><p>根据操作数据的不同分为：</p><ul><li>字节流：按照字节为单位写数据</li><li>字符流：按照字符为单位写数据</li></ul></li><li><p>流根据不同功能分为：</p><ul><li>节点流（普通流）：真正读写数据的流。真正干活的。</li><li>处理流（包装流）：是对节点流的封装，也就是在节点流的基础上增加心得功能。但是读写数据还是使用节点流</li></ul></li><li><p>注意：</p><ul><li><p>字节流是万能流，什么文件都可以操作，</p></li><li><p>字符流不是万能的，只有记事本打开不会乱码的文件，才可以用字符流操作。</p></li></ul></li></ul><h4 id="四大基本抽象流"><a href="#四大基本抽象流" class="headerlink" title="四大基本抽象流"></a>四大基本抽象流</h4><ul><li><p>字节输入流(InputStream)：按照字节为单位读数据</p><ul><li>表示所有输出字节流的超类</li></ul></li><li><p>字节输出流(outputstream) :按照字节为单位写数据</p><ul><li>表示所有输入字节流的超类</li></ul></li><li><p>字符输入流(Reader):按照字符为单位读数据</p></li><li><p>字符输出流(writer):按照字符为单位写数据</p></li></ul><h4 id="文件输入输出流"><a href="#文件输入输出流" class="headerlink" title="文件输入输出流"></a>文件输入输出流</h4><ul><li><p>文件输入输出流是一种普通流，真正干活的。</p></li><li><p>文件输入流(FileInputStream)</p><ul><li>用于读取硬盘中文件的数据。（以字节为单位读取）</li></ul></li><li><p>文件便捷输入流(FileReader)</p><ul><li>用于读取硬盘中文件的数据。（以字符为单位读取）</li></ul></li><li><p>文件输出流(FileOutputStream)</p><ul><li>用于向硬盘中的文件写入数据。（以字节为单位写入）</li></ul></li><li><p>文件便捷输出流(FileWriter)</p><ul><li>用于向硬盘中的文件写入数据。（以字符为单位写入）</li></ul></li></ul><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><ul><li><p>缓冲流是一种处理流，在节点流的基础上增加了缓冲区。</p></li><li><p>字节缓冲输入流()BufferedInputStream)</p><ul><li>BufferedInputStream为另一个输入流添加一些功能，即华冲输入以及支持mark和reset方法的能力</li></ul></li><li><p>字节缓冲输出流(BufferedOutputStream)</p><ul><li>该类实现缓冲的输出流，通过设置这种输出流，应用程序就可以将各个字节写入底层输出流中，而不必针对每次字节写入调用底层系统。</li></ul></li></ul><h4 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h4><ul><li><p>计算机中的标准输入设备：键盘</p></li><li><p>标准输出设备：显示器</p></li><li><p>system类中的静态方法：</p><ul><li><p>标准错误输出流(static Printstream err)</p></li><li><p>标准输入流(static Inputstream in)</p><ul><li>作用于键盘</li></ul></li></ul><ul><li>标准输出流(static Printstream out)<ul><li>作用于显示器</li></ul></li></ul></li></ul><h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><ul><li>打印流(PrintStream)<br>打印流是一种处理流，为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</li></ul><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><ul><li><p>数据流只有字节流，没有字符流</p></li><li><p>序列化(DataOutputStream)</p><ul><li><p>将数据以乱码的方式写入，读需要使用反序列化(DataInputStream)来读取数据</p><pre class="line-numbers language-Java"><code class="language-Java">public class Test03 {    public static void main(String[] args) {        DataOutputStream dos = null;        try {            dos = new DataOutputStream(new FileOutputStream("E:\\a.txt"));            dos.writeInt(1);            dos.writeInt(2);            dos.writeChar('a');            dos.writeChar('b');            dos.flush();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }finally {            if (dos != null) {                try {                    dos.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>反序列化(DataInputStream)</p><ul><li><p>读取序列化后的数据，读取时需要与写入时的数据类型顺序对应，否则会报错</p><pre class="line-numbers language-Java"><code class="language-Java">public class Test04 {    public static void main(String[] args) {        DataInputStream dis = null;        try {            dis = new DataInputStream(new FileInputStream("E:\\a.txt"));            System.out.println(dis.readInt());            System.out.println(dis.readInt());            System.out.println(dis.readChar());            System.out.println(dis.readChar());            System.out.println(dis.readByte());        } catch (Exception e) {            e.printStackTrace();        } finally {            if (dis != null) {                try {                    dis.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><hr><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h4 id="线程（Thread）"><a href="#线程（Thread）" class="headerlink" title="线程（Thread）"></a>线程（Thread）</h4><ul><li><p>Java中使用Thread类表示线程。</p></li><li><p>注意：只有Thread类及其子类才能叫做线程</p></li><li><p>线程就是进程的执行路径。作用就是将程序指令交个CPU执行。一个进程至少需要一个线程。线程将指令交给CPU执行，是需要抢占CPU的时间片才能执行。CPU的一个核心执行一个线程。</p></li><li><p>多线程</p><ul><li>一个程序有多个执行路径，那么这个程序就是多线程的程序。</li></ul></li><li><p>创建线程</p><ul><li>方法一：<ol><li>创建Thread类的子类</li><li>子类重写run()方法</li><li>创建子类对象并成功</li></ol></li><li>方法二：<ol><li>创建Runnable接口的实现类</li><li>实现类重写run()方法</li><li>创建Thread时将实现类对象作为参数传递，启动Thread</li></ol></li></ul></li><li><p>守护线程</p><pre class="line-numbers language-Java"><code class="language-Java">void setDaemon(boolean on) ,当为true时用户线程变为守护线程。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>礼让线程</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  （没什么用）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h4><ul><li>进程是运行中的程序，是计算机中分配资源的最小单位。</li><li>线程是程序的执行路径，线程是在进程中的。线程是程序执行的最小单位。</li></ul><h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><ul><li><p>线程的状态：新建，就绪，运行，阻塞，死亡</p><p><img src="/images/Javase/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE.png" alt="线程生命周期"></p></li></ul><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><ul><li>返回线程优先级：int getPriority();</li><li>设置线程优先级：void setPriority(int a)<ul><li>(最小优先级&#x3D;1 &lt;&#x3D; a &lt;&#x3D; 最大优先级&#x3D;10 ，默认优先级&#x3D;5)</li></ul></li><li>在cpu资源充足的情况下，设置优先级没有效果;在资源不足的情况下，优先级高的线程获取到资源的几率大一点。</li></ul><h4 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h4><ul><li><p>中断标记</p><pre class="line-numbers language-Java"><code class="language-Java">Void interrupt()    //给线程设置一个中断标记，不会中断线程。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>获取中断标记</p><pre class="line-numbers language-java"><code class="language-java">Static <span class="token keyword">boolean</span>  <span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//(获取后会清除标记)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h4><ul><li><p>同步代码块</p><pre class="line-numbers language-Java"><code class="language-Java">synchronized（对象锁）｛    //操作共享数据的代码｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>被synchronized修饰的代码具备有原子性。（要么不执行，要么执行结束）</p></li><li><p>对象锁：所有的多个线程是同一个锁。</p></li></ul></li><li><p>同步方法</p><pre class="line-numbers language-Java"><code class="language-Java">修饰符 synchronized 返回值 方法名（实参列表）｛        //共享修改的数据｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>方法结束释放锁</li><li>建议方法中的代码全是共享的的数据</li><li>方法中的对象锁是：this</li><li>注意：静态的同步方法的对象锁是：字节码对象 (类名.class)</li></ul></li><li><p>同步：（效率低）</p><ul><li>多个线程执行时，线程是阻塞的，需要得到前一个线程的结果，另一个线程才能执行</li></ul></li><li><p>异步：（效率高）</p><ul><li>多个线程执行时，非阻塞的，线程之间是并发执行，不需要等待前面的结果。</li></ul></li><li><p>Synchronized的可重入性：</p><ol><li>synchronized是一个不公平锁<ul><li>公平锁：按照进入阻塞队列的顺序获取锁。</li><li>不公平锁：不管先后顺序，谁抢到就是谁的。</li></ul></li><li>synchronized是一个可重入锁<ul><li>使用synchronized时，当一个线程得到一个&#x3D;对象锁后，只要该线程还没有释放这个对象锁，再次请求此对象锁时可以再次获得该对象的锁。</li><li>可重入锁也支持在父子类继承的环境中，当存在父子类继承关系时，子类是完全可以通过“可重入锁”调用父类的同步方法。</li></ul></li></ol></li></ul><h4 id="线程之间通信机制"><a href="#线程之间通信机制" class="headerlink" title="线程之间通信机制"></a>线程之间通信机制</h4><ul><li><p>线程通信使用的是 “等待唤醒” 机制</p><ul><li><p>等待：wait();(会自动释放锁)</p></li><li><p>唤醒：notify();或者notifyAll();（不会释放锁）</p></li></ul></li><li><p>wait();notify();或者notifyAll();这几个方法必须出现在同步代码块中或者在同步方法中（用对象锁来调用）</p></li><li><p>notify();随机唤醒一个线程，notifyAll();将所有等待线程全部唤醒</p></li><li><p>Lock锁</p><pre class="line-numbers language-Java"><code class="language-Java">    public interface Lock<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>Lock、实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的Condition对象。<ol><li>synchronized是关键字，我们不能修改。</li><li>Lock的接口，接口中就是方法，接口的方法可以重写，还可以接收参数，所以比 synchronized更加灵活。</li></ol></li></ul></li><li><p>condition接口</p><ul><li>Condition将object监视器方法(wait、notify和 notifyAll)分解成截然不同的对象，以便通过将这些对象与任意Lock 实现组合使用，为每个对象提供多个等待 set (wait-set)。其中,Lock 替代了synchronized方法和语句的使用，condition替代了object监视器方法的使用。</li></ul><ol><li>notify()&#x2F;notifyAll()只能在配合synchronized使用</li><li>condition接口的等待唤醒只能配合Lock使用</li><li>condition接口的await&#x2F;signal方法也必须编写在lock()和unlock()之间</li></ol></li></ul><h4 id="单列模式"><a href="#单列模式" class="headerlink" title="单列模式"></a>单列模式</h4><ul><li><p>饿汉式</p></li><li><p>在类中就直接new对象</p><ol><li>私有化构造方法</li><li>定义一个本类类型的静态变量，并私有化。</li><li>封装 一个get方法</li></ol><pre class="line-numbers language-Java"><code class="language-Java">public class DanLie01 {    //不管是否调用，直接先new出对象    private static DanLie01 danLie01 = new DanLie01();    private DanLie01() {    }    public static DanLie01 getDanLie01() {        return danLie01;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>懒汉式</p></li><li><p>用的时候才创建对象。</p><ol><li>私有化构造方法</li><li>定义一个本类类型的静态变量，并私有化。（添加volatile关键字，解决指令重排)</li><li>封装一个静态方法（在方法中new对象）</li><li>添加同步代码块使线程安全</li></ol><pre class="line-numbers language-Java"><code class="language-Java">public class DanLie02 {    //添加关键字volatile 解决指令重排问题    private volatile static DanLie02 danLie02;    private DanLie02() {    }    public static DanLie02 setDanLie02(){        //这个if判断是为了减少同步代码块的调用，增加效率        if (danLie02 == null){            //使用同步代码块，防止多线程安全问题            synchronized (DanLie02.class) {                //如果danLie02为空，表示还没有创建对象，所以就创建对象                //如果不为空，表示对象已创建，静态变量不能二次赋值，所以直接返回，                // 保证对象的单列。                if (danLie02 == null) {                    danLie02 = new DanLie02();                }            }        }        return danLie02;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="定时器（Timer）"><a href="#定时器（Timer）" class="headerlink" title="定时器（Timer）"></a>定时器（Timer）</h4><ol><li><p>创建定时器类对象</p></li><li><p>自定义一个任务子类继承TimerTask</p></li><li><p>在任务类中写任务。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyDeTimer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建定时器对象</span>        Timer timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建定时器子类对象</span>        MyTimer myTimer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//让myTimer类在两秒后执行。</span>        timer<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>myTimer<span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//让myTimer类在一秒后开始执行，每间隔两秒执行一次。</span>        timer<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>myTimer<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 自定义定时器子类 */</span><span class="token keyword">class</span> <span class="token class-name">MyTimer</span> <span class="token keyword">extends</span> <span class="token class-name">TimerTask</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="线程池（Exector）"><a href="#线程池（Exector）" class="headerlink" title="线程池（Exector）"></a>线程池（Exector）</h4><ul><li><p>线程池的工具类（Executors）</p></li><li><p>使用线程池创建单一线程：Executors . [**newSingleThreadExecutor**](mk:@MSITStore:C:\Users\ASUS\Desktop\JDK 1.6 API.chm::&#x2F;java&#x2F;util&#x2F;concurrent&#x2F;Executors.html#newSingleThreadExecutor())()</p></li><li><p>使用线程池创建多个固定可重复的线程：Executors . [**newFixedThreadPool**](mk:@MSITStore:C:\Users\ASUS\Desktop\JDK 1.6 API.chm::&#x2F;java&#x2F;util&#x2F;concurrent&#x2F;Executors.html#newFixedThreadPool(int))(int nThreads) </p></li><li><p>缓冲线程池：[**newCachedThreadPool**](mk:@MSITStore:C:\Users\ASUS\Desktop\JDK 1.6 API.chm::&#x2F;java&#x2F;util&#x2F;concurrent&#x2F;Executors.html#newCachedThreadPool())() </p></li><li><p>时间调度线程池：newS……</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyExecutor</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建多个固定可重复的线程</span>        ExecutorService service <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//创建单一线程</span>        ExecutorService service1 <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        service1<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"单一线程执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建缓冲线程</span>        ExecutorService service2 <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        service2<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"缓冲线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h4><ul><li><p>该类提供了线程局部变量</p></li><li><p>每个线程都有自己的局部变量</p></li><li><p>ThreadLocal本身不存储数据，真正存储数据的是线程内部的ThreadLocalMap,ThreadLocal是Map的key值</p></li><li><p>执行过程图</p><p><img src="/images/Javase/ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.png" alt="提供局部变量执行图"></p></li><li><p>使用匿名内部类时</p><pre class="line-numbers language-Java"><code class="language-Java">//自定义一个dog类class Dog{}/** * ThreadLocal类 */public class MyThreadLocal01 {    /**     * 创建时使用匿名内部类，重写initialValue方法，直接返回自定义类对象     * 这样输出方法中就可不用在new对象，     */    private static ThreadLocal<Dog> local = new ThreadLocal<Dog>(){        @Override        protected Dog initialValue() {            return new Dog();        }    };    public static void main(String[] args) {        //创建三个线程        for (int i = 0; i < 3; i++) {            Thread thread = new Thread(new Runnable() {                @Override                public void run() {                    m1();                    try {                        Thread.sleep(500);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    m2();                }            });            thread.start();        }    }    //定义两个方法    public static void m1(){        System.out.println(Thread.currentThread().getName() + "-->" + local.get() );    }    public static void m2(){        System.out.println(Thread.currentThread().getName() + "-->" + local.get() );    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建对象用set方法改变变量为局部变量</p><pre class="line-numbers language-Java"><code class="language-Java">//自定义一个类class Cat{}/** * ThreadLocal类 */public class MyThreadLocal02 {    //这个对象多线程无法起作用    //private static Cat cat = new Cat();    //创建一个ThreadLocal对象(泛型为cat)设置为静态，私有化    private static ThreadLocal<Cat> local = new ThreadLocal();    public static void main(String[] args) {        //创建三个线程        for (int i = 0; i < 3; i++) {            Thread t1 = new Thread(new Runnable() {                @Override                public void run() {                    //调用方法一                    m1();                    try {                        Thread.sleep(200);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    m2();                }            });            t1.start();        }    }    /**     * 如果要保证两个方法输出的cat值是同一个，则不能new两个cat对象     * 如果值new一个静态的cat的对象，那么多线程输出就会被最后执行的一个线程覆盖，不能起作用     * 所以只能将cat对象用（ThreadLocal类）绑定cat对象将其设置成局部对象     */    //定义两个静态输出Cat的方法    public static void m1(){        //创建cat对象        Cat cat = new Cat();        //使用ThreadLocal的set方法绑定Cat对象        local.set(cat);        //输出Cat        System.out.println(Thread.currentThread().getName() + "->" + local.get());    }    public static void m2(){        //输出Cat        System.out.println(Thread.currentThread().getName() + "====>" + local.get());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="CountDownLatch倒计时锁"><a href="#CountDownLatch倒计时锁" class="headerlink" title="CountDownLatch倒计时锁"></a>CountDownLatch倒计时锁</h4><ul><li><p>new一个对象出来，设置倒计时时长</p></li><li><p>调用conutDown方法一次可以减一。</p><pre class="line-numbers language-Java"><code class="language-Java">public class MyCountDownLatch {    public static void main(String[] args) {        //创建一个倒计时锁对象        CountDownLatch latch = new CountDownLatch(1);        //创建五个线程        for (int i = 0; i < 5; i++) {            Thread t1 = new Thread(new Runnable() {                @Override                public void run() {                    //倒计时数字减一                    //latch.countDown();                    try {                        latch.await();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(Thread.currentThread().getName() + "已到位====");                }            });            //启动线程            t1.start();        }        System.out.println("主程序启动");        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            e.printStackTrace();        }        latch.countDown();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier 循环栅栏"></a>CyclicBarrier 循环栅栏</h4><ul><li><p>创建时设置线程数量</p><pre class="line-numbers language-Java"><code class="language-Java">public class MyCyclicBarrier {    public static void main(String[] args) {        /**         * 创建循环栅栏对象(设置线程个数)         * 这个线程数量必须小于等于创建的线程数量，否则程序将陷入死等待         */        CyclicBarrier barrier = new CyclicBarrier(5);        //使用线程池创建五个线程        ExecutorService service = Executors.newFixedThreadPool(5);        for (int i = 0; i < 5; i++) {            service.submit(new Runnable() {                @Override                public void run() {                    try {                        System.out.println(Thread.currentThread().getName() + "准备就绪");                        Thread.sleep(1000);                        //当循环栅栏中的线程全部到达时，才会唤醒等待状态                        barrier.await();                    } catch (InterruptedException e) {                        e.printStackTrace();                    } catch (BrokenBarrierException e) {                        e.printStackTrace();                    }                    System.out.println(Thread.currentThread().getName() + "开始执行。。。");                }            });        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore:信号量"></a>Semaphore:信号量</h4><ul><li><p>用来限制同时访问资源的线程数量</p><pre class="line-numbers language-Java"><code class="language-Java">public class MySemaphore {    public static void main(String[] args) {        //创建信号量对象，设置同时访问的数量为4        Semaphore semaphore = new Semaphore(4);        //创建是个线程，这里采用线程池的方式        ExecutorService service = Executors.newFixedThreadPool(10);        for (int i = 0; i < 10; i++) {            service.submit(new Runnable() {                @Override                public void run() {                    //使用信号量限定一次最多的执行次数                    try {                        semaphore.acquire();                        System.out.println(Thread.currentThread().getName() + "开始执行。。。");                    } catch (InterruptedException e) {                        e.printStackTrace();                    }finally {                        //执行结束后，让出信号位置                        semaphore.release();                    }                    System.out.println(Thread.currentThread().getName() + "停止执行！！");                }            });        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="反射机制与注解"><a href="#反射机制与注解" class="headerlink" title="反射机制与注解"></a>反射机制与注解</h2><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ul><li><p>根据字节码文件动态获取类信息</p></li><li><p>反射机制就是将类的各个组成部分（属性，方法 ，构造器 ）封装为其他对象。</p><p>获取类信息</p></li></ul><h4 id="获取class对象的四种方法"><a href="#获取class对象的四种方法" class="headerlink" title="获取class对象的四种方法"></a>获取class对象的四种方法</h4><ol><li>Calss.forName</li><li>类名.class (主要用于传参)</li><li>对象.getClass</li><li>包装类.TYPE</li></ol><h4 id="获取成员变量的字节码对象"><a href="#获取成员变量的字节码对象" class="headerlink" title="获取成员变量的字节码对象"></a>获取成员变量的字节码对象</h4><ul><li><p>类的指定公开成员变量 —-getField ()  加一个 s 表示获取所有的</p></li><li><p>获取成员变量的变量名—-getName()</p></li><li><p>获取成员变量的返回值—–getTypt()</p></li><li><p>获取成员变量的修饰符—–getModifiers()</p><pre class="line-numbers language-Java"><code class="language-Java"> Field nameField = aClass.getField("name"); System.out.println(nameField); System.out.println(nameField.getName());//获取字段名 System.out.println(nameField.getType());//获取字段返回值 System.out.println(nameField.getModifiers());//获取字段的修饰符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="使用构造方法创建对象"><a href="#使用构造方法创建对象" class="headerlink" title="使用构造方法创建对象"></a>使用构造方法创建对象</h4><ul><li><p>类的字节码文件对象.newInstance()</p><pre class="line-numbers language-Java"><code class="language-Java">//直接用字节码对象创建对象（默认调用无参构造方法）Object obj = aClass.newInstance();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>构造方法对象.newInstance()</p><pre class="line-numbers language-Java"><code class="language-Java">//通过无参构造对像创建对象Object obj = constructor.newInstance();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="获取构造方法的字节码对象"><a href="#获取构造方法的字节码对象" class="headerlink" title="获取构造方法的字节码对象"></a>获取构造方法的字节码对象</h4><ul><li><p>公开的构造方法：getConstructor()</p></li><li><p>非公开的构造方法：getDeclaredConstructor()</p><pre class="line-numbers language-Java"><code class="language-Java">//获取无参构造对象Constructor<?> constructor = aClass.getConstructor();//获取有参构造Constructor<?> constructor1 = aClass.getConstructor();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注意：使用所有非公开的对象时，需要提前</p></li><li><p>使用：setAccessible(true)方法，来暴力避开 非公开的修饰符</p></li></ul><h4 id="获取方法的字节码对象"><a href="#获取方法的字节码对象" class="headerlink" title="获取方法的字节码对象"></a>获取方法的字节码对象</h4><ul><li><p>获取公开的方法：getmethod()</p><pre class="line-numbers language-Java"><code class="language-Java">Method method = aClass1.getMethod("方法名");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取非公开的方法：getDeclaredMethod()</p></li></ul><h4 id="获取内部类的字节码对象"><a href="#获取内部类的字节码对象" class="headerlink" title="获取内部类的字节码对象"></a>获取内部类的字节码对象</h4><ul><li><p>获取所有的内部类：getClasses</p><pre class="line-numbers language-Java"><code class="language-Java">//通过外部类获取非静态内部类Class<?>[] classes = aClass.getClasses();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>判断是否是静态内部类</p><pre class="line-numbers language-Java"><code class="language-Java">Modifier.isStatic(modifiers);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>注意：获取所有的内部类后，如果要判断是否是静态内部类 则</p></li><li><p>需要先获取修饰符对象，然后使用 ：Modifier.isStatic静态方法判断</p></li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li><p>扩展类加载器</p></li><li><p>启动类加载器</p></li><li><p>应用类加载器</p></li><li><p>Classpath:类路径，就是字节码文件所在的路径</p><ul><li>（src下面就是第一级包）第一级包就是类路径的开始。</li></ul></li><li><p>那些内容可以加载进类路径：</p><ol><li>sre中的资源</li><li>被标记成resources root目录下的资源</li><li>第三方jar包</li></ol></li><li><p>打包jar包的方法</p><ol><li>选择左上角File –&gt; Project Student…（资源包）</li><li>选择 Artifacts(构建) –&gt;点击+号 —&gt;点击JAR –&gt;Form modules……</li><li>第一行选择你要打包的模块名 —&gt;第二行 选择你模块中要运行的主类名。</li><li>第一个选项是将其抽取为一个目标的jar，</li><li>再下面是默认的文件保存位置</li><li>弹出提示框，可以修改文件的输出目录。</li><li>选择上方的Build,选择Build Artifacts，选择模块名，选择Build.</li><li>程序中的配置文件要放到resources 目录（resources自己创建的文件夹，注意要修改类型）</li></ol></li></ul><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><ul><li><p>注释：解释说明代码的—-程序员看的</p></li><li><p>注解：解释说明代码的——程序看的</p></li><li><p>注解语法格式：</p><pre class="line-numbers language-Java"><code class="language-Java">元注解Pbulic @interface 注解名｛        属性；｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注解的属性</p><ul><li>注解的本质是接口，注解是jdk1.5出现的，所以注解使用的是1.5时候的接口，1.5的接口只有常量值和抽象方法。也就是注解中的属性要么是常量值；要么是抽象方法来表示</li><li>结论：注解中的属性是抽象方法</li><li>方法名就是属性名</li><li>方法的返回值类型就是属性的数据类型。</li></ul></li><li><p>注解中的属性的数据类型只能是：</p><ol><li>.基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>Class</li><li>以上数据类型的数组</li></ol></li><li><p>属性的使用细节：</p><ol><li>属性可以有默认值；如果属性有默认值，那么使用注解的时候，该属性可以不用显示赋值</li><li>如果属性的名称叫做value，那么使用注解的时候，只单独使用value属性时，属性名可以省略不写，但是如果使用多个属性的时候value不能省略</li><li>注解中数组使用｛｝表示；使用注解的时候，如果｛｝中只有一个值时，｛｝可以省略不写</li><li>多个属性之间使用逗号分隔。</li></ol></li><li><p>内置的元注解：</p><ol><li>@target : 标记定义的注解可以贴在那些地方</li><li>@Retention : 表示注解可以保留到什么阶段。</li></ol></li><li><p>注解有三个功能：</p><ol><li>我们只能用一个就是用来“简化代码”。</li></ol></li></ul><h2 id="lambda表达式和Stream流"><a href="#lambda表达式和Stream流" class="headerlink" title="lambda表达式和Stream流"></a>lambda表达式和Stream流</h2><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><ul><li><p>是用来简化函数式接口的匿名内部类代码的。</p></li><li><p>函数式接口：只有一个抽象方法的接口，使用@FunctionalInterface进行注解</p></li><li><p>语法：</p><pre class="line-numbers language-Java"><code class="language-Java">（参数列表）-> {        函数体；        [return  [返回值];]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>方法引用</p><ul><li>当lambda表达式的函数体中只有一条语句且这条语句是调用其他方法完成功能，那么此时就可以使用方法引用简化lambda表达式</li><li>注意：函数体中的方法需要使用到参数列表中的参数</li></ul></li><li><p>简化语法：</p><ol><li>对象：：实例方法</li><li>类名：：静态方法</li><li>类名：：实例方法</li></ol><ul><li>注意：当lambda表达式的函数体中只有一条语句且这条语句是调用其他方法完成功能，同时参数列表的第一个参数作为方法的调用者，其余参数作为方法的参数传递，此时可以使用 第三种方法 3.类名：：实例方法</li></ul></li><li><p>构造方法引用</p><ul><li>当lambda表达式的函数体中只有一条语句，返回值为需要创建的对象类型，没有参数为无参构造，有参数为有参构造。</li></ul></li><li><p>简化语法</p><ol><li>类名：：new</li></ol></li></ul><h4 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h4><ul><li><p>Stream中的方法分为中间操作和终端操作</p><ul><li><p>中间操作：方法的返回值是Stream，该方法就是中间操作</p></li><li><p>终端操作：方法的返回值不是stream，该方法就是终端操作</p></li></ul></li><li><p>注意：终端操作不能写多个，想写多个只能重写多个流</p></li><li><p>顺序流：Stream（单线程的流）</p></li><li><p>并行流：parallelStream（多线程的流）</p></li><li><p>创建流的方法：</p><pre class="line-numbers language-Java"><code class="language-Java">集合名.stream()//创建单线程流集合名.parallelStream()//创建多线程流<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>Stream的静态方法：of()   iterate()    generate()</p><ul><li><p>of():直接添加元素在流中，返回一个流</p></li><li><p>iterate():无限迭代数据（limit可以设置迭代个数）（skip设置跳过几个数据）</p></li><li><p>generate()：无限的生成数据。</p></li></ul></li><li><p>stream流的常用方法：</p><ul><li><p>遍历：forEach ： 遍历流中的元素</p></li><li><p>过滤：filter：根据条件筛选出想要的元素</p></li><li><p>查找：</p><ol><li><p>findFirst()：找出集合中的第一个元素</p></li><li><p>findAny()：配合并行流使用，找出任意一个线程的头元素。</p></li></ol></li><li><p>匹配：</p><ol><li>anyMatch():只要有任意一个元素匹配条件则返回true</li><li>allMatch():需要所有元素匹配条件则返回true</li></ol></li></ul></li><li><p>收集元素：collect()</p></li><li><p>收集器工具类：Collectors()</p></li><li><p>聚合：（max&#x2F;min&#x2F;count）</p><ul><li>Max:默认获取字符最长的元素</li><li>Min:默认获取字符最短的的元素</li><li>注意：如果需要获取字节的长度，需要使用getBytes()方法转换</li><li>Count:获取元素的个数</li></ul></li><li><p>映射：（map&#x2F;flatMap）</p><ul><li>map的特点：流进一个，流出一个（一对一的关系）</li><li>flatMap的特点：进去一个，可以出来多个 （一对多的关系）</li></ul></li><li><p>归约：（reduce）</p><ul><li><p>归约：也称 缩减，顾名思义，是把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作。</p></li><li><p>归约中有三个重载方法（下列例子中演示的为集合中元素求和）</p><ol><li><p>只有一个参数的</p><pre class="line-numbers language-Java"><code class="language-Java">/*Optional<Integer> reduce1 = stream.reduce((a, b) -> {    System.out.println("a=" + a + " ,b=" + b);    //流中执行的规则      a=2 ,b=4      a=6 ,b=6      a=12 ,b=7      a=19 ,b=8      a=27 ,b=9      36    return a + b;});*/Optional<Integer> reduce = stream.reduce((a, b) -> a + b);Optional<Integer> reduce = stream.reduce((a, b) -> Integer.sum(a,b));Optional<Integer> reduce = stream.reduce(Integer::sum);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>有两个参数的</p><pre class="line-numbers language-Java"><code class="language-Java">//identity参数：恒等的，在流中给第一个变量赋上一个初始值Integer reduce = stream.reduce(0, (a, b) -> a + b);Integer reduce = stream.reduce(10, (a, b) -> a + b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>有三个参数的</p><ul><li>注意：第三个参数，只有在并行流中才能执行，在顺序流中不会执行</li></ul><pre class="line-numbers language-Java"><code class="language-Java">//  第一个参数表示赋一个初始值//  第二个参数accumulator表示 线程内部累加//  第三个参数combiner表示 线程之间累加//  线程每次都会获取identity进行操作Stream<Integer> stream = list.parallelStream();Integer reduce = stream.reduce(10, (a, b) -> a + b, (x, y) -> x + y);Integer reduce = stream.reduce(10, Integer::sum, (x, y) -> x + y);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ul></li><li><p>归集：（toList&#x2F;toSet&#x2F;toMap）</p><ul><li>toList：将收集器收集到的元素打包成List集合返回</li><li>toSet：将收集器收集到的元素打包成 set集合返回</li><li>toMap：将收集器收集到的元素打包成map集合返回</li></ul></li><li><p>统计：(count&#x2F;averaging)</p><ul><li><p>注：以下全是收集器工具类中的方法</p></li><li><p>计数：counting()</p></li><li><p>平均值：averagingInt、averagingLong、averagingDouble</p></li><li><p>最值：maxBy、minBy</p></li><li><p>求和：summingInt、summingLong、summingDouble</p></li><li><p>统计以上所有：summarizingInt、summarizingLong、summarizingDouble</p></li></ul></li><li><p>分组：（partitioningBy&#x2F;groupungBy）</p><ul><li><p>partitioningBy: 将元素通过某个条件分割为两个区</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//根据工资将元素分为是否高于7000的两个区</span>Map<span class="token operator">&lt;</span>Boolean<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Student<span class="token operator">>></span> collect <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">partitioningBy</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">getWages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">7000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>groupungBy： 根据条件将元素分割为多个区，可使用多个条件分割多次</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//根据所在地将元素分隔成多个区</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Student<span class="token operator">>></span> collect <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li><p>拼接：joining：收集器里面的方法，元素拼接在一起</p><pre class="line-numbers language-java"><code class="language-java">将所有的元素的名字拼接起来String collect <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>自然排序：(sorted()) </p><ul><li><p>元素类需要实现comparable接口，重写方法</p></li><li><p>注意：实现接口时需要使用泛型。</p><pre class="line-numbers language-Java"><code class="language-Java">Stream<Student> sorted = stream.sorted();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>比较器排序：comparator</p><ul><li><p>排序规则反转方法：reversed()</p></li><li><p>二次排序方法：thenComparing（）</p></li><li><p>注意：使用二次排序前 必须使前一个条件使用lambda方式书写成：对象：：方法</p><pre class="line-numbers language-Java"><code class="language-Java">//自定义排序规则Stream<Student> sorted1 = stream.sorted((a,b) -> b.getId() - a.getId());Stream<Student> sorted1 = stream.sorted(Comparator.comparingInt(s -> s.getId()));Stream<Student> sorted1 = stream.sorted(Comparator.comparingInt(Student::getId).reversed());//二次排序的方法Stream<Student> sorted = stream.sorted(Comparator.comparingDouble(Student::getWages).reversed().thenComparingInt(Student::getId));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>Stream流的静态方法：</p><ul><li><p>提取：Stream.iterate() ：定义初始值，取出什么值 </p><ul><li><p>提取多少个limit（）</p></li><li><p>是否需要跳过多少个  skip() </p><pre class="line-numbers language-Java"><code class="language-Java">//提取出3,4,5,6,7System.out.println(Stream.iterate(1, a -> a + 1).skip(2).limit(5).collect(Collectors.toList()));//提取出3,4,5System.out.println(Stream.iterate(1, a -> a + 1).limit(5).skip(2).collect(Collectors.toList()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>组合：Stream.concat() : 将两个流组合成一个流。</p><ul><li><p>去除重复值：distinct()</p><pre class="line-numbers language-Java"><code class="language-Java">//创建两个流Stream<String> stream = list.stream();Stream<String> stream1 = list1.stream();//合并两个流,然后去除重复值，在返回成一个数组List<String> collect = Stream.concat(stream,stream1).distinct().collect(Collectors.toList());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javaSE学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyMarkdown</title>
      <link href="/2020/07/16/Markdown/"/>
      <url>/2020/07/16/Markdown/</url>
      
        <content type="html"><![CDATA[<ol><li><p>字体加粗：** 文本 **，不要加空格，下同。</p></li><li><p>斜体：* 文本 * </p></li><li><p>斜体加粗： ** * 文本 * **</p></li><li><p>删除线： ~~ 文本 ~~</p></li><li><p>引用 ： &gt; + 空格</p></li><li><p>分割线：— + 换行符  或者 *** + 换行符</p></li><li><p>添加图片：<img src="D:/course11/note/图片路径" alt="图片名"></p></li><li><p>添加超链接： [文本] (网址)</p></li><li><p>有序列表：1. + 空格</p></li><li><p>无序列表：- + 空格</p></li><li><p>博客令牌密码：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</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
