<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL学习笔记</title>
      <link href="/2022/08/18/MySQL/"/>
      <url>/2022/08/18/MySQL/</url>
      
        <content type="html"><![CDATA[<h1><center> MySQL</center><hr><h2 id="数据库的相关概念"><a href="#数据库的相关概念" class="headerlink" title="数据库的相关概念"></a>数据库的相关概念</h2><h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><ul><li>表达形式：多种表现形式：文本，图形，音频，视频。</li></ul><h4 id="数据库（Database，DB）"><a href="#数据库（Database，DB）" class="headerlink" title="数据库（Database，DB）"></a>数据库（Database，DB）</h4><ul><li>存放数据的仓库，存放在计算机中，按照一定的格式存放，可为用户共享</li></ul><h4 id="数据库管理系统（Database-Management-System-DBMS）"><a href="#数据库管理系统（Database-Management-System-DBMS）" class="headerlink" title="数据库管理系统（Database Management System, DBMS）"></a>数据库管理系统（Database Management System, DBMS）</h4><ul><li>数据库管理系统就是科学的组织和存储数据，高效的获取和维护数据，</li><li>市面上常用的：Oracle MySQL SQL Server  DB2</li></ul><h4 id="数据库应用程序（DBAS）"><a href="#数据库应用程序（DBAS）" class="headerlink" title="数据库应用程序（DBAS）"></a>数据库应用程序（DBAS）</h4><ul><li>在数据库系统基础上，使用数据库管理系统的语法，开发的直接面对最终用户的应用程序</li><li>例如：学生管理系统、人事管理系统、图书管理系统</li></ul><h4 id="数据库管理员（Database-Administrator-DBA）"><a href="#数据库管理员（Database-Administrator-DBA）" class="headerlink" title="数据库管理员（Database Administrator, DBA）"></a>数据库管理员（Database Administrator, DBA）</h4><ul><li>数据库管理系统的操作者</li></ul><h4 id="最终用户"><a href="#最终用户" class="headerlink" title="最终用户"></a>最终用户</h4><ul><li>数据库应用程序的使用者</li></ul><h4 id="数据库系统"><a href="#数据库系统" class="headerlink" title="数据库系统"></a>数据库系统</h4><ul><li><p>数据库 + 数据库管理系统 + 数据库应用程序 + 最终用户</p><p><img src="/images/MySQL/DB.jpg" alt="DB"></p></li></ul><h4 id="数据库的发展阶段"><a href="#数据库的发展阶段" class="headerlink" title="数据库的发展阶段"></a>数据库的发展阶段</h4><ol><li><p>网状数据库</p></li><li><p>层次数据库</p></li><li><p>关系数据库</p><ul><li><p>采用关系[二维表]存储与管理数据</p></li><li><p>采用结构化查询结构（sql）作为客户端数据库服务器之间沟通的桥梁</p></li></ul></li></ol><h4 id="NOSQL数据库"><a href="#NOSQL数据库" class="headerlink" title="NOSQL数据库"></a>NOSQL数据库</h4><ul><li>Not only sql数据库 泛指非关系数据库。</li><li>关系数据库在超大规模和高并发的web2.0纯属动态网站已经显示力不从心，暴露了很多难以克服的问题。Nosql数据库的产生就是为了解决大无框数据集合多重数据种类带来的挑战，尤其是大数据应用难题</li><li></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/15/hello-world/"/>
      <url>/2022/08/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 世界 ！你好 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaSE学习笔记</title>
      <link href="/2022/08/14/javase/"/>
      <url>/2022/08/14/javase/</url>
      
        <content type="html"><![CDATA[<h1><center>javase</center></h1><hr><h2 id="编程语法及规则与规范"><a href="#编程语法及规则与规范" class="headerlink" title="编程语法及规则与规范"></a>编程语法及规则与规范</h2><h4 id="编辑阶段的整体注意点"><a href="#编辑阶段的整体注意点" class="headerlink" title="编辑阶段的整体注意点"></a>编辑阶段的整体注意点</h4><ul><li><p>见名知意、注意缩进、成对编程；</p></li><li><p>严格区分大小写，英文大写字母与小写字母意义不一样；</p></li><li><p>都是英文标点符号；</p><p>–&gt; 经典错误：”非法字符”：’\uff09’ –&gt; 使用了中文的标点符号；</p></li><li><p>main方法写法固定，是程序的入口，能被虚拟机识别并执行。</p></li></ul><h4 id="关于定义类的注意点？"><a href="#关于定义类的注意点？" class="headerlink" title="关于定义类的注意点？"></a>关于定义类的注意点？</h4><ul><li><p>使用public修饰的类，该类的名字必须和源文件名字保持一致，否则就会编译错误；</p></li><li><p>在源文件中，我们可以使用class来定义任意多个类，编译后就会生成任意多个字节码文件。</p><p>–&gt; 编译后，没有类都会生成一个字节码文件，并且字节码文件名字就是类名。</p></li><li><p>在源文件中，我们可以定义多个类，但是最多只能有一个类使用public修饰（0或1）。</p></li></ul><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ol><li>单行注释<ul><li>快捷键：ctrl + &#x2F;</li><li>语法：&#x2F;&#x2F;</li></ul></li><li>多行注释<ul><li>快捷键：ctrl + shift + &#x2F;</li><li>语法：&#x2F;* 注释内容 *&#x2F;</li></ul></li><li>文档注释<ul><li>语法：&#x2F;** 注释内容 *&#x2F;</li></ul></li></ol><h4 id="常见的转义字符"><a href="#常见的转义字符" class="headerlink" title="常见的转义字符"></a>常见的转义字符</h4><ul><li>\t –&gt; 制表符。作用：显示多个空格，并且还有对齐的功能；</li><li>\n –&gt; 换行符。作用：具有换行功能。</li><li>\“，编译时，把它当成一个整体，不作为字符串结束的标记；运行时，会忽略反斜杠，只会展示出一个双引号。</li><li>\‘，编译时会把它当成一个整体，运行时只会展示出一个单引号。</li></ul><h4 id="关于字符的使用"><a href="#关于字符的使用" class="headerlink" title="关于字符的使用"></a>关于字符的使用</h4><ol><li><p>方式一：把字符放在字符串内部使用！</p><ul><li>System.out.println(“hello\tworld”);</li></ul></li><li><p>方式二：把字符串单独使用，然后再使用+来拼接。</p><ul><li>System.out.println(“hello” + ‘\t’ + “world”);</li></ul><p><strong>注意：</strong></p><ul><li>int类型和char类型做“+”运算，则做的是“加法操作”。</li><li>String类型和char类型做“+”运算，则做的是“连接符操作”。</li></ul></li><li><p>关于Unicode值得补充</p><ul><li>因为java语言默认采用Unicode编码表，因此每个”字符”都对应一个Unicode值，其中一个Unicode值我们必须掌握</li><li>‘\u0000’代表的是空格字符</li></ul></li></ol><h4 id="理解编译和反编译"><a href="#理解编译和反编译" class="headerlink" title="理解编译和反编译"></a>理解编译和反编译</h4><p>编译：把源文件编译为字节码文件，也就是把”*.java”文件编译为”.class”文件</p><p>反编译：把字节码文件编译为源文件。</p><p><strong>反编译的实现方式：</strong></p><p><strong>方式一：提供javap.exe来实现</strong></p><ul><li>实现：在字节码文件所在目录中，我们通过javap.exe来实现反编译，例如:javap HelloWorld04</li><li>优点：能看到编译时期默认做的操作，例如<strong>能看到编译时期默认提供的无参构造方法</strong>。</li><li>缺点：反编译之后，我们无法看到方法内部的具体实现，也就是看不到方法体。</li></ul><p><strong>方法二：通过jd-gui.exe来实现</strong></p><ul><li>实现：打开jd-gui.exe程序，然后把需要反编译的字节码文件拖拽进入jd-gui.exe程序中即可。</li><li>优点：反编译之后，<strong>我们能够看到方法内部的具体实现，也就是能看到方法体。</strong></li><li>缺点：不能看到编译时期默认做的操作，例如无法看到编译时期默认提供的无参构造方法。</li></ul><p><strong>方法一与方法二可以看作是互补的。</strong></p><h4 id="文件存储的的单位"><a href="#文件存储的的单位" class="headerlink" title="文件存储的的单位"></a>文件存储的的单位</h4><p>实际开发中，我们把字节称之为文件存储的最小单位。</p><p>开发中，<strong>字节有两种表示方式</strong>，分别为：</p><ol><li><p>无符号表示</p><p>（只能表示正数，不能表示负数）</p><ul><li>1个字节无符号表示的数值范围在【0,2^8-1】之间，也就是表示范围在【0,255】之间。</li><li>作用：基本数据类型中，char类型采用的就是无符号来表示。</li></ul></li><li><p>有符号表示</p><p>（不但能表示正数，还能表示负数）</p><ul><li>1个字节有符号表示的数值范围在[-2^ 7,2^7-1]之间，也就是表示范围在[-128,127]之间。</li><li>作用：基本数据类型中，byte、short、int和long类型采用的就是有符号来表示。</li></ul></li><li><p>常见的文件存储单位及其换算公式</p><ul><li>1KB &#x3D; 1024Byte</li><li>1MB &#x3D; 1024KB</li><li>1GB &#x3D; 1024MB</li></ul></li><li><p>问题</p><p>：长度单位的换算使用的是1000，为什么文件存储单位换算使用的是1024呢？</p><ul><li>答：二进制早期有电信号开关演变而来，也就是意味着文件存储的换算肯定使用的是2的多少次方，而2的10次方结果就是1024，也就是2^10是最接近于1000的整数，因此就使用了1024来作为文件存储的换算值。</li></ul></li></ol><h4 id="标识符的作用"><a href="#标识符的作用" class="headerlink" title="标识符的作用"></a>标识符的作用</h4><ul><li>标识符就是给类名、方法名、变量名、常量名和包名命名的规则。</li></ul><h4 id="标识符的规则"><a href="#标识符的规则" class="headerlink" title="标识符的规则"></a>标识符的规则</h4><ol><li>必须由数字、字母、下划线和&amp;组成，并且开头不能是数字。</li><li>标识符不能是关键字或保留字，因为关键字和保留字是给编程语言使用。</li><li>在java语言中，对于标识符的长度没有任何限制，也就是标识符可以任意长。<ul><li>补充：java语言默认采用Unicode编码表，而Unicode编码表几乎包含了全世界所有的文字。</li><li>注意：此处的“字母”我们应该广义地去理解，也就是此处“字母”可以是“英文”，也可以是“中文”。</li><li>建议：给标识符进行命名的时候，我们不建议使用“中文汉字”来进行命名。</li></ul></li></ol><h4 id="命名规范的讲解"><a href="#命名规范的讲解" class="headerlink" title="命名规范的讲解"></a>命名规范的讲解</h4><p>明确：命名的时候不建议使用”中文汉字“，并且还必须做到“见名知意”的要求。</p><p>类名：必须遵守“大驼峰”的命名规范，大驼峰：每个单词首字母都大写。</p><ul><li>例如：HelloWorld、VariableDemo</li></ul><p>方法名、变量名：必须遵守“小驼峰”的命名规则，小驼峰：第一个单词首字符小写，从第二个单词起首字母都大写。</p><ul><li>例如：userName、maxValue</li></ul><p>常量名：必须遵守“字母全部大写，多个单词之间以下划线连接”的命名规范。</p><ul><li>例如：USER、NAME</li></ul><p>包名：必须遵守“单词全部小写，多个单词之间以 ‘.’ 连接，并且必须做到顶级域名倒着写”的命名规范。</p><hr><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h4 id="数据类型的分类"><a href="#数据类型的分类" class="headerlink" title="数据类型的分类"></a>数据类型的分类</h4><ol><li><p><strong>基本数据类型【八大基本数据类型】</strong></p><ul><li><p>整数型：byte、short、int、long</p></li><li><p>浮点数：float、double</p></li><li><p>布尔型：boolean</p></li><li><p>字符型：char</p></li></ul></li><li><p><strong>引用数据类型</strong></p><ul><li>数组、字符串、类和接口等等</li></ul></li><li><p><strong>整数型（有符号表示）</strong></p><ul><li><p>byte，占用1个字节，则表示范围在[-2^7, 2^7-1]之间，–&gt; [-128, 127]。</p></li><li><p>short, 占用2个字节，[-2^15, 2^15-1], –&gt; [-32768,32767]。</p></li><li><p>int, 占用4个字节，[-2^31, 2^31-1], –&gt; 大概在正负21亿之间。</p></li><li><p>long, 占用8个字节，[-2^63, 2^63]。</p></li><li><p><strong>注意：</strong></p><ul><li><p>占用的字节数越大，则表示的数值范围也就越大，开发中我们需要根据存储数值的大小来选择合适的数据类型。</p><p>–&gt; 存储的数值大小不能超出其数据类型的表示范围，否则就会编译错误。</p><p>–&gt; 实际开发中，byte和short几乎不会使用。存储较小的数值使用int，存储较大的数值使用long。</p></li><li><p>开发中，只能使用八进制、十进制、十六进制来表示整数，不能“直接”使用二进制来表示整数。</p><ol><li>int num1 &#x3D; 017：八进制；</li><li>int num1 &#x3D; 23：十进制；</li><li>int num1 &#x3D; 0x2B：十六进制；</li></ol></li><li><p>整数固定值常量默认为int类型,在整数固定值常量的末尾添加”L”【推荐】或”l”，则该常量就变为Long类型。</p></li></ul></li></ul></li><li><p><strong>浮点型（小数）</strong></p><ul><li>float，占用4个字节，我们称之为“单精度类型”，理论上能精确到小数点后7位。</li><li>double，占用8个字节，我们称之为“双精度类型”，理论上精确度是float的两倍。</li></ul><p><strong>注意：</strong></p><ul><li><p>占用的字节数越大，则表示小数的精确度就越高，开发中我们建议使用double类型。</p><p>–&gt; 开发中，float类型很少使用，因为精确度太低，而double类型很常用。</p></li><li><p>小数的表示方式有：1）生活中的表示小数；2）使用科学计数法来表示小数。</p><p>–&gt; 3.14E3，等效于：3140.0 –&gt; “乘以10的3次方”</p><p>–&gt; 3.14E-3，等效于：0.00314 –&gt; “除以10的3次方”</p></li><li><p>注意：使用科学计数法来表示小数的时候，此处的英文字母不区分大小写（E或e）。</p></li><li><p>因为小数存储的区别，因此不建议使用小数来做特别精确的运算，因为得到结果可能不精确。</p><p>–&gt; double sum &#x3D; 0.001 + 0.0002; 理论结果是：0.0003 实际结果：0.000300000000000000000003</p></li><li><p>小数固定值常量默认为double类型，在小数固定值常量末尾添加”F”【推荐】或”f”，则该常量就变为：float类型。</p></li><li><p>浮点型占用的字节数，强调的是存储”小数部分”占用的字节数，并不是强调存储”整数部分”占用的字节数。</p><p> <strong>–&gt; float类型存储”整数部分占用8个字节”，存储”小数部分占用4个字节”，总计至少占用12个字节。</strong>【底层（科学计数法）】</p></li></ul></li><li><p><strong>布尔型(boolean)</strong></p><ul><li><p>明确：布尔类型的固定值常量只有true和false，并且true和false都是关键字。</p><p>–&gt; true：表示为真或条件成立</p><p>–&gt; flase：表示为假或条件不成立</p></li><li><p>使用场合：常用于条件判断，条件成立则返回true，条件不成立则返回false。</p></li><li><p><strong>面试题：请问boolean类型占用几个字节？</strong></p><p>–&gt; 在java规范中，没有明确boolean类型占用几个字节。我个人觉得boolean类型占用x个字节，并说出理由！</p></li></ul></li><li><p><strong>字符型(char，无符号表示)</strong></p><ul><li>明确：字符型占用2个字节数，表示的数值范围在[0,2^16-1]之间，也就是表示范围在[0,65535]之间。</li><li>注意：使用单引号包裹的一个字符串，我们就称之为字符固定值常量。</li></ul></li><li><p><strong>字符串类型？</strong></p><ul><li><p>明确：字符串类型的名字叫做String类型，并且String类型属于”引用数据类型”。</p></li><li><p>注意：使用双引号包裹的任意多个字符，我们就称为“字符串固定值常量”。</p><p>–&gt; 双引号包裹的0个字符，我们就称之为”空字符串”。</p></li></ul></li><li><p><strong>关于”+”的作用</strong></p><ul><li>表示正数。eg:int num &#x3D; +8;</li><li>加法运算，要求两个操作数都必须是数值型。eg:int sum &#x3D; 5 + 8;</li><li>连接符，要求其中一个操作数必须是字符串类型。eg:”hello” + true;</li><li>结论：字符串的连接符操作，则运算完毕后返回的结果肯定属于String类型。</li></ul></li></ol><h4 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h4><ol><li><p>为什么需要学习数据类型的转换?</p><ul><li>因为java是强类型的语言，因此参与“赋值运算”和“算数运算”的时候，要求参与运算的数据类型必须保持一致，否则就需要做数据类型转换。</li></ul></li><li><p>基本数据类型转换的方式有哪些？</p><ul><li>隐式类型转换（自动）</li><li>强制类型转换（手动）</li></ul></li><li><p>哪些基本数据类型可以相互转换？</p><ul><li>除了boolean类型外，其余的基本数据类型都可以相互转换。</li></ul></li><li><p>隐式类型转换（自动）</p><ul><li>原则：低字节向高字节自动提升。</li><li>byte –&gt; short –&gt; int –&gt; long –&gt; float –&gt; double</li><li>char –&gt; int</li></ul><p>赋值运算：</p><ul><li><p>原则：低字节向高字节自动提升。</p></li><li><p>特例：把int类型的常量，赋值给byte、short和char类型的变量或final修饰的常量时，则就是属于隐式类型转换的特例。只需赋值的数据没有超出其数据类型的表示范围即可。</p><p>–&gt; 赋值的数据应该是什么？赋值的数据应该是int类型的常量！</p><p>–&gt; 赋值数据的大小是什么？赋值数据的大小不能超出其数据类型的表示范围。</p></li></ul><p>算术运算</p><p> 原则：两个操作数做运算，如果其中一个操作数为double类型，则另外一个操作数也会隐式转化为double类型；<strong>否则</strong>，如果其中一个操作数为float类型，则另外一个操作数也会隐式转化为float类型，最终计算结果就是float类型；<strong>否则</strong>，如果其中一个操作数为long类型，则另外一个操作数也会隐式转化为long类型，最终计算结果就是long类型;<strong>否则</strong>，这两个操作数都会隐式转化为int类型，最终计算的结果就是int类型。</p></li></ol><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><ul><li><p>当隐式类型转换无法解决问题时，我们要采用强制类型转换。</p></li><li><p>语法：目标类型 变量 &#x3D; （目标类型） 数据；</p><p>eg: int num &#x3D; (int) 3.14; –&gt; 可以用来小数取整。【<strong>一、想要的精度丢失</strong>】</p></li><li><p><strong>底层：只保留低位字节的二进制，高位字节的二进制就丢弃。</strong></p></li><li><p>注意：使用强制类型转换的时候，可能就丢失精度，使用的时候切记。【<strong>二、不想要的精度丢失</strong>】</p><p>–&gt; int num &#x3D; (int) 3.14; 只保留了整数位，丢失了小数位。</p></li><li><p><strong>强制类型转换后，被强制转换的变量还是原来的数据类型。</strong></p><p>eg: int num; byte num1 &#x3D; (int) num; –&gt; num (int类型)</p></li><li><p>使用强制类型转换的时候，我们必须明确强制转换数据的范围，否则得到的结果就不准确。</p></li></ul><hr><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><ul><li>“&#x3D;”，作用：把等号右边表达式的结果赋值给等号左边的变量或final修饰的常量保存。</li></ul><h4 id="算法运算符的分类"><a href="#算法运算符的分类" class="headerlink" title="算法运算符的分类"></a>算法运算符的分类</h4><ol><li><p>一元运算符（只需要一个操作数参与运算）</p><p>包含：++、–</p></li><li><p>二元运算符（需要两个操作数来参与运算）</p><ul><li><p>包含：+ 、-、*、&#x2F;、%</p></li><li><p>+：表示正数，加法运算，连接符操作；</p></li><li><p>-：表示负数，减法运算；</p></li><li><p>*：乘法运算</p></li><li><p>&#x2F;：除法运算</p></li><li><p>%：取模运算或取余运算</p><p>–&gt; 作用：获得两个整数相除的余数</p><p>eg：0 % 3 &#x3D; 0 –&gt; <strong>注意：0能被任何数整除。</strong></p><p> 1 % 3 &#x3D; 1</p><p>注意：”除法运算”是获得两个整数相除的”整数位结果”，”取模运算”是获得两个整数相除的”余数”。</p><p>使用场合：</p><ul><li><p>判断m能否被n整除，如果m%n的结果为0，则意味着m能被n整除；如果m%n的结果不为0，则意味着m不能被n整除。</p></li><li><p>“任意数 % m”，则得到的结果肯定在[0,m - 1]之间，例如：”任何数 % 3”，则得到的结果肯定是在[0, 2]之间。</p></li></ul></li></ul></li></ol><h4 id="除法运算符的注意事项"><a href="#除法运算符的注意事项" class="headerlink" title="除法运算符的注意事项"></a>除法运算符的注意事项</h4><ul><li>在java语言中，两个整数做除法运算，则得到的结果肯定为整数。</li><li>在java语言中，做除法运算的时候，分母不能为0，否则就会抛出算数异常（ArithmeticException）。</li></ul><h4 id="比较运算的概述"><a href="#比较运算的概述" class="headerlink" title="比较运算的概述"></a>比较运算的概述</h4><ul><li><p>明确：比较运算符返回的结果肯定是boolean类型。</p></li><li><p>如果条件成立，则返回true；如果条件不成立，则返回false。</p></li><li><p>包含：&gt; 、&gt;&#x3D;、&lt;&#x3D;、&#x3D;&#x3D;、!&#x3D;</p></li><li><p>&#x3D;&#x3D;（等于），判断左右两边的结果是否相等。</p><p>–&gt; 如果左右两边属于“基本数据类型”，则比较左右两边的“数据值”是否相等（掌握）。</p><p>–&gt; 如果左右两边属于“引用数据类型”，则比较左右两边的“地址值”是否相等（了解）。</p></li><li><p>!&#x3D;（不等于），判断左右两边的结果是否不相等。</p><p>–&gt; 如果左右两边属于“基本数据类型”，则比较左右两边的“数据值”是否不想等（掌握）。</p><p>–&gt; 如果左右两边属于“引用数据类型”，则比较左右两边的“地址值”是否不相等（了解）。</p></li><li><p>注意点：</p><ol><li>比较运算符是一个整体，中间不允许条件空格！</li><li>注意区分“&#x3D;”和“”的区别，“&#x3D;”属于赋值运算符，“”属于比较运算符。</li></ol></li></ul><h4 id="逻辑运算符的概述"><a href="#逻辑运算符的概述" class="headerlink" title="逻辑运算符的概述"></a>逻辑运算符的概述</h4><ul><li><p>明确：参与逻辑运算的数据必须是boolean类型，并且逻辑运算符返回的结果肯定是boolean类型。</p></li><li><p>包含：&amp;、|、^、&amp;&amp;、||、!</p></li><li><p>&amp;（与运算符），属于二元运算符</p><p>–&gt; 结论：只要两边都为true，则结果就是true。</p><p> 只要有一边为false，则结果就是false。</p><p><strong>辅助记忆</strong>：小明“与”小红来一趟办公室。</p></li><li><p>|（或运算符），属于二元运算符</p><p>–&gt; 结论：只要两边都为false，则结果就是false。</p><p> 只要有一边为true，则结果就是true。</p><p>辅助记忆：小明“或”小红来一趟办公室。</p></li><li><p>^：异或运算，相同为false，不同为true。</p><p>———————–以上三个开发中不常用，但是结论很重要———————-</p><p>———————–以下三个开发中常用，并且结论也很重要———————-</p></li><li><p>&amp;&amp;（短路与），属于二元运算符</p><ol><li><p>结论1：&amp;和&amp;&amp;的执行结果一样。</p></li><li><p>结论2：&amp;&amp;当左侧表达式为false时，右边不执行，结果直接原样返回左侧结果为false。</p><p> &amp;&amp;当左侧表达式为true时，右边执行，结果直接原样返回右侧结果。</p></li></ol><p>||（短路或），属于二元运算符</p><ol><li><p>结论1：|和||的执行结果一模一样；</p></li><li><p>结论2：如果左侧表达式的结果为true，则右边表达式肯定不会执行，并且原样返回左侧表达式的结果(true)。</p><p> 如果左侧表达式的结果为false，则右侧表达式肯定会去执行，并且原样返回右侧表达式的结果(true|false)。</p></li></ol><p>!（非运算），属于一元运算符。</p><p><strong>使用场合：</strong></p><ul><li>如果<strong>两个条件必须成立才能满足需求</strong>，则这两个条件之间使用“&amp;&amp;”来组织关系；</li><li>如果<strong>两个条件其中一个成立既能满足需求</strong>，则这两个条件之间使用”||”来组织关系。</li></ul></li></ul><h4 id="位运算（了解，建议掌握）"><a href="#位运算（了解，建议掌握）" class="headerlink" title="位运算（了解，建议掌握）"></a>位运算（了解，建议掌握）</h4><ul><li><p>明确：参与位运算的数据应该是整数型，并且位运算返回的结果也是整数。</p></li><li><p>包含：&amp;、|、^、~、&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</p></li><li><p>&amp;（与位运算），属于二元运算符</p><p>结论：位都为1，则结果就是1；位有一个为0，则结果就是0</p><p>使用场合：学习HashMap集合的时候，验证为啥底层的数组空间长度必须为2的整数次幂。</p></li><li><p>|（或为运算），属于二元运算符</p><p>结论：位都为0，则结果就是0；位有一个为1，则结果就是1</p></li><li><p>^（异或位运算），属于二元运算符</p><p>结论：位相同，则为0；位不同，则为1</p><p>特点：对m连续异或n两次，得到的结果依旧为m</p><p> –&gt; m^n ^ n 的结果为m，n^m ^n的结果为m，n ^ n ^ m的结果为m</p></li></ul><p>使用场合：</p><ol><li>使用异或位运算，我们可以实现对数据的”加密”和”解密”操作。<ul><li>加密：对需要加密的数据异或m，则就得到了加密后的结果。</li><li>解密：对加密后的数据继续异或m，则就得到了解密后的结果。</li></ul></li><li>使用异或位运算，用于交换两个变量的值。<ul><li>优点：效率非常高；</li><li>缺点：复杂、不好理解。</li></ul></li></ol><p>~（非位运算符），属于一元运算符</p><p>结论：二进制位取反的含义。0取反的结果就是1，1取反的结果就是0。</p><p>&lt;&lt; （左移位运算）</p><ul><li><p>结论：对m左移n位，则等效于：m * 2n</p><p>–&gt; 此处m可以是正数，也可以是负数！</p><p>特点：左移运算之后，则低位永远补0即可。</p><p>使用场合：对m做乘以2的操作，则最高效的方式为：m &lt;&lt; 1</p><p>(&gt;&gt;右移位运算)</p><ul><li><p>结论：对m右移n位，则等效于：m&#x2F;2n</p><p>–&gt; 此处m必须是正数，不能为负数！</p><p>特点：正数右移，则高位补0；负数右移，则高位补1</p><p>使用场合：对m做除以2的操作，则最高效的方式为：m&gt;&gt;1</p><p>–&gt; 此处m必须有正好，不能为负数！</p></li></ul><p>(&gt;&gt;&gt;无符号右移)</p><ul><li>无论对正数还是负数做无符号右移的操作，则高位永远补0即可。</li></ul></li></ul><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><ul><li><p>语法：数据类型 变量名 &#x3D; 条件表达式？表达式1 : 表达式2；</p></li><li><p>执行：如果”条件表达式”的结果为true，则执行”表达式1“，也就是”把表达式1*的结果赋值给等号左边的变量来保存。</p><p> 如果”条件表达式“的结果flase，则执行“表达式2”，也就是把“表达式2”的结果赋值给等号左边的变量来保存。</p></li><li><p>注意：if…else选择结构在某些情况下可以被三目运算符代替，毕竟这两者都是做的“二选一”的操作。</p></li></ul><hr><h2 id="循环选择结构"><a href="#循环选择结构" class="headerlink" title="循环选择结构"></a>循环选择结构</h2><h4 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h4><ul><li>代码自上而下，依次执行。</li></ul><h4 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h4><ul><li><p><strong>if选择结构</strong></p><ol><li>if单选结构<ul><li>概述：if(条件表达式){ &#x2F;&#x2F;当“条件表达式”的结果为true，则执行此处的代码。}</li><li>注意：<ol><li>此处的“条件表达式”返回的结果必须时Boolean型。</li><li>if选择结构依旧包含在顺序执行中，也就是顺序执行中包含了选择执行。</li></ol></li></ul></li><li>if双选结构</li><li>if多选结构<ul><li>在完整的if多选结构中，有且只能执行一个大括号中的代码（多选一）。</li><li>if，最前面，有且只能有一个（1）</li><li>else if，中间位置，可以有任意多个（0，1，2，…，n）</li><li>else，最后面，最多只能有一个（0或1）</li></ul></li><li>if选择结构的总结<ol><li>如果if选择结构中只有一行代码，则我们还可以省略大括号！省略大括号之后，则编译时会默认添加一个大括号，用于包裹if结构中的第一行代码。</li><li>建议：对于初学者而言，不建议省略if选择结构中的大括号，省略大括号之后可能会带来额外的问题。</li></ol></li></ol></li><li><p><strong>switch选择结构</strong></p><ul><li><p>关于switch关键字的注意点：</p><ul><li>此处“表达式”的结果必须是byte、short、int、char、String和枚举(后面学习)类型 ，别的类型都会编译错误！</li><li>“表达式”的结果不能是boolean类型，因此switch选择结构就不能对布尔类型的数据进行匹配！</li></ul></li><li><p>关于case关键字</p><ul><li><p>case关键字后面必须是“常量”,不能为“变量”，从而保证匹配的安全性！</p></li><li><p>在switch选择结构中，case后面不允许有多个“相同的”常量值，否则就会编译错误！</p></li><li><p>在此处“表达式”结果的类型和case后面“常量值”的类型必须保持一致，否则就会编译错误！</p><p>–&gt; 此处的数据类型必须“保持一致”，包含了“隐式类型转换”之后能保持一致。</p><p>–&gt; 因为“表达式”结果不支持boolean类型，因此case后面就不能为boolean类型的数据，也就是不支持区间判断。</p></li></ul></li><li><p>关于break关键字的注意点：</p><ul><li><p>一旦执行break关键字，则就会跳出switch选择结构，执行switch选择结构之后代码。</p></li><li><p>在switch选择结构中，我们可以省略break关键字，省略break关键字之后，则就会发生“穿透”，直到遇到下一个break才会结束“穿透”。</p></li></ul></li><li><p>关于default关键字的注意点：</p><ul><li>当switch选择结构中的所有case都无法匹配成功，则那么才会去执行default中的代码，此处的default类似于if选择结构中的else代码块。</li><li>在switch选择结构中，虽然可以省略default关键字，但是我们不建议省略，除非case都匹配所有的问题。</li></ul></li><li><p>强调：在某个case中定义的变量，则该变量就只能在当前作用域中使用，不能在别的case中使用！</p></li></ul></li></ul><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><ul><li><strong>for循环</strong><ul><li>for循环结构，我们也称为“带名字的代码块”或“带条件的代码块”，因此在“循环体”中定义的变量不能再循环之外使用。</li><li>在循环体定义的变量，每次执行循环体该变量都“出生”，每次循环体执行完毕该变量都“死亡”。</li><li>问题：想要在循环体中，每次操作的都是同一个变量，则该变量应该定义在哪里？–&gt; 必须定义在循环之前！</li><li>“循环条件表达式”返回的结果必须是boolean类型，但是“循环初始化表达式”和“循环后的操作表达式”没有特殊要求</li></ul></li><li><strong>while循环</strong><ul><li>while循环结构：先进行判断，若返回值为true则进行循环，反之则跳过循环</li></ul></li><li><strong>do…while循环</strong><ul><li>do…while循环：先将方法体执行一遍，然后进行判断，若返回值为true则进入循环，反之则跳过循环</li></ul></li></ul><hr><h2 id="方法的调用及内存分析"><a href="#方法的调用及内存分析" class="headerlink" title="方法的调用及内存分析"></a>方法的调用及内存分析</h2><h4 id="调用方法的内存分析（重点）"><a href="#调用方法的内存分析（重点）" class="headerlink" title="调用方法的内存分析（重点）"></a>调用方法的内存分析（重点）</h4><ol><li>栈内存的特点？<ul><li>栈内存具备“先进后出，后进先出”的特点，类似于生活中的“子弹夹”。</li></ul></li><li>调用方法的内存分析？<ul><li>调用方法的时候，则自动就会在栈内中开辟一个“栈帧”，用于执行该方法体中的代码。–&gt;入栈操作</li></ul></li><li>方法调用完毕的内存分析<ul><li>在方法体中一旦执行“return”关键字，则就证明方法调用完毕，那么调用方法时所开辟的“栈帧”就会被摧毁。–&gt; 弹栈操作</li></ul></li><li>问题：调用方法的时候，实参num1和num2与形参num1和num2是否有关系？<ul><li>答案：此处的“实参”和”形参”没有任何关系，仅仅是”名字”相同而已。</li></ul></li></ol><h4 id="方法的使用（重点）"><a href="#方法的使用（重点）" class="headerlink" title="方法的使用（重点）"></a>方法的使用（重点）</h4><ol><li><p>方法的使用原则</p><ul><li>先声明，后调用。</li></ul></li><li><p>方法声明的难点</p><ol><li>明确1：完成该功能，是否需要返回值。–&gt; 返回值类型</li><li>明确2：完成该功能，是否需要外部参数参与方法内部的运算。 –&gt; 形参列表</li></ol></li><li><p><strong>方法的分类</strong></p><ol><li><p>无参无返回值方法</p><ul><li><p>需求：在方法中输出“hello world”。</p></li><li><p>分析：完成该功能，无需返回值，因此返回值类型为void。</p><p> 完成该功能，无需外部参数参与方法内部运算，因此没有形参。</p></li></ul></li><li><p>无参有返回值方法</p><ul><li><p>需求：调用方法获得常量3+4的和。</p></li><li><p>分析：完成该功能，需要返回值，因此返回值类型为int。</p><p> 完成该功能，无需外部参数参与方法内部的运算，因此没有参数</p></li></ul></li><li><p>有参无返回值方法</p><ul><li><p>需求：在方法中输出指定两个int数据之和。</p></li><li><p>分析：完成该功能，无需返回值，因此返回值类型为void。</p><p> 完成该功能，需要外部参数参与内部的运算，也就是需要两个int类型的形参。</p></li></ul></li><li><p>有参有返回值方法</p><ul><li><p>需求：调用方法获得指定两个double数据之和。</p></li><li><p>分析：完成该功能，需要返回值，因此返回值类型为double。</p><p> 完成该功能，需要外部参数参与方法内部的运算，也就是需要两个double类型的形参。</p></li></ul></li></ol></li></ol><h4 id="方法的重载（overload）重点"><a href="#方法的重载（overload）重点" class="headerlink" title="方法的重载（overload）重点"></a>方法的重载（overload）重点</h4><ol><li><p>方法重载的定义</p><ul><li><p>同一个类中，具有相同的方法名，但是参数个数不同或参数类型不同，这就构成了方法的重载！</p></li><li><p>核心：两同，两不同</p><p>–&gt; 两同：同一个类中，具有同名的方法。</p><p>–&gt;两不同：参数个数不同，参数个数不同 或 参数类型不同。</p></li></ul></li><li><p>方法重载的特点</p><ul><li>修饰符不同，没有构成方法重载；</li><li>形参名字不同，没有构成方法重载；</li><li>返回值类型不同，没有构成方法重载。</li></ul></li><li><p>方法重载的好处</p><ul><li>官方：方法重载的出现，使其同一个类中允许定义多个同名的方法，从而避免了方法名被污染。</li><li>通俗：学习方法重载之后，如果同一个类中多个同名的方法发生了编译错误，则首先考虑这些方法是否满足方法重载!</li></ul></li><li><p>重载方法的调用</p><ul><li>调用重载方法的时候，会根据实参的“个数”和“类型”来选择调用合适的方法。</li></ul></li><li><p>目前已经用过的重载方法有哪些？</p><ul><li>print()、println()等等</li><li>问题：通过IDEA工具，如何查看底层的API源码？</li><li>实现：按下Ctrl键，然后鼠标左键单击即可。</li></ul></li></ol><h4 id="调用方法时，实参传递给形参的过程-超级重点"><a href="#调用方法时，实参传递给形参的过程-超级重点" class="headerlink" title="调用方法时，实参传递给形参的过程(超级重点)"></a>调用方法时，实参传递给形参的过程(超级重点)</h4><ol><li><strong>调用方法时，基本数据类型的传递</strong><ul><li>结论：”基本数据类型”的传递，属于”数据值”的传递。</li><li>解释：”实参”赋值给”形参”之后，则”实参”和”形参”就没有任何联系了，我们在方法中修改”形参”的值，则”实参”的值不会改变。</li></ul></li><li><strong>调用方法时，引用数据类型的传递</strong><ul><li><strong>结论：”引用数据类型”的传递，属于”地址值”的传递。</strong></li><li>解释：”实参”赋值给”形参”之后，则”实参”和”形参”保存的地址值就相同，也就意味着”实参”和”形参”指向了同一块存储空间，<strong>我们在方法中修改”形参”指向存储空间的数据，则”实参”指向该存储空间的数据也被修改了。</strong></li></ul></li></ol><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="数组的声明"><a href="#数组的声明" class="headerlink" title="数组的声明"></a>数组的声明</h4><ul><li>数组就是一个存储“相同数据类型”的“有序”集合（容器）。</li><li>明确：所谓数组的声明，指的就是给数组取一个名字，类似于变量的声明。</li><li>语法1：数据类型[] 数组名;</li><li>语法2：数据类型 数组名[];</li><li>注意：开发中，建议使用“语法1”来声明数组，因为“数据类型[]”代表的是“数组类型”。</li></ul><h4 id="数组的创建"><a href="#数组的创建" class="headerlink" title="数组的创建"></a>数组的创建</h4><ol><li><p>明确：所谓数组的创建，指的就是在内存中为数组开辟存储空间。</p></li><li><p>方式一：动态创建数组（仅仅在内存中开辟存储空间，但没有给数组元素指定赋值）</p><ul><li>语法：数据类型[] 数组名 &#x3D; new 数据类型[空间长度];</li></ul></li><li><p>方式二：静态创建数组（不但在内存中开辟存储空间，并且还给数组元素指定赋值）</p><ul><li><p>语法1：数据类型[] 数组名 &#x3D; {数据1,数据2,数据3,…};</p></li><li><p>语法2：数据类型[] 数组名 &#x3D; new 数据类型[]{数据1,数据2,数据3,…};</p></li></ul></li></ol><h4 id="操作数组元素"><a href="#操作数组元素" class="headerlink" title="操作数组元素"></a>操作数组元素</h4><ul><li><p>明确：想要操作数组元素，则必须通过“索引”来实现，因为通过“索引”就能找到元素对应的存储空间，然后就能做出“赋值”和“取值”的操作。</p></li><li><p><strong>数组的注意点</strong></p><ul><li><p>数组存储的是相同数据类型的元素，则意味着每个元素占用的字节数相同。</p></li><li><p>数组是一块连续的存储空间，则意味着相邻两个元素的存储空间是紧挨着的。</p></li><li><p>创建数组的时候，我们必须明确数组的空间长度，并且数组一旦创建成功，则数组的空间长度就不能改变了。</p></li><li><p>给数组元素赋值的时候，赋值“元素的类型”必须和“声明数组的数据类型”保持一致，否则就会编译错误！</p><pre class="line-numbers language-Java"><code class="language-Java">int[] arr = new int[5];arr[0] = 11;  //没问题arr[1] = "abc";  //编译错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>声明数组的时候，我们可以使用“基本数据类型”来声明数组，也可以使用“引用数据类型”来声明数组。</p><pre class="line-numbers language-Java"><code class="language-Java">int[] arr1；    //基本数据类型String[] arr2;   //引用数据类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>通过索引来操作数组元素的时候，操作的索引值必须合法，如果索引值不合法就会抛出数组索引越界异常。</p><p>明确：数组索引的合法取值范围在[0,数组长度-1]之间，如果索引越界就会抛出数组索引越界异常（ArrayIndexOutOfBoundsException）。</p></li></ul></li></ul><h4 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h4><ul><li>明确：基本数据类型没有属性和方法，但是引用数据类型有属性和方法。</li><li>强调：通过数组的“length”属性，我们可以动态的获得数组的空间长度。</li></ul><h4 id="数组元素的默认值"><a href="#数组元素的默认值" class="headerlink" title="数组元素的默认值"></a>数组元素的默认值</h4><p>明确：通过“动态创建数组”的方式，则数组中每个元素都有默认值，并且元素的默认值规则如下：</p><ul><li>整数型（byte、short、int和long）数组元素的默认值为：0</li><li>浮点型（float和double）数组元素的默认值为：0.0</li><li>布尔型（boolean）数组元素的默认值为：false</li><li>字符型（char）数组元素默认值为：’\u0000’ –&gt; 代表空格字符</li><li>引用数据类型（数组、字符串、类和接口）数组元素的默认值为：Null –&gt; 此处是null关键字，代表的是空对象。</li></ul><h4 id="数组元素的遍历"><a href="#数组元素的遍历" class="headerlink" title="数组元素的遍历"></a>数组元素的遍历</h4><ol><li><p>使用普通for循环来实现</p><ul><li>思路：通过普通for循环，获得[0, 数组长度-1]的合法索引取值，然后再通过索引获得数组元素</li><li>优势：遍历的过程中，可以获得数组的合法索引值，因此遍历过程中我们可以操作数组中的元素。</li><li>劣势：语法复杂，效率较低。</li><li>使用场合：遍历数组的过程中，如果想要获得数组的合法索引取值，或者想要在遍历过程中操作数组元素，则“必须”通过普通for循环来实现。</li></ul></li><li><p>使用增强for循环来实现</p><ul><li><p>语法：</p><pre class="line-numbers language-Java"><code class="language-Java">/*for(数据类型 变量名 : 数组或集合){    //循环体}*/int[] arr = {1,23,4,5};//增强for循环for(int element : arr){   System.out.println(element); }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>优势：语法简洁，效率较高。</p></li><li><p><strong>劣势：遍历的过程中，不能获得数组的合法索引值，因此遍历过程中我们无法操作数组中的元素。</strong></p></li><li><p>使用场合：遍历数组的过程中，如果<strong>无需获得数组的合法索引取值</strong>，也就是遍历数组过程中<strong>无需操作数组元素，</strong>则建议通过增强for循环来实现。</p></li><li><p><strong>快速使用增强for循环来遍历数组：数组名.for + enter</strong></p></li><li><p><strong>强调：通过length属性获得数组空间长度，则该操作的效率是非常低，因此在循环中切记不要使用length属性来获得数组空间长度。</strong></p></li><li><p>**建议定义一个数组长度变量来循环</p></li></ul></li></ol><h4 id="栈内存的概述"><a href="#栈内存的概述" class="headerlink" title="栈内存的概述"></a>栈内存的概述</h4><ul><li><p>存储：局部变量</p><p>–&gt; “基本数据类型”的局部变量，则在栈内存中存储的是”数据值”。</p><p>–&gt; “引用数据类型”的局部变量，则在栈内存中存储的是”地址值”。</p><p>特点：</p><ul><li>栈内存具备”先进后出”或”后进先出”的特点，类似于生活中的”子弹夹”。</li><li>栈内存是一块连续的存储空间，由虚拟机分配，效率高！</li><li>栈内存由虚拟机来管理，也就是无需程序员来手动管理内存。</li><li>虚拟机会为每个线程创建一个栈内存，用于存放该线程执行方法的信息。</li></ul></li><li><p>存储：对象（数组）</p><p>特点：</p><ul><li>堆内存不是一块连续的存储空间，分配灵活，但是效率低。</li><li>堆内存理论上需要程序员来手动管理，但是实际上交由”垃圾回收机制”来管理。</li><li><strong>虚拟机中只有一个堆内存，被所有的线程共享。</strong></li></ul></li></ul><h4 id="数组反转"><a href="#数组反转" class="headerlink" title="数组反转"></a>数组反转</h4><p>需求：将数组元素反转，原数组{5, 12, 54,7676,9}，反转后为：{9, 676, 54, 12, 5}。</p><p>要求：使用两种方式来实现</p><ol><li>方式一：<strong>创建一个新的数组，用于保存反转之后的结果。</strong><ul><li>缺点：<ul><li>需要创建新的数组，浪费了存储空间。</li><li>需要完整遍历整个数组，浪费了执行时间。</li></ul></li></ul></li><li>方式二：<strong>使用“首尾元素交换位置”的思路来实现。</strong><ul><li>优点：<ul><li>无需创建新的数组，节约了存储空间。</li><li>只需遍历数组长度的一半，节约了执行时间。</li></ul></li></ul></li></ol><h4 id="数组工具类"><a href="#数组工具类" class="headerlink" title="数组工具类"></a>数组工具类</h4><ul><li>问题：在前面的学习中，我们把操作数组的静态方法放到了不同的类中，因此想要调用这些静态方法的时候，我们首先得明确该方法在那个类中，然后才能通过“类名”来调用这些静态方法，因此调用这些方法的时候非常不方便。</li><li>解决：定义一个“数组工具类”，然后把操作数组的静态方法都放到该“数组工具类”中。</li></ul><ol><li><p>Arrays工具类的概述</p><ul><li>Arrays工具类在”java.util”包中，因此我们使用Arrays工具类的时候，必须通过import关键字导入Arrays类，然后才能使用Arrays工具类。</li><li>Arrays工具类我们称之为“数组相关的工具类”，在Arrays类中提供了很多操作数组的“静态方法”，因此我们调用这些方法的时候，直接通过类名.来调用。</li></ul></li><li><p>Arrays工具类的方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作用：把数组转换为字符串并返回，也就是获得数组中的元素，然后把这些元素拼接成字符串并返回。</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">fill</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作用：数组的填充操作，把arr数组中的所有元素设置为val</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作用：给数组元素执行“排序”操作，默认为“升序”排序</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作用：对“指定范围”的数组元素执行“升序”排序</span><span class="token comment" spellcheck="true">//范围：从fromIndex索引位置开始（包含），到toIndex索引位置结束（不包含）。</span><span class="token comment" spellcheck="true">//注意：fromIndex取值范围在[0,数组长度-1]之间，toIndex取值范围在[0,数组长度]之间，并且必须满足toIndex大于fromIndex</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    作用：二分查找，查询key在arr数组中的索引位置。    返回值：如果查询元素在数组中存在，则返回该元素在数组中的索引位置；如果查询的元素在数组中不存在，则返回负数即可。*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    作用：对“指定范围”的数组元素执行二分查找操作，此处要求arr数组为升序排序。    范围；从fromIndex索引位置开始（包含），到toIndex索引位置结束（不包含）。    注意：fromIndex取值范围在[0, 数组长度-1]，toIndex取值范围在[0,数组长度]之间，并且必须满足toIndex大于fromIndex。    返回值：如果查询元素在数组中存在，则返回该元素在数组中的索引位置；如果查询的元素在数组中不存在，则返回负数即可。*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> newLength<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    作用：从索引为0的位置开始拷贝，一共拷贝newLength个数组元素并返回。    注意：此处newLength取值范围在[0,数组长度]之间。*/</span>Public <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOfRange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> to<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    作用：拷贝指定索引范围的数组元素    范围：从from索引位置开始（包含），到to索引位置结束（不包含）。    注意：from取值范围在[0,数组长度 - 1]之间，to取值范围在[0,数组长度]之间，并且必须满足to大于from*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*    作用：判断arr1和arr2两个数组是否相等。    返回值：如果arr1和arr2的地址值相等或arr1和arr2的数组元素一一对应，则都返回true，否则一律返回false。*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="方法的可变参数（掌握）"><a href="#方法的可变参数（掌握）" class="headerlink" title="方法的可变参数（掌握）"></a>方法的可变参数（掌握）</h4><p>1、可变参数的引入</p><ul><li><p>需求：定义一个方法，用于获得指定两个int类型数据之和。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> num1<span class="token punctuation">,</span> <span class="token keyword">int</span> num2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="可变参数的语法"><a href="#可变参数的语法" class="headerlink" title="可变参数的语法"></a>可变参数的语法</h4><ul><li><p>语法：数据类型 … 可变参数名</p></li><li><p>eg：int … arr</p></li><li><p><strong>可变参数的注意点</strong></p></li><li><p>“可变参数”必须存在于“形参列表”中，并且“可变参数”必须在形参列表“最末尾”。</p><p>–&gt; 也就是说，方法的形参列表中最多只能定义一个可变参数（0或1）</p></li><li><p>在方法体中，我们可以把可变参数当成“数组”来使用，本质上可变参数就是数组的另外一种语法表现形式。</p><p>–&gt; eg：调用方法的是，实参为”int类型的数组”，则方法的形参可以为“int类型的可变参数”。</p></li><li><p><strong>可变参数的使用场合</strong></p><ul><li>定义一个方法的时候，参数的类型都相同，但是参数的个数不确定时。</li></ul></li></ul><h4 id="数组的核心特点"><a href="#数组的核心特点" class="headerlink" title="数组的核心特点"></a>数组的核心特点</h4><ul><li><p>数组是一块连续的存储空间，则意味着相邻两个元素的存储空间是紧挨着的。</p></li><li><p>数组存储的是相同数据类型的元素，则意味着每个元素占用的字节数相同。</p></li><li><p>常见数组则必须明确数组的空间长度，数组一旦创建成功，则数组的空间长度就不能改变。</p></li><li><p><strong>根据索引操作【改和查】</strong></p><ul><li><p>结论：根据索引操作元素效率非常高，甚至是所有数据结构中效率最高的。</p></li><li><p>依据：数组是一块连续的存储空间，则意味着相邻两个元素的存储空间是紧挨着。</p><p>–&gt; 数组存储的是相同数据类型的元素，则意味着每个元素占用的字节数相同。</p><p>–&gt; <strong>寻址公式：首地址 + 索引值 * 每个元素占用的字节数</strong></p></li></ul></li><li><p><strong>根据索引删除元素【删】</strong></p><ul><li><p>结论：根据索引删除元素的效率非常低，因为需要大量的挪动数组元素。</p></li><li><p>依据：数组是一块连续的存储空间，则意味着相邻两个元素的存储空间是紧挨着。</p><p>–&gt; 常见数组则必须明确数组的空间长度，数组一旦创建成功，则数组的空间长度就不能改变了</p></li></ul></li><li><p><strong>根据索引插入元素【增】</strong></p><ul><li><p>结论：根据索引插入元素的效率非常低，因为需要大量挪动数组元素+扩容操作。</p></li><li><p>依据：数组时一块连续的存储空间，则意味着相邻两个元素的存储空间时紧挨着。</p><p>–&gt; 常见数组则必须明确数组的空间长度，数组一旦创建成功，则数组的空间长度就不能改变啦。</p></li></ul></li></ul><h4 id="二维数组（矩阵，较难）"><a href="#二维数组（矩阵，较难）" class="headerlink" title="二维数组（矩阵，较难）"></a>二维数组（矩阵，较难）</h4><ol><li><p>二维数组的定义</p><ul><li>数组中的每个元素都是一堆数组，这样的数组我们就称之为“二维数组”。</li></ul></li><li><p>二维数组的声明</p><ul><li><p>明确：所谓二维数组的声明，指的就是给二维数组取一个名字，类似于“变量的声明”。</p></li><li><p>语法1：</p><pre class="line-numbers language-Java"><code class="language-Java">//数据类型[][] 数组名；int[][] arr1;String[][] arr2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>语法2：</p><pre class="line-numbers language-Java"><code class="language-Java">//数据类型[] 数组名[];int[] arr1[]String[] arr2[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>注意：实际开发中，我们建议使用”语法1”来声明二维数组，因为“数据类型 [ ] [ ] ”代表的是“二维数组类型”。</p></li></ul></li><li><p>二维数组的创建</p><ul><li><p>明确：所谓二维数组的创建，指的就是在堆内存中为二维数组开辟存储空间。</p></li><li><p><strong>方式一：创建“等长”的二维数组（动态）</strong></p><pre class="line-numbers language-Java"><code class="language-Java">//语法：数据类型[][] 数组名 = new 数据类型[m][n];// m: 设置二维数组得空间长度//n：设置一维数组的空间长度int[][] arr1 = new int[3][3];String[][] arr2 = new String[3][4];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>方式二：创建“不等长”的二维数组（动态）</strong></p><pre class="line-numbers language-Java"><code class="language-Java">//语法：数据类型[][] 数组名 = new 数据类型[m][];//m:设置二维数组的空间长度int[][] arr1 = new int[3][];String[][] arr2 = new String[4][];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>方式三：静态创建的二维数组（静态）(等长|不等长)</strong></p><pre class="line-numbers language-Java"><code class="language-Java">//数据类型[][] 数组名 = {{数据1,数据2}, {数据3,数据4},...}     int[][] arr1 = {{11,22,33},{55,66,77},{13,56,78}};String[][] arr2 = {{"aa","bb"},{"cc","dd","yt"}};//数据类型[][] 数组名 = new 数据类型[][]{{数据1,数据2}, {数据3,数据4},...};     int[][] arr1 = new int[][]{{11,22,33},{55,66,77},{13,56,78}};String[][] arr2 = new String[][]{{"aa","bb"},{"cc","dd","yt"}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>注意：通过大括号创建出来的二维数组，我们无法直接作为方法的”实参”和”返回值”，因为编译器不认识大括号创建的二维数组。</strong></p></li></ul></li></ol><hr><h2 id="异常及断点调试"><a href="#异常及断点调试" class="headerlink" title="异常及断点调试"></a>异常及断点调试</h2><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><ol><li><p><strong>debug调试的作用</strong></p><ul><li>查看代码的执行顺序，分析变量值的变化，从而找到问题的并解决问题。</li></ul></li><li><p><strong>debug的调试步骤</strong></p><ul><li><p>第一步：在代码可能出现问题的位置，我们在该位置打一个断点。</p><p>–&gt; 在该代码行号左侧位置，我们单击打一个断点（红色圆圈）</p></li><li><p>第二步：开启debug调试来执行程序，则代码就会停留在打断点的位置。</p><p>–&gt;方式一： 点击类名或main方法左侧绿色按钮，然后选中”Debug Xxx.main()”即可。</p><p>–&gt; 方式二：在代码编辑区域，我们鼠标右键然后选中”Debug Xxx.main()”即可。</p><p>–&gt; 方式三：已经执行程序后，我们点击工具栏或控制台左侧的”debug按钮”。</p></li><li><p>明确：开启debug调试之后，则就会出现debug窗口，debug窗口的作用如下：</p><p><strong>Debugger</strong></p><ul><li>Frames：显示代码停留的位置（包、类、方法和行号）</li><li>Variables：显示当前方法已经执行过的变量的值</li></ul><p><strong>Console</strong></p><ul><li>显示输出的内容或获取输入的内容。</li></ul></li><li><p>第三步：控制代码的执行，也就是通过Debug窗口来控制代码的执行。</p><ol><li>F8：执行下一行代码。</li><li>F7：进入执行方法体中的代码。</li><li>shift + F8：结束当前方法，回到方法的调用位置。</li><li>Alt + F9：直接执行到下一个断点的位置。</li><li>Alt + F8：计算并执行某行未执行代码的运算结果。</li></ol></li><li><p>第四步：结束debug调试。</p><p>首先，取消断点（单击取消）；然后，结束程序（点击红色按钮）；最后，关闭debug窗口。</p></li></ul></li></ol><h4 id="异常的概述"><a href="#异常的概述" class="headerlink" title="异常的概述"></a>异常的概述</h4><ol><li>什么是异常？<ul><li>程序在执行过程中，发生的各种不正常情况，我们就称之为“异常”。</li><li>例如：算数异常、数组索引越界异常、空指针异常和类型转换异常等等</li></ul></li><li>什么是异常类？<ul><li>用于封装和描述各种不正常情况的类，我们就称之为“异常类”。</li><li>例如：ArithmeticException、ArrayIndexOutOfBoundsException、NullPointerException和ClassCastException等等。</li></ul></li><li>学习异常的好处？<ul><li><strong>a)学习异常之后，就能够实现把“正常逻辑代码”和“错误逻辑代码”相分离。</strong></li><li>b)没有学习异常，则某些情况下无论我们如何处理，则都可能无法满足需求。</li></ul></li><li><strong>异常的处理机制？</strong><ul><li>在java语言中，使用面向对象的思想来处理异常。在可能出现问题的位置，我们创建并抛出一个异常对象，该异常对象中封装了异常的详细描述信息（异常类名、异常位置和异常原因），从而实现“正常逻辑代码”和“错误逻辑代码”相分离。</li></ul></li></ol><h4 id="常见异常"><a href="#常见异常" class="headerlink" title="常见异常"></a>常见异常</h4><ol><li>算数异常（ArithmeticException）<ul><li>原因：做除法操作的时候，如果分母为零，则就会抛出算数异常。</li></ul></li><li>数组索引越界异常（ArrayIndexOutOfBoundsException）<ul><li>原因：根据索引操作数组元素的时候，如果操作的索引值越界，则就会抛出数组索引越界异常。</li></ul></li><li>空指针异常（NullPointerException）<ul><li>原因：我们对空对象做操作，则就会抛出空指针异常。</li></ul></li></ol><h4 id="异常的体系"><a href="#异常的体系" class="headerlink" title="异常的体系"></a>异常的体系</h4><ol><li><p>异常体系的引入</p><ul><li>在程序执行的过程中，可能会发生各种各样的不正常情况，因此我们就需要很多的异常类来封装和描述这些不正常情况，我们对这些异常类进行“向上提取”，那么就得到了异常的继承体系。</li></ul></li><li><p>异常体系的概述</p><ul><li><p><strong>所有Java类的老祖宗为Object类，所有不正常情况类的老祖宗就是Throwable类，那么Throwable类的继承体系如下：</strong></p><pre class="line-numbers language-Java"><code class="language-Java">/*Throwable          --> 所有不正常情况类的老祖宗 |-- Error         --> 所有错误类的老祖宗 |-- Exception     --> 所有异常类的老祖宗 *///注意：a)如何查看某个类的继承体系呢？？？选中该类，然后使用“ctrl + h”来查看继承体系。    // b)所有错误类的后缀都以“Error”来结尾，所有异常类的后缀都以“Exception”来结尾。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>Throwable的概述</p><ul><li><strong>Throwable类是所有不正常情况类的老祖宗，Error类和Exception类都属于Throwable的子类，因此Error类和Exception类都能使用Throwable提供的方法。</strong></li></ul></li><li><p>Error类的概述</p><ul><li><strong>Error类是所有“错误类”的老祖宗，并且Error类继承于Throwable类，因此Error类能使用Throwable类提供的所有方法。</strong></li><li><strong>Error描述的是“资源耗尽”或“虚拟机内部错误”等不正常情况，因此开发中遇到这样的不正常情况，我们程序员是无法解决的（不结束程序的前提来解决），也就是程序员只能先结束程序，然后再去重新修改代码来搞定这种不正常情况</strong>。</li></ul></li><li><p>Exception类的概述</p><ul><li>Exception类是所有“异常类”的老祖宗，并且Exception类继承于Throwable类，因此Exception类能使用Throwable类提供的所有方法。</li><li><strong>Exception类描述的是“程序员能够解决”的不正常情况，开发中我们遇到了Exception异常，则需要拼尽全力去解决该异常（不结束程序的前提来解决）。</strong></li><li><strong>Error属于程序员无法解决的不正常情况，而Exception属于程序员能够解决的不正常情况。</strong></li></ul></li><li><p><strong>Error与Exception的区别</strong></p><ul><li>我开着车走在路上，一头猪冲在路中间，我刹车，这叫一个异常。</li><li>我开着车在路上，发动机坏了，我停车，这叫错误。</li><li>发动机什么时候坏？我们普通司机能管吗？不能。发动机什么时候坏是汽车厂发动机制造商的事。</li></ul></li></ol><h4 id="自定义异常类（掌握）"><a href="#自定义异常类（掌握）" class="headerlink" title="自定义异常类（掌握）"></a>自定义异常类（掌握）</h4><ol><li><p>自定义异常类的引入</p><ul><li>问题：给学生年龄复制的时候，则赋值的年龄不能为负数。</li><li>解决：如果赋值的年龄为负数，则无论我们给年龄赋值任何数据都不合理，那么最好的方案就是如果年龄不合法就抛出异常。</li><li>问题：如果赋值的年龄不合法，则应该抛出“学生年龄不合法异常”，该如何实现？？？</li><li><strong>解决：使用“自定义异常类”来解决。</strong></li></ul></li><li><p>什么时候使用自定义异常类</p><ul><li>当Java语言提供的异常类无法满足我们的需求，则我们就可以使用“自定义异常类”来满足需求。</li></ul></li><li><p>自定义异常类的要求</p><ul><li><p><strong>要求1：自定义异常类必须继承于异常体系中的类，一般继承于Exception类或RuntimeException类。</strong></p><p>–&gt; <strong>只有继承于异常体系的中的类，该类才具备可抛型，也就是才能使用throw和throws关键字。</strong></p></li><li><p>要求2：自定义异常类必须提供两个构造方法，其中一个为无参构造方法，<strong>另外一个为字符串参数的有参构造方法。</strong></p><p> –&gt; <strong>使用字符串参数的有参构造方法，我们可以用于封装和保存异常出现的原因，从而传递给父类的异常来保存。</strong></p></li></ul></li></ol><h4 id="异常产生的过程"><a href="#异常产生的过程" class="headerlink" title="异常产生的过程"></a>异常产生的过程</h4><ul><li>如果在方法体中抛出了异常，而我们在方法体中又没有处理该异常，则就会把该异常继续抛给方法的上层调用者，也就是抛给方法的上层调用者来处理。</li><li>如果方法的上层调用者依旧没有处理该异常，那么就会继续把该异常抛给方法的上层调用者来处理，以此类推，如果方法的上层调用者都没有处理该异常，那么最终就把该异常抛给了main方法的调用者（虚拟机），而虚拟机也不会处理该异常，那么程序就终止啦。</li></ul><h4 id="手动抛出异常（throw）"><a href="#手动抛出异常（throw）" class="headerlink" title="手动抛出异常（throw）"></a>手动抛出异常（throw）</h4><ol><li>在可能出现异常的位置，我们创建并抛出一个异常对象，该异常对象中包含了异常的详细描述信息（异常类名、异常位置和异常原因），从而实现了“正常逻辑代码”和“错误逻辑代码”相分离。</li><li>注意：throw关键字只能在方法体中使用，也就是我们只能在方法体中来手动抛出一个异常。</li></ol><h4 id="异常的分类（重点）"><a href="#异常的分类（重点）" class="headerlink" title="异常的分类（重点）"></a>异常的分类（重点）</h4><ol><li><p>异常的分类的引入？</p><ul><li><p>问题：“学生年龄越界异常类”继承于Exception类和RuntimeException类的区别?</p></li><li><p>答案：“学生年龄越界异常类”继承于Exception类，则抛出“学生年龄越界异常”就会出现<strong>编译错误。</strong></p><p> “学生年龄越界异常类”继承于RuntimeException类，则抛出 “学生年龄越界异常”就<strong>不会出现编译错误。</strong></p></li></ul></li><li><p>异常的分类的概述</p><ul><li><p><strong>运行时异常</strong></p><p>–&gt; 包含：RuntimeException类及其所有子类。</p><p>–&gt; 特点：程序编译时，不强制我们对抛出的异常进行处理（可以处理，也可以不处理）</p></li><li><p>编译时异常</p><p>–&gt;包含：Exception类及其所有子类（排除运行时异常）。</p><p>–&gt;特点：程序编译时，强制我们对抛出的异常进行处理（必须处理，否则就会编译错误）。</p></li></ul></li><li><p>异常的处理的方式</p><ul><li><p><strong>声明异常（throws）</strong></p><p>–&gt; 属于“消极”的处理方式，本质上并没有处理该异常。</p></li><li><p><strong>捕捉异常（try…catch…finally）</strong></p><p>–&gt;属于“积极”的处理方式，本质上已经解决了该异常。</p></li></ul></li><li><p>不正常情况的分类补充</p><ul><li><p><strong>可检查异常（CheckedException）</strong></p><p>–&gt;包含：编译时异常</p><p>–&gt;特点：<strong>程序在编译时期，能够检查出程序中出现的不正常情况。</strong></p></li><li><p><strong>不可检查异常（UnCheckedException）</strong></p><p>–&gt;包含：Error和运行时异常</p><p>–&gt;特点：<strong>程序在编译时期，不能够检查出程序中出现的不正常情况。</strong></p></li></ul></li></ol><h4 id="声明异常（throws）"><a href="#声明异常（throws）" class="headerlink" title="声明异常（throws）"></a>声明异常（throws）</h4><ol><li><p>声明异常的概述</p><ul><li>声明异常属于“消极”的处理方式，本质上并没有解决该异常。</li><li>程序中出现了异常，此时我们又无法处理该异常，那么就使用声明异常来处理。</li></ul></li><li><p>声明异常的使用？</p><ul><li>当方法中“可能”会出现异常，此时我们又无法处理该异常，那么就可以使用“声明异常”来处理。也就是在方法声明的末尾，使用throws关键字将方法体中可能抛出的异常声明出来，然后报告给方法的调用者，交给方法的调用者来处理。</li></ul></li><li><p>声明异常的语法</p><pre class="line-numbers language-Java"><code class="language-Java">[修饰符] 返回值类型 方法名(形参列表) throws 异常类1, 异常类2, 异常类3, ... {    // 方法体     return [返回值];}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="捕捉异常类（try…catch…finally）"><a href="#捕捉异常类（try…catch…finally）" class="headerlink" title="捕捉异常类（try…catch…finally）"></a>捕捉异常类（try…catch…finally）</h4><ol><li><p>捕捉异常的概述</p><ul><li>捕捉异常属于“积极”的处理方式，本质上就已经处理了该异常。</li><li>当程序中可能出现异常，此时我们恰好能解决该异常，则就使用捕捉异常来处理。</li></ul></li><li><p>try…catch组合</p><ul><li><p>语法</p><pre class="line-numbers language-Java"><code class="language-Java">try{    //书写可能出现异常的代码}catch(异常类 对象){    //用于处理捕获到的异常。}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>执行：如果try代码块中没有出现异常，则try代码块中的代码正常执行完毕，然后就直接执行try…catch之后的代码。 <strong>如果try代码块中出现了异常，则catch代码块就会立刻捕获到该异常，然后就执行catch代码中的代码，最后再执行try…catch之后的代码。</strong></p></li></ul></li><li><p>try…多catch组合</p><ul><li><p>语法：</p><pre class="line-numbers language-Java"><code class="language-Java">try{    //书写可能出现异常的代码}catch(异常类 对象){    //用于处理捕获到的异常}catch(异常类 对象){    //用于处理捕获到的异常}...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>作用：<strong>使用try…多catch组合，我们可以实现对try代码块中出现的异常进行“针对性”的处理。</strong></p></li><li><p>注意：</p><ol><li><p><strong>使用捕捉异常的时候，建议使用“Ctrl + Alt + T”快捷键来生成try…catch…finally代码。</strong></p><ul><li>选择中可能出现异常的代码，然后使用使用“Ctrl + Alt + T”快捷键来捕捉异常的代码。</li></ul></li><li><p>在JDK1.8之后，则我们还以可以这样来处理：</p><pre class="line-numbers language-Java"><code class="language-Java">catch (NullPointerException | ArrayIndexOutOfBoundsExceptionexception) {    ...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>以上操作不建议使用，因为使用以上操作无法实现对try代码块中出现的异常进行针对性的处理。</strong></li></ul></li><li><p>使用try…多catch组合的时候，建议把子类异常catch放在前面，把父类异常catch放在后面，否则就会编译错误。</p><ul><li><strong>捕获异常的时候，属于“从上往下”来顺序匹配，如果父类异常catch放前面，则后面的子类异常catch将永远无法执行。</strong></li></ul></li><li><p>try…多catch…finally组合</p><ul><li><p>语法：</p><pre class="line-numbers language-Java"><code class="language-Java">try{    //书写可能出现异常的代码}catch(异常类 对象){// 用于处理捕获到的异常}catch(异常类 对象){// 用于处理捕获到的异常}…finally{// 无论是否出现异常，则都会执行finally中代码}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol></li></ul></li></ol><h4 id="方法重写之异常（掌握）"><a href="#方法重写之异常（掌握）" class="headerlink" title="方法重写之异常（掌握）"></a>方法重写之异常（掌握）</h4><ol><li><p>原则：子类重写方法声明的异常类型必须小于等于父类被重写方法声明的异常类型【辈分】。</p><p>–&gt;此处说的异常，指的是编译时异常，而运行时异常不用管！</p></li><li><p>要求：a)如果父类被重写方法没有声明异常，则子类重写方法也不能声明异常。</p><p>b)如果父类被重写方法声明了异常，则子类重写方法声明的异常类型必须小于等于父类被重写方法声明的异常类型（辈分）。</p></li></ol><h4 id="异常链（了解）"><a href="#异常链（了解）" class="headerlink" title="异常链（了解）"></a>异常链（了解）</h4><ol><li><p>解释：在catch代码块中，我们抛出一个描述更加详细的异常，这就是异常链。</p><pre class="line-numbers language-Java"><code class="language-Java">// 分母为零异常类class DenominatorZeroException extends Exception {    public DenominatorZeroException() { }    public DenominatorZeroException(String message) {        super(message);    }}public class Test03 {    /**     * 功能：获得两个数相除的结果     * 问题：a)除法运算，如果分母为0，则不应该返回任何结果，而此处却返回了结果为0。     *      b)除法运算，如果分母为0，则抛出算数异常，那么意味着异常描述不够清晰。     * 解决：使用“异常链”来解决。     */    public static int division(int fenZi, int fenMu) throws DenominatorZeroException {        // 1.定义一个变量，用于保存运算的结果        int result = 0;        // 2.执行除法运算，并处理了可能出现的算数异常        try {            result = fenZi / fenMu;        }        catch (ArithmeticException exception) {            // 需求：在此处，我们需要抛出一个描述更加详细的异常            throw new DenominatorZeroException("分母为零异常，fenMu：" + fenMu);        }        // 3.返回除法运算的结果        return result;    }    public static void main(String[] args) {        try {            int result = division(5, 0);            System.out.println(result);        } catch (DenominatorZeroException e) {            e.printStackTrace();        }        System.out.println("over");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><hr><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h4 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h4><ul><li><p>封装（堆功能method的封装）</p></li><li><p>典型：c语言</p></li><li><p>特点：以线性的思维来思考解决问题，强调一步一步的实现。</p><p>–&gt; 强调程序员是一个“实施者”，类似于公司中的“小职员”。</p></li><li><p><strong>优点：效率高。</strong></p></li><li><p><strong>缺点：程序的复用性、可维护性和可扩展性较低</strong>。</p></li><li><p>使用场合：适用于“小型”的程序，例如：计算器、嵌入式开发等等</p></li></ul><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><ul><li><p>封装（对数据field和功能method做的封装）、继承和多态。</p></li><li><p>典型：C++、C#、java等。</p></li><li><p>特点：以非线性的思维来思考解决问题，强调宏观上的把控。</p><p>–&gt; 强调程序员是一个“指挥官”，类似于公司中的“小老板”。</p></li><li><p><strong>优点：程序的复用性、可维护性和可扩展性较高。</strong></p></li><li><p><strong>缺点：效率低。</strong></p></li><li><p>使用场合：适用于“大型”的程序，例如：京东、淘宝、微信等等。</p></li></ul><h4 id="面向对象编程的特点"><a href="#面向对象编程的特点" class="headerlink" title="面向对象编程的特点"></a>面向对象编程的特点</h4><ul><li><strong>宏观</strong>上采用面向对象的思维来把控，<strong>微观</strong>实施上依旧采用的是面向过程，即<strong>：面向对象中包含了面向过程。</strong></li></ul><h4 id="类和对象（理解）"><a href="#类和对象（理解）" class="headerlink" title="类和对象（理解）"></a>类和对象（理解）</h4><ol><li><p>对象（instance）</p><ul><li>从编程的角度来理解：万物皆对象。</li><li>eg：教室里面的每个学生、每个凳子、每张椅子。。。</li><li><strong>每个对象都是“独一无二”的，类似于每个同学都是“独一无二”的。</strong></li></ul></li><li><p>类（class）</p><ul><li>从编程的角度来理解：类就是对一类事物的抽象，抽象就是提取这一类事物的共同属性和行为，这样就形成了类。</li><li>eg:班上的每个同学都有姓名、年龄和成绩等属性，每个同学都有吃饭、睡觉和学习等行为，则我们对班上的同学进行向上提取，那么就得到了学生类。</li></ul></li><li><p>类和对象</p><ul><li><p>从编程的角度来分析：我们以类为模板，然后实例化出对象。</p><p>–&gt; <strong>先有类，后有对象。</strong></p><p>–&gt; <strong>类是对象的模板，对象是类的实例。</strong></p><p>eg：我们以小汽车图纸（类）为模板，然后生产出一辆一辆的小汽车（对象）。</p></li></ul></li></ol><h4 id="如何定义类"><a href="#如何定义类" class="headerlink" title="如何定义类"></a>如何定义类</h4><p>语法：[修饰类] class类名{ &#x2F;&#x2F;书写的代码 }</p><p>注意：</p><ul><li>使用class关键字修饰的就是类，也就是类必须使用class来修饰。</li><li><strong>类名必须满足“标识符”的命名规则，必须满足“大驼峰”的命名规范，并且最好“见名知意”。</strong></li><li>使用“public”关键字修饰的类，则类名必须和源文件名字保持一致，否则就会出现编译错误。</li></ul><h4 id="类中的组成"><a href="#类中的组成" class="headerlink" title="类中的组成"></a>类中的组成</h4><ul><li>数据（属性），我们使用“变量”来存储类中封装的数据，类中的变量有：<ol><li>成员变量：又称之为“实例变量”或“非静态变量”，因为是从属于“对象”的。</li><li>静态变量：又称之为“类变量”，从属于“类”的。</li></ol></li><li>功能（行为），我们使用“方法”来封装类中的功能。<ol><li>成员方法，又称之为“实例方法”或“非静态方法”，从属于“对象”的。</li><li>静态方法，又称之为“类方法”，从属于“类”的。</li></ol></li></ul><h4 id="成员变量的概述"><a href="#成员变量的概述" class="headerlink" title="成员变量的概述"></a>成员变量的概述</h4><ul><li><p><strong>定义位置：在类中，代码块和方法体之外。</strong></p></li><li><p>定义语法：[修饰符] 数据类型 变量名；</p><p>–&gt;定义成员变量的时候，则不允许使用static关键字来修饰。</p></li><li><p>操作成员变量的语法：对象.成员变量名</p><p>–&gt; 通过 “对象.成员变量名” 就能找到该成员变量的存储空间，然后就能对该成员变量取值和赋值的操作。</p><p>–&gt; 在成员方法中，想要操作当前类的成员变量，则我们可以直接通过“成员变量名”来操作。</p><p>–&gt; 定义成员方法的时候，则不允许使用static关键字来修饰。</p><p><strong>调用成员方法的语法：对象.成员变量名(实参列表);</strong></p><p> –&gt; 注意：<strong>在成员方法中，想要调用当前类的成员方法，则我们可以直接通过“成员变量名(实参列表);”来实现。</strong></p></li></ul><h4 id="实例化对象的概述"><a href="#实例化对象的概述" class="headerlink" title="实例化对象的概述"></a>实例化对象的概述</h4><ul><li><p>语法</p><pre class="line-numbers language-Java"><code class="language-Java">类型 对象 = new 类名(实参列表);Student stu = new Student();Scanner input = new Scanner(System.in);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="成员变量的默认值"><a href="#成员变量的默认值" class="headerlink" title="成员变量的默认值"></a>成员变量的默认值</h4><ul><li>明确：“成员变量”和“数组元素”都有默认值，并且默认值规则一样。</li><li>整数型（byte、short、int和long）成员变量的默认值为：0；</li><li>浮点型（float和double）成员变量的默认值为：0.0;</li><li>布尔型（boolean）成员变量的默认值为：false；</li><li>字符型（char）成员变量的默认值为：’\u0000’ –&gt; 代表的是空格字符</li><li>引用数据类型（数组、字符串、类和接口等等）成员变量的默认值为：null</li></ul><h4 id="成员变量的初始化"><a href="#成员变量的初始化" class="headerlink" title="成员变量的初始化"></a>成员变量的初始化</h4><ul><li><strong>最先执行“默认初始化”，然后执行“显示初始化”，最后执行“指定初始化”。</strong></li></ul><h4 id="创建对象时的内存分析"><a href="#创建对象时的内存分析" class="headerlink" title="创建对象时的内存分析"></a>创建对象时的内存分析</h4><ul><li><strong>结论：</strong>以类为模板来创建对象，则只需要为类中的成员变量在堆内存中开辟存储空间，<strong>而成员方法是调用的时候自动在栈内存中开辟栈帧。</strong></li><li><strong>注意：</strong>每个对象都是“独一无二”的，<strong>因为每次创建对象都会在堆内存中开辟存储空间。</strong></li></ul><h4 id="成员变量和局部变量的对比"><a href="#成员变量和局部变量的对比" class="headerlink" title="成员变量和局部变量的对比"></a>成员变量和局部变量的对比</h4><ol><li>定义位置区别<ul><li>成员变量：在类中，代码块和方法体之外。</li><li>局部变量：在类中，代码块或方法体之内。</li></ul></li><li>存储位置区别<ul><li>成员变量：存储在“堆内存”中。</li><li>局部变量：存储在“栈内存”中。</li></ul></li><li>生命周期区别<ul><li>成员变量：随着对象的创建而“出生”，随着对象的销毁而“死亡”。</li><li>局部变量：定义变量的时候“出生”，所在作用域执行完毕就“死亡”。</li></ul></li><li>默认值的区别<ul><li>成员变量：成员变量有默认值，并且默认值规则和数组元素默认值规则一模一样。</li><li>局部变量：局部变量没有默认值，因为只声明未赋值的局部变量，则不能做取值操作。</li></ul></li><li>修饰符的区别<ul><li>成员变量：可以被public、protected、private、static、final等修饰符修饰。</li><li>局部变量不能被public、protected、private、static修饰，只能被final修饰。</li></ul></li></ol><h4 id="成员变量和局部变量的使用"><a href="#成员变量和局部变量的使用" class="headerlink" title="成员变量和局部变量的使用"></a>成员变量和局部变量的使用</h4><ul><li>明确：当成员变量和局部变量同名的时候，则默认采用的是“就近原则”，也就是“谁离的近，就执行谁”。</li><li>问题：当成员变量和局部变量同名的时候，我们该如何区分？</li><li>解决：局部变量采用“就近原则”来区分，成员变量使用“this”关键字来区分。</li></ul><h4 id="通过new关键字来创建对象，则创建出来的对象分为两种"><a href="#通过new关键字来创建对象，则创建出来的对象分为两种" class="headerlink" title="通过new关键字来创建对象，则创建出来的对象分为两种"></a>通过new关键字来创建对象，则创建出来的对象分为两种</h4><ol><li>匿名对象，指的就是“没有名字的对象”，例如：new Tiger();</li><li>非匿名对象，指的就是“有名字的对象”，例如：Tiger tiger &#x3D; new Tiger();</li><li>开发中，匿名对象很少使用，但是以下两种场合建议使用匿名对象来实现。<ul><li>创建出来的对象，仅仅只调用一次成员方法，则该对象就建议使用匿名对象来实现。</li></ul></li></ol><h4 id="构造方法（构造器或构造函数）"><a href="#构造方法（构造器或构造函数）" class="headerlink" title="构造方法（构造器或构造函数）"></a>构造方法（构造器或构造函数）</h4><ul><li><p>语法</p><pre class="line-numbers language-Java"><code class="language-Java">[修饰符] 类名(形参列表){    //方法体}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>注意：【构造方法的特点】</strong></p><ol><li><p>构造方法中没有“返回值类型”，因为在构造方法中不允许有“返回值”。</p><p>–&gt; 构造方法中没有“返回值”，则构造方法中只有“return;”，那么我们就省略”return;”。</p></li><li><p>构造方法的名字必须为“类名”，也就是构造方法名采用”大驼峰”来命名。</p><p>–&gt; 构造方法名采用“大驼峰”，而成员方法名和静态方法名采用“小驼峰”。</p></li><li><p>构造方法就是一个“特殊”的方法，并且构造方法应该通过new关键字来调用。</p></li><li><p><strong>构造方法专门给成员变量做初始化，也就是构造方法不为静态变量做初始化。</strong></p></li><li><p>构造方法可以没有（默认一个无参构造方法），也可以有多个构造方法，他们之间构成重载关系。</p></li><li><p>如果定义有参构造方法，则无参构造方法被自动屏蔽。</p></li><li><p>构造方法不能被继承。</p></li><li><p>构造方法不能手动调用，在创建类实例的时候自动调用构造方法。</p></li></ol></li><li><p><strong>创建对象的步骤</strong></p><p>分析“new Student();”的执行顺序，也就是分析创建对象的执行步骤：</p><ol><li>创建对象，并给成员变量开辟存储空间；</li><li>给成员变量做“默认初始化”；</li><li>给成员变量做“显式初始化”；</li><li>调用构造方法，给成员变量做“指定初始化”。</li></ol></li><li><p><strong>创建对象的时候，是谁来完成的呢？</strong></p><ul><li>new关键字负责创建对象，构造方法负责给成员变量做指定初始化操作，创建对象的时候new关键字和构造方法缺一不可。</li></ul></li><li><p><strong>构造方法的作用</strong></p><ol><li>创建对象的时候new关键字和构造方法缺一不可（了解）。</li><li><strong>通过构造方法来给成员变量做指定初始化操作，从而实现代码的复用【核心】。</strong></li></ol></li><li><p><strong>无参构造方法的概述</strong></p><ul><li>作用：用于给成员变量做初始化操作，例如在无参构造方法中给int类型数组做开辟存储空间的操作。</li><li>注意：<strong>如果某个类中没有显式地提供构造方法，则程序编译时会默认为这个类提供一个无参构造方法。</strong></li></ul></li><li><p><strong>有参构造方法的概述</strong></p><ul><li>作用：用于给成员变量做初始化操作，例如<strong>在有参构造方法中我们将形参的值赋值给成员变量来保存。</strong></li><li>注意：<ol><li>建议形参的名字和成员变量名保持一致，然后在构造方法中通过this来操作成员变量。</li><li>如果一个类显式地提供了构造方法，则程序编译时就不会为该类提供默认的无参构造方法了。</li><li>建议每个类都应该提供无参构造方法，避免在继承体系中子类找不到父类的无参构造方法。</li></ol></li></ul></li><li><p><strong>构造方法的重载</strong></p><ul><li>构造方法依旧可以实现方法的重载，<strong>调用构造方法的时候会根据实参的“个数”和“类型”来选中调用合适的构造方法。</strong></li></ul></li></ul><h4 id="this关键字（重点）"><a href="#this关键字（重点）" class="headerlink" title="this关键字（重点）"></a>this关键字（重点）</h4><ol><li><p><strong>this关键字的概述</strong></p><ul><li>创建一个对象成功之后，则<strong>虚拟机</strong>就会<strong>动态地创建一个引用</strong>，该引用<strong>指向的就是新创建出来的对象</strong>，并且该引用的名字就是this。</li></ul></li><li><p><strong>this关键字指的是什么？</strong></p><ul><li><p>在构造方法中，this指的是什么？</p><p><strong>在构造方法中，this指的是“新创建出来的对象”。</strong></p></li><li><p>在成员方法中，this指的是什么？</p><p>在成员方法中，this指的是“方法的调用者对象”。</p></li></ul></li><li><p><strong>this关键字的作用</strong></p><ol><li><p><strong>操作成员变量，语法：对象.成员变量名</strong></p><ul><li>如果成员变量和局部变量的名字相同，则我们必须通过this关键字来操作成员变量，使用就近原则来操作局部变量。</li><li>如果成员变量和局部变量的名字不同，则我们可以通过this关键字来操作成员变量，也可以忽略this关键字来操作成员变量。<ul><li>–&gt; 忽略this关键字来操作成员变量，则编译时会默认添加this关键字来操作。</li></ul></li></ul></li><li><p><strong>调用成员方法，语法：对象.成员变量名(实参列表);</strong></p><ul><li><p>调用当前类的别的成员方法时，我们可以通过this关键字来调用，也可以忽略this关键字来调用。</p><p>–&gt; 忽略this关键字来调用成员方法，则编译时会默认添加this关键字来操作。</p></li></ul></li><li><p><strong>调用构造方法，语法：this(实参列表);</strong></p><ul><li><p>作用：调用“当前类”的别的构造方法，此处仅仅调用方法并不创建对象，从而实现了代码的复用。</p></li><li><p>注意：</p><ol><li><p><strong>“this(实参列表)”只能存在于构造方法中，并且必须在构造方法有效代码的第一行。</strong></p><p>–&gt; “this(实参列表)”必须在构造方法有效代码的第一行，则意味着一个构造方法中最多只能有一个“this(实参列表)”。（0或1）</p></li><li><p><strong>构造方法切记不能“递归”调用，否则就会陷入死循环，从而造成程序编译错误！</strong></p><p>–&gt; 在构造方法中，我们不允许通过“this(实参列表)”来自己调用自己，否则就会编译错误！</p></li><li><p><strong>在一个类中，不可能所有的构造方法中都存在“this(实参列表)”,因为这样肯定会陷入死循环。</strong></p><p><strong>–&gt; 一个类中，可以定义多个构造方法，但是至少有一个构造方法中没有“this(实参列表)”。</strong></p></li></ol></li></ul></li></ol></li></ol><h4 id="静态变量（重点）"><a href="#静态变量（重点）" class="headerlink" title="静态变量（重点）"></a>静态变量（重点）</h4><ol><li><p><strong>静态变量的引入</strong></p><ul><li>需求：班上所有同学的姓名、年龄和成绩等属性，并且所有的学生都共享同一个教室和饮水机。</li><li>解决：定义一个Student类，然后在Student类中定义姓名、年龄、成绩、教室和饮水机等成员变量即可。</li></ul></li><li><p><strong>静态变量的概述</strong></p><ul><li>在类中，代码块和方法体之外，使用static关键字修饰的变量，我们就称之为“静态变量”。</li></ul></li><li><p><strong>静态变量的特点</strong></p><ol><li><p>静态变量优先于对象存在，随着类的加载就已经存在了。</p></li><li><p>一个类中，每个静态变量都只有一份，为类和对象所共享。</p></li><li><p>我们可以通过“类名”来操作静态变量，也可以通过“对象”来操作静态变量。</p><p><strong>语法1：类名.静态变量 –&gt; 建议</strong></p><p>语法2：对象.静态变量 –&gt; 不建议</p></li></ol></li><li><p><strong>类的加载过程分析</strong></p><ul><li><p>第一次使用某个类的时候，就会加载该类的信息进入方法区，如果该类中存在静态变量，则还会在方法区中为该静态变量开辟存储空间并设置默认值。</p></li><li><p><strong>问题1：什么时候执行加载类的操作呢？</strong></p><p>–&gt; 第一次使用某个类的时候，则就会执行加载类的操作。</p></li><li><p><strong>问题2：一个类会加载几次呢？</strong></p><p>–&gt; 每个类都只会加载一次，因为第一次使用某个类的时候就执行加载类的操作。</p></li><li><p><strong>问题3：什么是方法区？方法区存储的内容是什么？？</strong></p><p> <strong>–&gt; 方法区就是一块存储空间，并且方法区属于堆内存中的一部分，方法区用于存储类的信息、静态变量等等内容。</strong></p></li><li><p><strong>问题4：静态变量什么时候开辟存储空间呢？</strong></p><p>–&gt; 加载类的时候，则就会把该类中的静态变量在方法区中开辟存储空间，<strong>也就意味着静态变量优先于对象存在。</strong></p></li><li><p><strong>问题5：一个类中的静态变量，会开辟几次存储空间？</strong></p><p>–&gt; 因为类只会加载一次，<strong>因此每个类中的静态变量就只有一份，也就是每个静态变量只会开辟一次存储空间。</strong></p></li><li><p><strong>问题6：静态变量的默认值是什么？</strong></p><p>–&gt; 静态变量和成员变量都有默认值，并且他们的默认值规则一模一样。</p></li></ul></li></ol><h4 id="成员变量和静态变量的对比"><a href="#成员变量和静态变量的对比" class="headerlink" title="成员变量和静态变量的对比"></a>成员变量和静态变量的对比</h4><ol><li>存储位置区别<ul><li>成员变量：存储在堆内存中。</li><li>静态变量：存储在方法区中。</li></ul></li><li>生命周期<ul><li>成员变量：随着对象的创建而“出生”，随着对象的销毁而”死亡”。</li><li>静态变量：随着类的加载而“出生”，随着程序执行完毕而“死亡”。</li></ul></li><li>创建次数的区别：<ul><li>成员变量：对象创建多少次，则成员变量就创建多少次。</li><li>静态变量：因为类只会加载一次，因次静态变量就只会创建一次。</li></ul></li><li>调用语法区别<ul><li>成员变量：必须通过”对象”来调用。</li><li>静态变量：可以通过“类名”来调用，也可以通过“对象”来调用。</li></ul></li></ol><h4 id="成员变量和静态变量的使用"><a href="#成员变量和静态变量的使用" class="headerlink" title="成员变量和静态变量的使用"></a>成员变量和静态变量的使用</h4><ul><li>成员变量：如果存储的是“特有数据”，则就使用成员变量来存储。</li><li>静态变量：如果存储的是“共享数据”，则就是用静态变量来存储。</li></ul><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><ol><li><p><strong>代码块的分类</strong></p><ul><li>局部代码块</li><li>静态代码块</li><li>构造代码块(非静态代码块)</li></ul></li><li><p><strong>局部代码块的概述</strong></p><ul><li>定义位置：在类中，代码块或方法体的内部。</li><li>定义个数：任意多个。</li><li>执行顺序：从上往下，顺序执行。</li><li>注意事项：<ol><li>在局部代码块中定义的变量，则该变量就只能在当前作用域中使用，不能在代码块之外使用。</li></ol></li></ul></li><li><p><strong>静态代码块的概述</strong></p><ul><li><p>定义位置：在类中，代码块和方法体之外（必须使用static来修饰）。</p></li><li><p>定义个数：任意多个</p></li><li><p>执行顺序：从上往下，顺序执行</p></li><li><p>注意事项：a）加载某个类的时候，就会执行该类中的静态代码块，并且静态代码块只会执行一次。</p><p> –&gt;执行时间：加载类的时候，就会执行该类中的静态代码块。</p><p> –&gt; 执行次数：因为类只会加载一次，因此静态代码块就只会执行一次。</p><p> b）在静态代码块中，我们可以直接操作当前类的静态内容，但是不能直接操作当前类的成员内容和this。</p><p> –&gt; 原因：加载类的时候，就会执行该类中的静态代码块，则执行静态代码块的时候对象都还未创建。</p><p> c）加载类的时候，静态变量和静态代码块属于“从上往下，顺序执行”，建议把静态变量定义在静态代码块之前。</p><p> –&gt; 注意：在静态代码块中，我们“未必”能直接操作当前的静态变量。</p><p> d）在静态代码块中定义的变量，则该变量就只能在当前作用域中使用，不能再代码块之外使用。</p><p>使用场合：<strong>开发中，我们经常再静态代码块中完成对静态变量的初始化操作（常见）。</strong></p><p> –&gt;例如：创建工厂、加载数据库初始信息等等。</p></li></ul></li><li><p><strong>构造代码块的概述</strong></p><ol><li>定义位置：在类中，代码块和方法体之外（不能使用static来修饰）</li><li>定义个数：任意多个</li><li>执行顺序：从上往下，顺序执行。</li><li>注意事项：<ul><li>创建对象的时候，则就会执行该类中的构造代码块，对象创建了多少次则构造代码块就执行多少次。<ul><li>执行时间：创建对象的时候，则就会执行该类中的构造代码块。</li><li>执行次数：对象创建了多少次，则该类中的构造代码块就执行多少次。</li></ul></li><li>在构造代码块中，我们不但能直接操作当前类的静态内容，并且还能直接操作当前类的成员内容和this。<ul><li>原因：执行代码块的时候，此时对象都已经创建完毕，因此就能操作当前类的成员内容和this。</li></ul></li><li>创建对象的时候，成员变量和构造代码块属于“从上往下，顺序执行”，建议把成员变量定义在构造代码块之前。<ul><li>注意：在构造代码块中，我们“未必”能直接操作当前类的成员变量。</li></ul></li><li><strong>在构造代码块中定义的变量，则该变量就只能在当前作用域中使用，不能在代码块之外使用。</strong></li><li>使用场合：开发中，我们偶尔会在构造代码块中完成对成员变量的初始化操作。（不常见）<ul><li>可以将各个构造方法中公共的代码提取到构造代码块。</li><li>匿名内部类不能提供构造方法，此时初始化操作可以放到构造代码块中。</li></ul></li></ul></li></ol></li><li><p><strong>静态代码块、构造代码块和构造方法执行顺序？</strong></p><p>–&gt; 静态代码块 &gt; 构造代码块 &gt; 构造方法</p></li></ol><h4 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h4><ol><li><p>包的作用</p><ul><li>我们使用包来管理类，也就是类应该放在包中。</li><li><strong>包的出现，为类提供了多层的命名空间，也即是类的完整名字为”包名.类名”。</strong></li><li>注意：不同的包中，我们可以定义同名的类；同一个包中，我们不允许定义同名的类。</li></ul></li><li><p>如何定义包</p><ul><li><p>包名必须满足“标识符”的命名规则，必须满足<strong>“单词全部小写，多个单词之间以’.’链接，并且做到顶级域名倒着写”</strong>的命名规范。</p></li><li><p><strong>问题：以下两个包是否存在父子关系？【没有】</strong></p><p>–&gt; com.bjpowernode.demo com.bjpowernode.demo.test</p></li></ul></li><li><p>如何使用包</p><p>–&gt; <strong>在源文件有效代码第一行，使用package关键字来声明当前源文件中的类在那个包中。</strong></p><p>注意：通过IDEA新建的源文件，则源文件有效代码的第一行默认就有包声明；<strong>如果通过DOS命令来运行IDEA创建的源文件，则必须删除源文件中的包声明。</strong></p></li><li><p>java语言提供的包</p><ul><li><strong>java.lang 包含一些java语言的核心类，如String、Math、System等；</strong></li><li>java.awt 包含了构成抽象窗口工具集(abstract window toolkits)的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)；</li><li>java.net 包含执行与网络相关的操作的类；</li><li>java.io 包含能提供多种输入、输出功能的类；</li><li>java.util 包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。</li></ul></li><li><p><strong>类的访问方式</strong></p><ul><li><p><strong>简化访问</strong></p><ul><li><p>解释：当我们需要访问“java.lang”或“当前包”中的类时，则就可以直接使用“类名”来实现简化访问。</p></li><li><p>例如：访问“当前包”中的类</p><p>–&gt; Tiger tiger &#x3D; new Tiger(“老虎”, 18);</p></li><li><p>例如：访问“java.lang”中的类</p><p>–&gt; String str &#x3D; “hello world”;</p></li></ul></li><li><p><strong>带包名访问</strong></p><ul><li><p>解释：当我们需要访问“当前包”之外的类时（排除java.lang包中的类），则我们就必须通过“包名.类名”的方式来访问。</p></li><li><p>例如：访问”p1包”中的类</p><p>–&gt; com.bjpowernode.p1.staticblock.student stu &#x3D; new com.bjpowernode.p1.staticblock.student();</p></li><li><p>例如：访问“java.util”中的类</p><p>–&gt; java.util.Scanner input &#x3D; new java.util.Scanner(System.in);</p></li></ul></li></ul></li><li><p><strong>import关键字的概述</strong></p><ul><li><p><strong>解释：当我们需要访问“当前包”之外的类（排除java.lang包中的类），则必须通过“带包名”的方式来访问，则此访问方式太麻烦，想要实现简化访问，则就可以先通过import关键字导入需要访问的类，然后再通过“类名”来实现简化访问。</strong></p></li><li><p>例如：访问“p1包”中的类</p><p>–&gt; import com.bjpowernode.p1.staticblock.student;</p><p>–&gt; Student stu &#x3D; new Steudent();</p></li><li><p>例如：访问”java.util”中的类</p><p>–&gt; import java.util.Scanner;</p><p>–&gt; Scanner input &#x3D; new Scanner(System.in);</p></li></ul></li><li><p><strong>import关键字的注意点</strong></p><ul><li><p><strong>如果需要使用某个包中的多个类时，则我们可以通过”*”通配符来导入这个包中的所有类。</strong></p><p>–&gt; 注意：开发中，不建议使用“*”来导入某个包中的所有类，因此此方式效率非常低。</p></li><li><p><strong>如果需要使用不同包中的同名类时，则其中一个类必须通过“带包名”的方式来访问。</strong></p><p>–&gt; 原因：通过import关键字导入多个不同包的同名类，则在源文件中使用导入的类时，无法区分。</p></li><li><p><strong>在JDK1.5之后，还新增了静态导入，也就是能导入某个类中的静态属性和静态方法。</strong></p><p>–&gt; 例如：导入Math类中的静态属性</p><ol><li>第一步：import static java.lang.Math.PI;</li><li>第二步：System.out.println(PI);</li></ol><p>–&gt; 例如：导入Math类中的静态属性和静态方法</p><ol><li>第一步：import static java.lang.Math.*;</li><li>第二部：System.out.println(PI);</li></ol></li></ul></li></ol><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ol><li><p>问题：具备那三大特性的编程语言，我们才称之为面向对象语言？</p><p><strong>–&gt; 封装、继承、多态</strong></p></li><li><p><strong>封装的引入</strong></p><ul><li><p>问题1：给学生年龄赋值的时候，赋值的年龄不能为负数！</p><p>–&gt; 使用“setter和getter”方法来解决</p></li><li><p>问题2：<strong>相同的代码在不同的包中，可能会发生编译错误！</strong></p><p>–&gt; 使用“权限修饰符”来解决</p></li></ul></li><li><p><strong>编程中的封装</strong></p><ul><li><strong>核心：对于使用者而言，只需掌握其公开的访问方式，无需了解内部的具体实现细节。</strong></li></ul></li><li><p><strong>封装的层次</strong></p><ul><li>面向过程：对功能做的封装，也就是使用方法来完成的封装。</li><li><strong>面向对象：对数据和功能做的封装，也就是使用类来完成的封装。</strong></li></ul></li><li><p><strong>封装的好处</strong></p><ul><li>封装的出现，提高了代码的安全性【了解】。</li><li><strong>封装的出现，提高了代码的复用性【核心】。</strong></li></ul></li></ol><h4 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h4><ol><li><p>private，私有的，权限：只能在“<strong>当前类</strong>”中访问，因此我们称之为“类可见性”。</p></li><li><p>default，<strong>默认的，权限：</strong>只能在“<strong>当前类 + 当前包</strong>”中访问，因此我们称之为“包可见性”。</p><p>–&gt; 注意：在权限修饰符中，没有default关键字，省略权限修饰符默认就是包可见性。</p></li><li><p>protected，受保护的，权限：只能在“<strong>当前类 + 当前包 + 别的包中的子类包</strong>”中访问，因此我们称之为“子类可见性”。</p></li><li><p>public，公开的，权限：只能在“<strong>当前类 + 当前包 + 加别的包</strong>”中访问，因此我们称之为“项目可见性”。</p></li></ol><ul><li><strong>权限大小【由低到高】：private &lt;&lt; default &lt;&lt; protected &lt;&lt; public</strong></li></ul><h4 id="权限修饰符的使用"><a href="#权限修饰符的使用" class="headerlink" title="权限修饰符的使用"></a>权限修饰符的使用</h4><ul><li><p><strong>明确：实际开发中，“默认的”和“受保护的”很少使用，但是“私有的”和“公开的”却很常用。</strong></p></li><li><p><strong>private：default、protected和public都能修饰”成员变量”和“静态变量”。</strong></p><p>–&gt; 成员变量：因为存储都是“特殊数据”，因此使用private修饰。</p><p>–&gt; 静态变量：因为存储是“共享数据”，因此使用public来修饰。</p></li><li><p><strong>private：default、protected和public都能修饰”成员方法”和“静态方法”。</strong></p><p>–&gt; 如果该方法需要外界访问，则就把该方法使用public来修饰。</p><p>–&gt; 如果该方法无需外界访问，也就是只为当前类服务，那么久把该方法使用private来修饰。</p></li><li><p><strong>private：default、protected和public都能修饰“构造方法”。</strong></p><p>–&gt; 如果该类需要被外界实例化，则该类的构造方法就采用public来修饰;</p><p>–&gt; 如果该类无需被外界实例化，则该类的构造方法就采用private来修饰。</p><p><strong>注意：工具类中只有静态内容，因此工具类就无需被实例化，那么工具类的构造方法都采用了private修饰，eg：Arrays和Math等等。</strong></p></li><li><p><strong>定义类的时候，类只允许使用public和default，不允许使用private和protected来修饰。</strong></p><p>–&gt;使用public修饰的类（公开权限），则该类就能在整个项目中使用。</p><p>–&gt; 使用default修饰的类（默认权限），则该类就只能在当前包中使用。</p></li><li><p><strong>使用权限修饰符，则不允许修饰局部变量、局部代码块、静态代码块和构造代码块。</strong></p></li></ul><h4 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h4><ol><li>setter和getter方法的概述<ul><li>成员变量一律私有化（private），避免外界直接去访问成员变量，然后提供公开的setter和getter方法来操作私有的成员变量。</li></ul></li><li><strong>setter方法的概述</strong><ul><li>作用：用于给私有的成员变量做<strong>赋值操作</strong>，<strong>并且还能对赋值的数据做检查和处理。</strong></li></ul></li><li><strong>getter方法的概述</strong><ul><li>作用：<strong>用于获取私有成员变量的值（取值操作），并且还能对获得的数据做统一的处理。</strong></li></ul></li><li><strong>setter和getter的注意点</strong><ul><li>通过构造方法给成员变量赋值，如果赋值的数据需要做检查和处理，则在构造方法中就必须调用setter方法来实现赋值操作。</li><li><strong>给boolean类型成员变量提供getter方法的时候，此时getter方法的名字前缀必须是“is”开头，而不是能以“get”来开头。</strong></li><li><strong>给类提供“构造方法”和“setter和getter方法”的时候，则建议使用“alt + insert”快捷键来实现，而不建议手动写代码来实现。</strong></li></ul></li></ol><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ol><li><p><strong>继承的引入</strong></p><ul><li>问题：讲师类和学生类中都有相同的name和age两个成员变量，都有相同的eat()和sleep()两个成员方法，因此需要实现代码的复用。</li><li>解决：使用“继承”来实现。</li></ul></li><li><p><strong>继承的本质</strong></p><ul><li>就是提取一系列类中相同的成员变量和成员方法，这样就得到了一个父类，从而形成了继承关系。</li><li>即：<strong>向上提取。</strong></li></ul></li><li><p><strong>继承语法</strong></p><pre class="line-numbers language-Java"><code class="language-Java">[修饰符] class 父类{}[修饰符] class 子类 extends 父类{}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>继承的特点</strong></p><ul><li>子类不但能继承父类的成员变量和成员方法，并且子类还可以有自己特有的成员变量和成员方法。</li><li>即：<strong>子类对父类做的扩展。</strong></li></ul></li><li><p><strong>继承的好处</strong></p><ul><li>继承的出现，提高了代码的复用性，从而提高了开发的效率。</li><li>继承的出现，让类与类之间产生了联系，为后面学习“多态”打下了技术铺垫。</li><li><strong>强调：继承是一把“双刃剑”，父类代码一旦发生了变化，则就会影响所有的子类，使用继承的时候慎重。【高耦合】</strong></li></ul></li><li><p><strong>哪些内容子类不能继承</strong></p><ul><li>父类私有的内容，子类不能继承。</li><li>父类的构造方法，子类不能继承。</li><li><strong>父类静态的内容，虽然子类能够使用，但父类静态内容“不参与”继承。</strong></li><li><strong>强调：继承强调的是“对象”之间的关系，因此成员内容能参与继承，但是静态内容不参与继承。</strong></li></ul></li><li><p><strong>继承的注意点</strong></p><ul><li><p><strong>java语言采用的是“单继承”，C++语言采用的是“多继承”。</strong></p><ul><li><strong>单继承：</strong>一个子类只能有一个直接父类。</li><li><strong>多继承：</strong>一个子类可以有多个直接父类。</li></ul></li><li><p>AA类继承于BB类，BB类继承于CC类，CC类继承于DD类，。。。，从而就形成了“继承链”。</p><p>–&gt; 此处BB类，CC类和DD类都是AA类的“父类”，<strong>只有BB类属于AA类的“直接父类”。</strong></p></li><li><p><strong>java语言中，一个子类只能有一个直接父类，但是一个父类可以有多个直接子类。</strong></p></li><li><p><strong>如果一个类没有显式地使用extends关键字，则该类就默认继承于”java.lang.Object”类。</strong></p><p>–&gt; <strong>所有的java类都可以使用object类提供的方法。【最终继承的都是object类】</strong></p></li></ul></li></ol><h4 id="方法重写（方法复写，override）"><a href="#方法重写（方法复写，override）" class="headerlink" title="方法重写（方法复写，override）"></a>方法重写（方法复写，override）</h4><ol><li><p><strong>方法重写的引入</strong></p><ul><li>eg：智能机是对功能机做的扩展，也就是应该让“智能机类”继承于“功能机类”，也就意味着“父类”和“子类”中都有show()方法，从而就形成了“方法重写”。</li></ul></li><li><p><strong>什么是方法重写呢？</strong></p><ul><li>在子类中，我们定义一个和父类“几乎”一模一样的方法，这就形成了“方法重写”。</li></ul></li><li><p><strong>什么时候使用方法重写？</strong></p><ul><li>当父类提供的方法无法满足子类的需求，则在子类中就可以重写父类提供的方法，从而满足开发的需求。</li></ul></li><li><p><strong>父类的哪些方法子类不能重写？</strong></p><ul><li>父类的构造方法，子类不能重写。</li><li>父类的静态方法，子类不能重写。</li><li>父类私有的成员方法，子类不能重写。</li></ul></li><li><p><strong>方法重写的注意点</strong></p><ul><li><p>通过子类对象来调用重写方法，则默认调用的是子类重写的方法，而不是调用父类被重写的方法。</p></li><li><p>保证子类的某个方法肯定是重写方法，则可以在该方法声明之前添加“@Override”注解，从而保证该方法肯定是重写方法。</p><p>–&gt; 如果某个方法声明之前添加了“@Override”注解，则该方法就必须是重写方法，否则就会编译错误。</p></li><li><p><strong>在子类重写方法中，如果想要调用父类被重写的方法，则必须通过super关键字来调用（this和super使用类似）</strong></p></li></ul></li><li><p><strong>方法重写的具体要求</strong></p><ul><li><p><strong>&#x3D;&#x3D;，子类重写方法的“方法名”和“形参列表”必须和父类被重写方法的“方法名”和“形参列表”相同。</strong></p><p>–&gt; 此处“形参列表”必须相同，指的是“形参个数”和“形参类型”必须相同，<strong>形参名字不同不影响。</strong></p></li><li><p><strong>“&gt;&#x3D;”，子类重写方法的修饰符权限必须大于等于父类被重写方法的修饰符权限【权限】。</strong></p><p>–&gt; 修饰符权限：public &gt; protected &gt; default &gt; private</p><p><strong>–&gt; 注意：子类就不能重写父类采用了static或private来修饰的方法。</strong></p></li><li><p><strong>“&lt;&#x3D;”，子类重写方法的“返回值类型”必须小于等于父类被重写方法的“返回值类型”【辈分】。</strong></p><p>–&gt; 如果父类被重写方法的返回值类型为void、基本数据类型和String类型，则子类重写方法的返回值类型必须和父类被重写方法的返回值类型保持一致（&#x3D;&#x3D;）。</p><p>–&gt; 如果父类被重写方法的返回值类型为引用数据类型（排除String类型），则子类重写方法的返回值必须小于等于被重写方法的返回值类型。（&lt;&#x3D;，辈分）。</p></li></ul></li></ol><h4 id="方法重载和方法重写的区别"><a href="#方法重载和方法重写的区别" class="headerlink" title="方法重载和方法重写的区别"></a>方法重载和方法重写的区别</h4><ol><li><p><strong>整体区别</strong></p><ul><li><p>英文名字区别</p><p>方法重载：overload</p><p>方法重写：override</p></li><li><p>使用位置区别</p><p>方法重载：同一个类中使用。</p><p>方法重写：<strong>必须在继承体系中使用。</strong></p></li><li><p>具体作用区别</p><p>方法重载：允许在同一类中定义多个同名的方法，从而避免了方法名被污染。</p><p>方法重写：父类提供的方法如果无法满足子类需求，则子类就可以重写父类提供的方法。</p></li><li><p>修饰符的区别</p><p>方法重载：修饰符不同，不构成方法重载。</p><p>方法重写：<strong>子类重写方法的“修饰符权限”必须大于等于父类被重写方法的“修饰符权限”【权限】。</strong></p></li><li><p>返回值类型的区别</p><p>方法重载：返回值类型不同。不构成方法重载。</p><p>方法重写：<strong>子类重写方法的“返回值类型”必须小于等于父类被重写方法的“返回值类型”【辈分】。</strong></p></li><li><p>方法名的区别</p><p>方法重载：方法名必须相同。</p><p>方法重写：方法名必须相同。</p></li><li><p><strong>形参列表的区别</strong></p><p>方法重载：<strong>形参个数不同 或 形参类型不同，形参名字不同不影响。</strong></p><p>方法重写：<strong>形参个数 和 形参类型必须相同。</strong></p></li></ul></li></ol><h4 id="重写toString-方法（理解）"><a href="#重写toString-方法（理解）" class="headerlink" title="重写toString()方法（理解）"></a>重写toString()方法（理解）</h4><ol><li><strong>请问print()和println()方法的作用</strong><ul><li><strong>通过输出语句，都能把输出的内容转化为字符串类型，然后把转化为字符串类型的结果输出到控制台。</strong></li></ul></li></ol><h4 id="super关键字-重点"><a href="#super关键字-重点" class="headerlink" title="super关键字(重点)"></a>super关键字(重点)</h4><ol><li><p><strong>super关键字的概述</strong></p><ul><li>创建一个对象成功之后，则虚拟机就会动态地创建一个引用，该引用指向的就是“新创建出来的对象”，并且该引用的名字就是this。</li><li>创建一个子类对象成功之后，则虚拟机还会动态创建一个引用，该引用指向的就是“当前对象的直接父类对象”，并且该引用的名字就是super。</li><li>总结：this指的就是“当前对象”，super指的就是“当前对象的直接父类对象”。并且this可以单独使用，但是super不能单独使用。</li></ul></li><li><p><strong>super关键字的作用</strong></p><ul><li><strong>强调：this和super指的都是“对象”，并且this和super使用场合是相同的（构造方法、成员方法和构造代码块）。</strong></li><li>操作父类的成员变量，语法： super.父类成员变量名</li><li>调用父类的成员方法，语法：super.父类成员方法(实参列表);</li><li>调用父类的构造方法，语法：super(实参列表);</li></ul></li><li><p><strong>this和super的区别</strong></p><ul><li>this的特点：先在当前类找，找不到再去父类找。</li><li>super的特点：直接去父类找，而不会在当前类找。</li></ul></li><li><p><strong>super关键字的注意点</strong></p><ul><li><p>在子类重写方法中，如果想要调用父类被重写的方法，则必须通过super关键字来实现。</p></li><li><p>当局部变量，子类的成员变量和父类的成员变量同名的时候，则该如何去区分呢？</p><p><strong>局部变量采用“就近原则”，子类成员变量通过“this”来操作，父类成员变量通过“super”来操作。</strong></p></li><li><p><strong>父类私有的成员变量，在子类中即使使用super关键字也无法操作，只能通过setter和getter方法来操作父类私有成员变量。</strong></p></li></ul></li></ol><h4 id="super-实参列表-的概述"><a href="#super-实参列表-的概述" class="headerlink" title="super(实参列表)的概述"></a>super(实参列表)的概述</h4><ul><li><strong>在子类构造方法中，如果想要显式地调用父类的某个构造方法，则必须通过“super(实参列表)”来实现，从而实现了代码的复用。</strong></li><li><strong>在子类构造方法中，如果没有显式地调用别的构造方法，则默认就会调用父类的无参构造方法，也就是编译时会默认添加“super();”语句。</strong></li></ul><h4 id="super-实参列表-的注意点"><a href="#super-实参列表-的注意点" class="headerlink" title="super(实参列表)的注意点"></a>super(实参列表)的注意点</h4><ul><li><strong>“super(实参列表)”只能存在于构造方法中，并且必须在构造方法有效代码的第一行。</strong></li><li><strong>建议每个类都应该有自己的无参构造方法，避免在继承体系中子类找不到父类的无参构造方法。</strong></li></ul><h4 id="this-实参列表-和super-实参列表-的区别"><a href="#this-实参列表-和super-实参列表-的区别" class="headerlink" title="this(实参列表)和super(实参列表)的区别"></a>this(实参列表)和super(实参列表)的区别</h4><ul><li>this(实参列表)的特点：<strong>调用“当前类”的别的构造方法，并且必须在构造方法有效代码的第一行。</strong></li><li>super(实参列表)的特点：<strong>调用“父类”中的某个构造方法，并且必须在构造方法有效代码的第一行。</strong></li><li>结论：<strong>因为“this(实参列表)”和“super(实参列表)”都必须在构造方法有效代码的第一行，因此构造方法中不允许同时存在“this(实参列表)”和“super(实参列表)”。</strong></li></ul><h4 id="继承体系下，创建子类对象的步骤分析"><a href="#继承体系下，创建子类对象的步骤分析" class="headerlink" title="继承体系下，创建子类对象的步骤分析"></a>继承体系下，创建子类对象的步骤分析</h4><ol><li>第一步：加载类（先加载父类，后加载子类）<ul><li>先执行父类的静态代码块，然后执行子类的静态代码块。</li></ul></li><li>第二步：创建对象（先创建父类对象，后创建子类对象）<ul><li>首先，执行父类的构造代码块，接着执行父类的构造方法。</li><li>然后，执行子类的构造代码块，接着执行子类的构造方法。</li></ul></li></ol><h4 id="继承体系下，创建子类对象的内存分析"><a href="#继承体系下，创建子类对象的内存分析" class="headerlink" title="继承体系下，创建子类对象的内存分析"></a>继承体系下，创建子类对象的内存分析</h4><ul><li><strong>创建一个子类对象，则默认还会创建他的父类对象，并且创建的这些对象之间属于“包含”关系。</strong></li><li><strong>也就是说，子类对象中包含了父类对象，那么子类对象和父类对象的“首地址”肯定是相同的。</strong></li></ul><h4 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h4><ol><li>组合的引入<ul><li>需求：有一台电脑，电脑中包含鼠标、键盘和CPU等。</li><li>实现：定义电脑类（Computer），然后再定义鼠标类（Mouse）、键盘类（KeyBoard）和CPU类（CPU），然后把鼠标、键盘和CPU作为电脑类的“成员变量”即可，这就形成了“组合”关系。</li></ul></li><li>继承和组合<ul><li>相同点<ul><li><strong>都能让类与类之间产生联系，都能实现代码的复用。</strong></li></ul></li><li>不同点<ul><li><strong>继承描述的是“is a”的关系</strong>，例如：Tiger is Animal, Student is a Person等等。</li><li><strong>组合描述的是“has a”的关系</strong>，例如：Computer has a Mouse,Computer has a keyBoard等等。</li></ul></li></ul></li></ol><h4 id="final关键字的概述"><a href="#final关键字的概述" class="headerlink" title="final关键字的概述"></a>final关键字的概述</h4><ol><li>final关键字的含义<ul><li>最终的、不可变的</li></ul></li><li>final关键字能修饰的内容？<ul><li>final关键字能修饰类、变量（局部变量、成员变量和静态变量）和方法（成员方法和静态方法），但是不能修饰构造方法和代码块。</li></ul></li></ol><h4 id="final关键字的特点"><a href="#final关键字的特点" class="headerlink" title="final关键字的特点"></a>final关键字的特点</h4><ol><li><p>使用final关键字修饰的类，</p><p>则该类就不能被继承。</p><ul><li>使用final修饰的类，则改类肯定是一个子类，例如String、Math和System都采用了final修饰。</li></ul></li><li><p>使用final关键字修饰的方法（成员方法和静态方法），则该方法就不能被重写。</p><ul><li>如果某个成员方法不想被子类重写，则该方法就采用final来修饰即可，例如Object类中的很多方法都采用了final修饰。</li></ul></li><li><p>使用final关键字修饰的变量（局部变量、成员变量和静态变量），则该变量就变为常量了。</p><ul><li>常量名必须符合“标识符”的命名规则，必须符合“字母全部大写，多个单词之间以下划线连接”的命名规范。</li><li>使用final修饰的静态变量，要么做显式初始化，要么在静态代码块中初始化，否则就会编译错误。</li><li>使用final修饰的成员变量，要么做显式初始化，要么在构造代码块中初始化，要么在构造方法中初始化，否则就会编译错误。</li></ul></li><li><p><strong>使用final关键字，我们不能修饰构造方法、局部代码块、构造代码块和静态代码块。</strong></p></li></ol><h4 id="final修饰引用数据类型变量的特点"><a href="#final修饰引用数据类型变量的特点" class="headerlink" title="final修饰引用数据类型变量的特点"></a>final修饰引用数据类型变量的特点</h4><ul><li><strong>引用数据类型的变量采用final修饰后，则该变量就变为常量了，因此常量保持的地址值不能更改，但是该常量指向堆内存中的成员变量值可以更改。</strong></li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li><p><strong>使用多态的前提？</strong></p><ul><li><p><strong>前提1：继承是实现多态的前提。</strong></p><p>–&gt; 让所有的动物类都继承于Animal类，也就是Animal类是所有动物类的父类！</p></li><li><p><strong>前提2：子类必须重写父类方法。</strong></p><p>–&gt; 所有的动物类都重写了Animal类的eat()方法，毕竟每个动物吃的东西都不同。</p></li><li><p><strong>前提3：父类引用指向子类对象。</strong></p><p>–&gt; Admin类中的feedAnimal()方法的形参为“Animal”类型，调用该方法时的实参为“Animal类的子类对象”，此处就用到了“父类引用指向子类对象”。</p><p>–&gt; 调用feedAnimal()方法的代码为“admin.feedAnimal(new Dog());”，则实现赋值给形参的操作就等效于：Animal animal &#x3D; new Dog();</p></li></ul></li><li><p><strong>使用多态的场合</strong></p><ul><li><p><strong>场合一：方法的形参为父类类型，则实参就可以是该父类的任意子类对象。</strong></p><p>–&gt; 例如：管理员给动物们喂食的案例</p></li><li><p><strong>场合二：返回值类型为父类类型，则返回值就可以是该父类的任意子类对象。</strong></p><p>–&gt; 例如：简单工厂模式的案例</p></li></ul></li></ul><h4 id="多态情况下，操作成员变量的特点"><a href="#多态情况下，操作成员变量的特点" class="headerlink" title="多态情况下，操作成员变量的特点"></a>多态情况下，操作成员变量的特点</h4><ol><li>编译时：检查“编译时类型”，也就是检查编译时类型中是否有该成员变量。</li><li>运行时：检查“编译时类型”，也就是操作了编译时类型中的成员变量。</li><li><strong>总结：多态情况下操作成员变量，则编译和运行都检查“编译时类型”。</strong></li></ol><h4 id="abstract的引入"><a href="#abstract的引入" class="headerlink" title="abstract的引入"></a>abstract的引入</h4><ol><li>需求：在动力节点中，有讲师和助教两个工种，他们都具备工作的能力。</li><li>实现：定义讲师类（Teacher）和助教类（Assistant），然后分别提供work()的方法。</li><li>问题：讲师类和助教类都有work()方法，也就是讲师类和助教类都有相同的代码，因此我们需要实现代码的复用。</li><li>解决：使用“继承”来实现。定义一个员工类（Employee），并且给员工类提供work()方法，然后让讲师类和助教类继承于员工类，并重写员工类中的work()方法。</li><li>问题1：世界上没有任何一个工种就叫做员工，因此员工类不应该被实例化！<ul><li>–&gt; 使用“抽象类”来解决，也就是把员工类设置为抽象类即可。</li></ul></li><li>问题2：为了避免讲师和助教偷懒，因为要求讲师类和助教类必须重写员工类的work()方法！<ul><li>–&gt; 使用“抽象方法”来解决，也就是把员工类的work()方法设置为抽象方法。</li></ul></li></ol><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ol><li><p>什么是抽象类</p><ul><li><strong>使用abstract关键字修饰的类，则我们就称之为“抽象类”。</strong></li></ul></li><li><p><strong>抽象类的组成</strong></p><ul><li>a)在抽象类中，依旧可以拥有成员变量和静态变量。</li><li>b)在抽象类中，依旧可以拥有成员方法和静态方法，<strong>并且还可以有任意多个抽象方法。</strong></li><li>c)在抽象类中，依旧可以拥有构造方法，该构造方法用于给抽象类中的成员变量做指定初始化操作。</li><li>d)在抽象类中，依旧可以拥有构造代码块和静态代码块。</li><li><strong>总结：抽象类就是一个特殊的类，抽象类对比普通类新增了任意多个抽象方法。</strong></li></ul></li><li><p><strong>抽象类的特点</strong></p><ul><li><p><strong>a)抽象类不能被实例化，因为抽象类中包含了抽象方法。</strong></p></li><li><p>b)抽象类肯定是一个父类，<strong>只有实现类“实现”了抽象类中的所有抽象方法，则该实现类才能被实例化，否则该实现类就是一个抽象类。</strong></p><p><strong>实现：子类重写父类的抽象方法，我们就称之为“实现”。</strong></p><p>重写：子类重写父类的普通方法，我们就称之为“重写”。</p></li><li><p><strong>c)抽象类可以作为方法的“形参类别”和“返回值类型”，也就是抽象类也可以实现多态。</strong></p></li><li><p><strong>d)实现类与抽象类之间属于“extends”的关系，并且属于“单继承”。</strong></p></li></ul></li></ol><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><ol><li>什么是抽象方法？<ul><li><strong>使用abstract关键字修饰的方法，我们就称之为“抽象方法”。</strong></li></ul></li><li>抽象方法的特点<ul><li>a)抽象方法<strong>只有方法声明</strong>，没有方法内部的具体实现，也就是<strong>没有方法体。</strong></li><li><strong>b)抽象方法只能存在于“抽象类”和“接口”中，不能存在于“普通类”中。</strong></li></ul></li><li>关于abstract关键字的补充？<ul><li>a)<strong>请问abstract关键字和哪一个关键字是反义词？</strong>？？final</li><li>b)<strong>请问abstract关键字不能和哪些关键字共存呢？</strong>？？final、private、static</li></ul></li></ol><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h4 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h4><ol><li>接口的引入<ul><li>需求：让飞机、炮弹、小鸟和超人进行飞行表演！</li><li>实现：定义飞机类（Plane）、炮弹类（Peng）、小鸟类（Bird）和超人类（SuperMan），然后为每个类提供showFly()的方法。</li><li>问题：飞机类、炮弹类、小鸟类和超人类都有showFly()方法，也就是这些类中有相同的代码，那么我们就需要实现代码的复用，如何实现？</li><li>解决：使用“继承”来解决。定义一个Flyable类，然后给Flyable类提供showFly()的方法，接着让飞机类、炮弹类、小鸟类和超人类“继承”于Flyable类，并重写Flyable类中的showFly()方法。</li><li>问题：继承描述的是“is a”的关系，也就是描述“相同体系”的基本行为，此处飞机、炮弹、小鸟和超人属于不同体系，因此使用继承不合适</li><li>解决：使用“接口”来解决。定义一个Flyable接口，然后给Flyable接口提供showFly()方法，接着让飞机类、炮弹类、小鸟类和超人类“实现”于Flyable接口，并实现Flyable接口中的showFly()方法。</li><li><strong>总结：接口描述的是“is like a”的关系，也就是描述“不同体系”的相同行为，此处飞机、炮弹、小鸟和超人属于不同体系，因此使用接口很合适。</strong></li></ul></li></ol><h4 id="接口的概述"><a href="#接口的概述" class="headerlink" title="接口的概述"></a>接口的概述</h4><ol><li><p>接口的定义</p><ul><li><strong>明确：接口使用interface关键字来修饰，并且interface和class属于平级的，因此interface和class不能共存！</strong></li></ul></li><li><p>接口的组成</p><ul><li><p>a)接口中的<strong>属性</strong>，<strong>默认全部是“全局静态常量”，也就是默认使用了“public static final”来修饰。</strong></p></li><li><p>b)接口中的<strong>方法，默认全部是“全局抽象方法”，也就是默认使用了“public abstract”来修饰。</strong></p><p><strong>在JDK1.8之后，接口中还新增了“全局静态方法”和“default修饰的全局默认方法”。</strong></p></li><li><p>c)<strong>在接口中，不允许存在构造方法，因为接口中都没有成员变量，因此就无需存在构造方法。</strong></p></li><li><p><strong>d)在接口中，不允许存在静态代码块和构造代码块。</strong></p></li></ul></li><li><p>接口的特点</p><ul><li>a)<strong>接口不能被实例化，因为接口中存在抽象方法，并且接口中没有构造方法。</strong></li><li>b)<strong>接口可以作为方法的“形参类型”和“返回值类型”</strong>，也就是<strong>接口能够实现多态。</strong></li><li>c)接口与接口之间属于“extends”的关系，并且<strong>接口还属于“多继承”。</strong></li><li>d)<strong>抽象方法只能存在于“抽象类”和“接口”中，不能存在于“普通类”中。</strong></li></ul></li></ol><h4 id="实现类的概述"><a href="#实现类的概述" class="headerlink" title="实现类的概述"></a>实现类的概述</h4><ol><li><p>实现类的定义</p><ul><li>明确：<strong>实现类和接口之间属于“implements”的关系，而不是属于“extends”的关系。</strong></li></ul></li><li><p>实现类的特点</p><ul><li>a)<strong>实现类只有“实现”了接口中的所有抽象方法，则该实现类才能被实例化，否则该实现类就是一个抽象类。</strong></li><li>b)<strong>实现类可以先继承一个父类，然后再去实现多个接口，实现多个接口的操作我们就称之为“接口的多实现”。</strong></li></ul></li><li><p>抽象类和接口的总结</p><ol><li><p>普通类、抽象类和接口的特点</p><ul><li><strong>接口的抽象程度最高，抽象类的抽象程度次之，普通类的抽象程度最低。</strong></li></ul></li><li><p>抽象类和接口的对比</p><ul><li><p>相同点</p><ol><li>都是向上提取的结果，因此都不能被实例化。</li><li>都是向上提取的结果，因此都包含了抽象方法。</li></ol></li><li><p>不同点</p><ol><li><p>接口与接口之间属于“extends”的关系，并且属于“多继承”。</p><p>抽象类与抽象类之间属于“extends”的关系，并且属于“单继承”。</p></li><li><p>实现类与接口之间属于“implements”的关系，并且属于“多实现”。</p><p>实现类与抽象类之间属于“extends”的关系，并且属于“单继承”。</p></li><li><p>接口描述的是“is like a”的关系，也就是描述“不同体系”的相同行为。</p><p>抽象类描述的是“is a”的关系，也就是描述“相同体系”的基本行为。</p></li><li><p>接口中只有“全局静态常量”和“全局抽象方法”，JDK1.8之后新增了“全局静态方法”和“default修饰的全局默认方法”。</p><p>抽象类就是一个特殊类，抽象类对比普通类新增了任意多个抽象方法。</p></li></ol></li></ul></li></ol></li></ol><h4 id="单继承和多继承的概述？"><a href="#单继承和多继承的概述？" class="headerlink" title="单继承和多继承的概述？"></a>单继承和多继承的概述？</h4><ol><li>单继承：java、C#等等<ul><li>解释：一个子类只能有一个直接父类，类似于一个儿子只有一个亲爹。</li><li>优势：简单、安全。</li><li>劣势：只能继承一个父类的内容，则子类功能不够强大。</li></ul></li><li>多继承：C++<ul><li>解释：一个子类可以有多个直接父类，类似于一个儿子可以有多个亲爹。</li><li>优势：可以继承多个父类的内容，则子类功能非常强大。</li><li>劣势：复杂、不安全。</li></ul></li></ol><h4 id="接口的多实现的概述"><a href="#接口的多实现的概述" class="headerlink" title="接口的多实现的概述"></a>接口的多实现的概述</h4><ol><li>需求：要求子类不但简单又安全，同时还要求子类功能非常强大，如何实现？<ul><li>不但要集合单继承和多继承的优势，并且还要摒弃单继承和多继承的劣势。</li><li><strong>实现：先让子类继承于某个父类，然后再让该子类实现多个接口，实现多个接口的操作就称之为“接口的多实现”。</strong></li><li>通过以上的实现方式，我们就模拟了C++的多继承操作，并且还摒弃了C++多继承的劣势。</li></ul></li></ol><h4 id="内部类的概述"><a href="#内部类的概述" class="headerlink" title="内部类的概述"></a>内部类的概述</h4><ol><li><p>什么是内部类</p><ul><li><strong>在OutClass类的内部，我们再定义InnerClass类就是内部类。</strong></li></ul></li><li><p>内部类的定义位置？</p><ul><li>位置一：在类中，代码块或方法体的内部。</li><li>位置二：在类中，代码块和方法体的外部。</li></ul></li><li><p>什么时候使用内部类？</p><ul><li>描述一个事物的时候，我们发现该事物内部还有别的事物，此时就可以使用内部类来实现。</li><li>例如：描述小汽车的时候，我们发现小汽车内部还有发动机，此时的发动机就是一个内部类。</li></ul></li><li><p>内部类的分类？</p><ul><li><strong>成员内部类（掌握）</strong>、<strong>静态内部类（掌握）</strong>、局部内部类（了解）和<strong>匿名内部类（重点）</strong>。</li></ul></li><li><p>内部类编译的特点？</p><ul><li><p>在OuterClass类的内部，我们再定义InnerClass类，此时我们对程序进行编译，<strong>则就会获得两个字节码文件</strong></p><p>–&gt; <strong>OuterClass.class</strong> 外部类的字节码文件，也就是OuterClass类的字节码文件</p><p>–&gt; <strong>OuterClass$InnerClass.class</strong> 内部类的字节码文件，也就是InnerClass类的字节码文件</p></li></ul></li><li><p>操作内部类的特点？</p><ul><li>想要操作内部类，则必须通过外部类来实现，也就是内部类是依附于外部类的。</li></ul></li></ol><h4 id="成员内部类（掌握）"><a href="#成员内部类（掌握）" class="headerlink" title="成员内部类（掌握）"></a>成员内部类（掌握）</h4><p>明确：学习成员内部类的时候，我们建议<strong>把“成员内部类”当成“成员变量”来理解。</strong></p><ol><li><p>定义位置</p><ul><li>在类中，代码块和方法体之外。</li></ul></li><li><p>定义语法</p><ul><li><pre class="line-numbers language-Java"><code class="language-Java">[修饰符] class 外部类{    //成员内部类    [修饰符] class 内部类{    //内部类中的代码    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>成员内部类的实例化方式？</p><ul><li>情况一：<strong>在外部类的内部，我们实例化成员内部类对象（掌握）</strong></li><li>情况二：<strong>在外部类的外部，我们实例化成员内部类对象。（了解）</strong></li></ul></li></ol><h4 id="静态内部类-掌握"><a href="#静态内部类-掌握" class="headerlink" title="静态内部类(掌握)"></a>静态内部类(掌握)</h4><p>明确：学习静态内部类的时候，我们把“静态内部类”当成“静态变量”来理解。</p><ol><li><p>定义位置</p><ul><li>在类中，代码块和方法之外。</li></ul></li><li><p>语法</p><pre class="line-numbers language-Java"><code class="language-Java">[修饰符] class 外部类{    //静态内部类    [修饰符] static class 内部类{        //书写静态内部类的代码    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注意事项</p><ul><li><p>a)定义静态内部类的时候，我们可以使用private、protected、public、final和abstract来修饰，并且还<strong>必须使用static来修饰</strong></p></li><li><p>b)在静态内部类中，我们不但能定义成员变量、成员方法、构造方法和构造代码块，并且还<strong>能定义静态变量、静态方法和静态代码块。</strong></p></li><li><p>c)<strong>想要操作静态内部类，则直接通过外部类名来操作即可</strong>，因为静态内部类是依附于外部类的，此处联想“静态变量”来理解即可。</p><p><strong>在外部类的成员位置，我们可以直接操作当前类中的静态内部类；在外部类的静态位置，我们可以直接操作当前类中的静态内部类。</strong></p></li><li><p>d)<strong>在静态内部类中，我们可以直接操作外部类的静态变量和静态方法，但是不能直接操作外部类的成员变量和成员方法。</strong></p><p>静态内部类是依附于外部类的，也就是<strong>只要外部类加载完毕，则就能操作当前类中静态内部类。</strong></p></li><li><p>e)想要操作静态内部类中的静态变量和静态方法，则我们还可以通过以下方式来直接操作：</p><ol><li><strong>操作静态变量</strong>：外部类.静态内部类.静态变量名；</li><li><strong>操作静态方法</strong>：外部类.静态内部类.静态方法名(实参列表);</li></ol></li></ul></li><li><p><strong>静态内部类的实例化方式？</strong></p><ul><li><strong>情况一：在外部类的内部，我们实例化静态内部类对象（掌握）</strong></li><li>情况二：在外部类的外部，我们实例化静态内部类对象（了解）</li></ul></li><li><p><strong>成员内部类和静态内部类的总结</strong></p><ul><li><strong>成员内部类：如果内部类需要依附于外部类对象，则该内部类就必须为成员内部类。</strong></li><li><strong>静态内部类：如果内部类只需依附于外部类即可，并且需要在该内部类中定义静态内容，则该内部类就必须定义为静态内部类。</strong></li></ul></li></ol><h4 id="局部内部类（了解）"><a href="#局部内部类（了解）" class="headerlink" title="局部内部类（了解）"></a>局部内部类（了解）</h4><p>明确：学习局部内部类，则我们把“局部内部类”当成“局部变量”来理解。</p><ol><li><p>定义位置</p><ul><li>在类中，代码块或方法体的内部。</li></ul></li><li><p>注意事项</p><ul><li><p>a)定义局部内部类的时候，我们不能使用private、protected、public和static修饰，但是<strong>可以使用final和abstract来修饰。</strong></p></li><li><p>b)在局部内部类中，我们<strong>只能定义成员变量、成员方法、构造方法和构造代码块</strong>，但是<strong>不能定义静态变量、静态方法和静态代码块。</strong></p></li><li><p>c)局部内部类只能在“当前作用域”中使用，不能在代码块或方法体之外使用，此处我们可以联想局部变量的“生命周期”来理解。</p></li><li><p>d)<strong>在局部内部类中，我们“肯定”能操作外部类的静态变量和静态方法，但是“未必”能操作外部类的成员变量和成员方法。</strong></p><p>在局部内部类中，是否能操作外部类的成员变量和成员方法，<strong>关键是看该局部内部类在哪个位置中定义的。</strong></p></li><li><p>e)<strong>在局部内部类中，想要操作外部的局部变量，则该局部变量必须采用final来修饰，从而保证数据的安全性。</strong></p><p><strong>在局部内部类中，如果操作了外部的局部变量，则该局部变量的生命周期就延长了，也就是该局部变量的生命周期和局部内部类对象的生命周期保持一致了。</strong></p></li><li><p><strong>补充：在JDK1.8之后，如果在局部内部类中使用了外部的局部变量，则该局部变量默认就会采用final来修饰，从而保证数据的安全性。</strong></p></li></ul></li></ol><h4 id="匿名内部类（重点）"><a href="#匿名内部类（重点）" class="headerlink" title="匿名内部类（重点）"></a>匿名内部类（重点）</h4><ol><li><p>匿名内部类的概述</p><ul><li><strong>匿名内部类本质就是一个“局部内部类”，也就是一个“没有名字”的局部内部类，也就是一个特殊的局部内部类。</strong></li></ul></li><li><p>匿名内部类的语法</p><pre class="line-numbers language-Java"><code class="language-Java">[修饰符] class 外部类 {       {            // 位置一：创建一个继承于某个父类的局部内部类对象，该局部内部类没有名字。            // 第一步：定义了一个继承于某个父类的局部内部类，并且该局部内部类没有名字。            // 第二步：创建该局部内部类对象，也就是常见了一个没有名字的局部内部类对象。            new 父类名() {               // 书写匿名内部类中的代码            };       }        [修饰符] 返回值类型 方法名(形参列表) {            // 位置二：创建一个实现于某个接口的局部内部类对象，该局部内部类没有名字。           // 第一步：定义一个实现于某个接口的局部内部类，并且该局部内部类没有名字           // 第二步：创建该局部内部类对象，也就是常见了一个没有名字的局部内部类对象            new 接口名() {                // 书写匿名内部类中的代码            };        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>匿名内部类的注意点</p><ul><li>a)匿名内部类就是一个特殊的局部内部类，因此局部内部类的要求对于匿名内部类依旧生效。</li><li>b)<strong>在匿名内部类中，我们不能定义构造方法，因为匿名内部类都没有类名，而构造方法名必须为类名。</strong></li><li>c)<strong>在匿名内部类中，我们不建议定义自己“特有”的成员变量和成员方法，因为这样不方便我们去操作。</strong></li><li><strong>注意：在匿名内部类中，我们一般用于重写父类或接口中的抽象方法。</strong></li></ul></li></ol><hr><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ol><li><p>包装类的引入</p><ul><li><strong>世界上没有任何一门语言是完全面向对象的，因为面向对象语言中都包含了“基本数据类型”，为了方便“基本数据类型”和“引用数据类型”之间的转换，因此就诞生了“包装类”。</strong></li></ul></li><li><p>包装类的概述？</p><ul><li><p>明确：每一种基本数据类型都对应一个包装类，因此Java语言中提供的包装类至少有8种。</p><pre class="line-numbers language-Java"><code class="language-Java">byte        Byteshort        Shortint          Integerlong        Longfloat        Floatdouble        Doublechar        Characterboolean    Boolean//注意：除了int类型和char类型之外，其余基本数据类型对应的包装类名都是“首字母大写”即可。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Number类的概述</p><ul><li><p>java.lang.Number属于一个抽象类，所有的“数值型包装类”都属于Number的实现类，也就意味着所有的数值型包装类都能使用Number抽象类所提供的方法，并且Number抽象类常见的方法如下：</p><pre class="line-numbers language-Java"><code class="language-Java">public byte byteValue() { ... }       --> 把数值型包装类对象转化为byte类型public short shortValue() { ... }     --> 把数值型包装类对象转化为short类型public abstract int intValue();       --> 把数值型包装类对象转化为int类型public abstract long longValue();     --> 把数值型包装类对象转化为long类型public abstract float floatValue();   --> 把数值型包装类对象转化为float类型public abstract double doubleValue(); --> 把数值型包装类对象转化为double类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul></li><li><p>包装类的作用</p><ul><li><p>作为和基本数据类型对应的类型存在，方便涉及到对象的操作，如Object[]、集合等的操作。</p></li><li><p>包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法(这些操作方法的作用是在基本数据类型、包装类对象、字符串之间提供相互之间的转化)。</p><pre class="line-numbers language-Java"><code class="language-Java">public class Test01 {    public static void main(String[] args) {        System.out.println("int类型表示的最大值：" + Integer.MAX_VALUE);        System.out.println("int类型表示的最小值：" + Integer.MIN_VALUE);        System.out.println("byte类型表示的最大值：" + Byte.MAX_VALUE);        System.out.println("byte类型表示的最小值：" + Byte.MIN_VALUE);        /*// 问题：数组的定义？？？数组就是一个存储“相同数据类型”的“有序”集合（容器）。        // 涉及到的技术：向上转型+自动装箱        Object[] arr = {123, 3.14, true, 'a', "abc", new Test01()};        System.out.println(Arrays.toString(arr));*/    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h4 id="基本数据类型和包装类之间的转换"><a href="#基本数据类型和包装类之间的转换" class="headerlink" title="基本数据类型和包装类之间的转换"></a>基本数据类型和包装类之间的转换</h4><ol><li><p><strong>包装类的底层</strong></p><ul><li><strong>所谓的包装类，则底层中定义了一个对应基本数据类型的“私有常量”来保存数据，包装类其实就是对基本数据类型的数据执行封装的操作。</strong></li><li>例如：在Integer包装类中，其底层定义了一个int类型的“私有常量”来保存数据，也就是Integer包装类就是对int类型数据执行的封装操作。</li></ul></li><li><p><strong>基本数据类型转化为包装类</strong></p><ul><li><p>方式一：通过构造方法来实现</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Integer</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作用：把基本数据类型转化为包装类对象。</span><span class="token keyword">public</span> <span class="token function">Integer</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token keyword">throws</span> NumberFormatException <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//作用：把字符串的内容转化为包装类对象。</span>          <span class="token comment" spellcheck="true">//注意：当字符串存储的内容和对应的基本数据类型的数据格式不匹配的时候，则就会抛出“数值格式化异常”</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>方式二：通过valueOf()静态方法来实现</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//作用：把基本数据类型转化为包装类对象。</span>       <span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token keyword">throws</span> NumberFormatException <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//作用：把字符串的内容转化为包装类对象。</span>          <span class="token comment" spellcheck="true">//注意：当字符串存储的内容和对应的基本数据类型的数据格式不匹配的时候，则就会抛出“数值格式化异常”。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>注意事项</strong></p><ol><li><p><strong>针对Character类型，字符串不能转化为Character类型的包装类对象，因为Character类没有提供字符串参数的构造方法和字符串参数的valueOf()方法。</strong></p></li><li><p>针对Boolean类型，只有字符串为“true”（不区分大小写）的时候，转化为包装对象的值才为true，否则一律都为false。</p></li><li><p><strong>数值型的包装类中（不包含Character和Boolean），形参字符串的内容为必须为数值型，否则抛出NumberFormatException异常。</strong></p></li></ol></li></ul></li><li><p><strong>包装类转化为基本数据类型？</strong></p><ul><li><p><strong>情况一：数值型包装类</strong></p><p>–&gt; 数值型包装类都是Number抽象类的实现类，因此数值型包装类使用Number抽象类提供的方法，我们就可以实现把“数值型包装类对象”转化为“数值型”。</p></li><li><p><strong>情况二：非数值型包装类</strong></p><p>–&gt; 针对Character类型，我们可以使用Character类中提供的charValue()方法，从而将“Character对象”转化为对应的“char类型”。</p><p>–&gt; 针对Boolean类型，我们可以使用Boolean类中提供的booleanValue()方法，从而将“Boolean对象”转化为对应的“boolean类型”。</p></li></ul></li></ol><h4 id="自动装箱和自动拆箱（超级重点）"><a href="#自动装箱和自动拆箱（超级重点）" class="headerlink" title="自动装箱和自动拆箱（超级重点）"></a>自动装箱和自动拆箱（超级重点）</h4><ol><li><p><strong>自动装箱和自动拆箱的概述</strong></p><ul><li>在JDK1.5之前，想要实现“基本数据类型”和“包装类”之间的转换，则必须通过调用包装类的方法来手动完成，此操作比较麻烦。</li><li>在JDK1.5之后，想要实现“基本数据类型”和“包装类”之间的转换，则我们可以通过自动装箱和自动拆箱来完成，此操作非常简单。</li></ul></li><li><p><strong>自动装箱机制的概述？</strong></p><ul><li>解释：当基本数据类型处于需要对象的环境中，则就会触发自动装箱机制，也就是自动会把基本数据类型转化为对应的包装类对象。</li><li>底层：当触发自动装箱机制的时候，则默认就会调用包装类的valueOf(xxx x)静态方法，从而将基本数据类型转化为包装类对象。</li></ul></li><li><p><strong>自动拆箱机制的概述？</strong></p><ul><li>解释：当包装类对象处于需要基本数据类型的环境中，则就会触发自动拆箱机制，也就是自动会把包装类对象转化为对应的基本数据类型。</li><li>底层：当触发自动拆箱机制的时候，则默认就会调用包装类的xxxValue()成员方法，从而将包装类对象转化为对应的基本数据类型。</li><li>例如：int num &#x3D; new Integer(123); –底层–&gt; int num &#x3D; new Integer(123).intValue();</li></ul></li><li><p><strong>自动装箱的缓存问题？</strong></p><ul><li>解释：当“整数型”的数据取值范围在[-128, 127]之间的时候，如果触发了自动装箱机制，则就会从“缓存池”中取出一个包装类对象并返回，也就是不会创建新的包装类对象并返回。</li><li>当“整数型”的数据取值范围在[-128, 127]之外的时候，如果触发了自动装箱机制，则就会直接创建一个新的包装类对象并返回，也就是不会从缓存池中取出包装类对象来返回。</li></ul></li><li><p><strong>自动拆箱的空指针问题？</strong></p><ul><li><p>解释：<strong>当触发自动拆箱机制的时候，则默认就会调用包装类的xxxValue()成员方法，如果该包装对象为null，那么触发自动拆箱机制就会抛出空指针异常。</strong></p><p>–&gt; <strong>例如：Integer integer &#x3D; null; int num &#x3D; integer; &#x2F;&#x2F; 等效于： int num &#x3D; integer.intValue();</strong></p></li></ul></li></ol><h4 id="基本数据类型和字符串之间的转换"><a href="#基本数据类型和字符串之间的转换" class="headerlink" title="基本数据类型和字符串之间的转换"></a>基本数据类型和字符串之间的转换</h4><ol><li><p><strong>字符串转化为基本数据类型（重要）</strong></p><ul><li><p>明确：<strong>使用包装类提供的parseXxx(String str)的静态方法来实现。</strong></p><pre class="line-numbers language-java"><code class="language-java">Byte    <span class="token keyword">static</span> <span class="token keyword">byte</span> <span class="token function">parseByte</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//将字符串参数解析为带符号的十进制byte 。</span>Short    <span class="token keyword">static</span> <span class="token keyword">short</span> <span class="token function">parseShort</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//将字符串参数解析为带符号的十进制short 。</span>Integer<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">//将字符串参数解析为带符号的十进制int。</span>Long    <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">parseLong</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">//将字符串参数解析为带符号的十进制long。</span>Float    <span class="token keyword">static</span> <span class="token keyword">float</span> <span class="token function">parseFloat</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//返回一个新 float值，该值被初始化为用指定字符串表示的值。</span>Double    <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">parseDouble</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//返回一个新 double值，该值被初始化为用指定字符串表示的值。</span> Boolean<span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">parseBoolean</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//将字符串参数解析为boolean值。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注意事项：</p><ul><li>1.<strong>不能把字符串转化为char类型，因为Character包装类中没有提供parseChar(String value)方法。</strong></li><li>2.针对Boolean类型，只有字符串为“true”的时候（不区分大小写），转化为基本类型的值才为true，否则都为false。</li><li>3.<strong>整数型包装类，字符串中的内容必须是十进制整数；浮点型包装类中，字符串中的内容必须为十进制整数或浮点数，否则抛出NumberFormatException异常。</strong></li></ul></li></ul></li><li><p>基本数据类型转化为字符串（了解）</p><ul><li><p>明确：<strong>把基本数据类型转换为字符串，我们可以使用“+”连接符来实现，也可以使用包装类提供的方法来实现。</strong></p><pre class="line-numbers language-java"><code class="language-java">所有包装类String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                返回对象的字符串表示形式。Byte    <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">byte</span> b<span class="token punctuation">)</span>    把<span class="token keyword">byte</span>类型转化为字符串返回。Short    <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">short</span> s<span class="token punctuation">)</span>    把<span class="token keyword">short</span>类型转化为字符串返回。Integer<span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>    把<span class="token keyword">int</span>类型转化为字符串返回。Long    <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">long</span> i<span class="token punctuation">)</span>    把<span class="token keyword">long</span>类型转化为字符串返回。Float    <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">float</span> f<span class="token punctuation">)</span>    把<span class="token keyword">float</span>类型转化为字符串返回。Double    <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">)</span>把<span class="token keyword">double</span>类型转化为字符串返回。Boolean<span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> b<span class="token punctuation">)</span>把<span class="token keyword">boolean</span>类型转化为字符串返回。Character<span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span>    把<span class="token keyword">char</span>类型转化为字符串返回。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h2 id="String类讲解"><a href="#String类讲解" class="headerlink" title="String类讲解"></a>String类讲解</h2><h4 id="字符串常量池的概述"><a href="#字符串常量池的概述" class="headerlink" title="字符串常量池的概述"></a>字符串常量池的概述</h4><ul><li><strong>加载类的时候</strong>，如果该类中有双引号创建的字符串，则就<strong>把该字符串在常量池中开辟存储空间并存储，并且常量池中存储的字符串都是唯一的。</strong></li><li><strong>执行程序的时候</strong>，如果遇到了双引号创建的字符串，则<strong>直接去常量池中取出该字符串并使用即可，也就是不会再次去创建一个新的字符串。</strong></li></ul><h4 id="String类的概述"><a href="#String类的概述" class="headerlink" title="String类的概述"></a>String类的概述</h4><ul><li>在字符串中，存储的是任意多个字符，这些字符以char类型的数组来存储的。<strong>在String类中，char类型的数组默认采用了final来修饰</strong>，也就意味着<strong>char类型的数组不能扩容</strong>，也就是<strong>字符串中存储的字符内容不可改变，因此我们称String为“不可变的Unicode编码序列”，简称“不可变字符串”。</strong>并且，<strong>String类还采用了final修饰，则意味着String类不能被继承。</strong></li></ul><h4 id="String类的部分常用方法"><a href="#String类的部分常用方法" class="headerlink" title="String类的部分常用方法"></a>String类的部分常用方法</h4><ul><li><p>length()方法</p><pre class="line-numbers language-Java"><code class="language-Java"> public int length() { ... }//作用：获得字符串的长度，也就是获得底层char类型数组的空间长度。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>charAt()方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">char</span> <span class="token function">charAt</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作用：根据索引获得字符串中的字符。</span><span class="token comment" spellcheck="true">//注意：index取值范围在[0, 字符串长度-1]之间，超出范围则就会抛出StringIndexOutOfBoundsException异常</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>indexOf()方法</p><ul><li>明确：“从前往后”查找某个“字符”或“子串”在“主串”中的索引位置，如果查找的“字符”或“字串”不存在，则返回-1</li></ul><pre class="line-numbers language-Java"><code class="language-Java">int indexOf(int ch)                //返回指定字符第一次出现在字符串内的索引。int indexOf(int ch, int fromIndex)    //返回指定字符第一次出现在字符串内的索引，以指定的索引开始搜索。int indexOf(String str)            //返回指定子字符串第一次出现在字符串内的索引。int indexOf(String str, int fromIndex)//返回指定子串的第一次出现在字符串中的索引，从指定的索引开始搜索。//注意：此处indexOf()方法的底层使用“字符串匹配算法”来实现，常见的字符串匹配算法有：BF算法和KMP算法。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>lastIndexOf()方法</p><ul><li>明确：“从后往前”查找某个“字符”或“子串”在“主串”中的索引位置，如果查找的“字符”或“字串”不存在，则返回-1</li></ul><pre class="line-numbers language-Java"><code class="language-Java">int lastIndexOf(int ch)                //返回指定字符最后一次出现在字符串内的索引。int lastIndexOf(int ch, int fromIndex)    //返回指定字符最后一次出现在字符串内的索引，以指定的索引开始搜索。int lastIndexOf(String str)            //返回指定子字符串最后一次出现在字符串内的索引。int lastIndexOf(String str, int fromIndex)//返回指定子串的最后一次出现在字符串中的索引，从指定的索引开始搜索。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>startsWith()方法</p><pre class="line-numbers language-Java"><code class="language-Java">public boolean startsWith(String prefix) { ... }// 作用：判断某个字符串是否以prefix开头。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>endsWith()方法</p><pre class="line-numbers language-Java"><code class="language-Java">public boolean endsWith(String suffix) { ... }//作用：判断某个字符串是否以suffix结尾<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>contains()方法</p><pre class="line-numbers language-Java"><code class="language-Java">public boolean contains(CharSequence s) { ... }//作用：判断字符串中是否包含某个子串（开头、中间和结尾）//注意：此处CharSequence是一个接口，该接口的实现类有String、StringBuffer和StringBuilder<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>字符串大小写转换</p><ul><li>明确：字符串大小写转换，针对“英文字母”有效，针对“中文汉字”无效。</li></ul><pre class="line-numbers language-Java"><code class="language-Java">String toUpperCase()//返回一个新的字符串，该字符串中所有英文字符转换为大写字母。String toLowerCase()//返回一个新的字符串，该字符串中所有英文字符转换为小写字母。//注意：执行注册或登录操作的时候，就需要使用字符型大小写转换来校对验证码。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>忽略字符串前后空格</p><pre class="line-numbers language-Java"><code class="language-Java">public String trim()  //忽略字符串前后端的空格，中间的空格不用忽略<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>字符串的截取操作</p><pre class="line-numbers language-Java"><code class="language-Java">String substring(int beginIndex)            //从beginIndex开始截取字符串，到字符串末尾结束。// 注意：此处beginIndex的取值范围在[0, 字符串长度-1]之间。    String substring(int beginIndex, int endIndex)//从beginIndex开始截取字符串，到字符索引endIndex-1结束。    //注意：beginIndex的取值范围在[0, 字符串长度-1]之间，endIndex的取值范围在[0, 字符串长度]之间，并且endIndex必须大于beginIndex<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>字符串的替换操作</p><pre class="line-numbers language-Java"><code class="language-Java">// 通过用newChar字符替换字符串中出现的所有oldChar字符，并返回替换后的新字符串。String replace(char oldChar, char newChar)    //将与字面目标序列匹配的字符串的每个子字符串替换为指定的字面替换序列。String replace(CharSequence target, CharSequence replacement)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>字符串拼接的操作</p><ul><li>明确：我们可以使用“+”连接符来实现字符串的评价操作，也可以使用String类提供的“String concat(String str)”方法来实现。</li></ul><pre class="line-numbers language-Java"><code class="language-Java">public class Test02 {    public static void main(String[] args) {        // 需求：完成字符串的拼接操作        String str1 = "hello" + "world";        System.out.println(str1); // 输出：helloworld        String str2 = "hello".concat("world");        System.out.println(str2); // 输出：helloworld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>isEmpty方法</p><pre class="line-numbers language-Java"><code class="language-Java">//作用：判断字符串是否为空，也就是判断底层的char类型数组空间长度是否为0 public boolean isEmpty() { ... }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>equals方法</p><pre class="line-numbers language-Java"><code class="language-Java">boolean equals(Object anObject)    //判断字符串内容是否相同，区分字母大小写。boolean equalsIgnoreCase(String str)//判断字符串内容是否相同，忽略字母大小写。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>valueOf方法</p><pre class="line-numbers language-Java"><code class="language-Java">String类提供了valueOf(xxx x)    //这个静态方法，该方法用于将其他的数据类型转化为字符串。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="StringBuffer类的概述"><a href="#StringBuffer类的概述" class="headerlink" title="StringBuffer类的概述"></a>StringBuffer类的概述</h4><ul><li>StringBuffer类继承于AbstractStringBuilder抽象类，StringBuffer类底层维护者一个char类型的数组，并且该char类型的数组没有使用final修饰，也就意味着该char类型的数组可以自动扩容，也就是该char类型数组存储的元素可以改变，因此我们就称StringBuffer类为“可变的Unicode编码序列”，简称“可变字符串”。并且，StringBuffer类采用了final修饰，也就意味着StringBuffer不能被继承。</li></ul><h4 id="String类和StringBuffer类特点"><a href="#String类和StringBuffer类特点" class="headerlink" title="String类和StringBuffer类特点"></a>String类和StringBuffer类特点</h4><ol><li><p>相同点：</p><ul><li>a)底层都维护者一个char类型的数组，也就是存储的都是字符，因此都属于“字符串”。</li><li>b)这个两个类都采用了final修饰，也就意味着String和StringBuffer都不能被继承。</li></ul></li><li><p>不同点：</p><ul><li><p>String类底层的char类型数组使用了final修饰，因此String类存储的字符内容不可改变，我们就称之为“不可变字符串”。</p><p>–&gt; 通过String类提供的方法来操作字符串中的内容时，都不是直接基于char类型数组做的操作，那么都会返回一个新的字符串。</p></li><li><p>StringBuffer类底层的char类型数组没有使用final修饰，因此StringBuffer类存储的字符内容可以改变，我们就称之为“可变字符串”。</p><p>–&gt; 通过StringBuffer类提供方法来操作字符串中的内容，都是直接基于char类型数组做的操作，因此就可以无需返回新的字符串。</p></li></ul></li></ol><h4 id="StringBuffer类的构造方法"><a href="#StringBuffer类的构造方法" class="headerlink" title="StringBuffer类的构造方法"></a>StringBuffer类的构造方法</h4><pre class="line-numbers language-Java"><code class="language-Java">StringBuffer()                //构造一个没有字符的字符串缓冲区，初始容量为16个字符（有用）。StringBuffer(CharSequence seq)//构造一个包含与指定的相同字符的字符串缓冲区CharSequence 。StringBuffer(int capacity)    //构造一个没有字符的字符串缓冲区和指定的初始容量。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="StringBuffer类的方法"><a href="#StringBuffer类的方法" class="headerlink" title="StringBuffer类的方法"></a>StringBuffer类的方法</h4><ul><li><p>明确：如果StringBuffer类提供方法的返回值类型为StringBuffer或AbstractStringBuilder，则该返回值就是“当前方法的调用者对象”。</p><ol><li><p>添加方法</p><pre class="line-numbers language-Java"><code class="language-Java">//作用：在可变字符串末尾添加内容。public AbstractStringBuilder append(Type type) { ... }// 作用：在可变字符串索引为offset位置插入字符串内容。 public AbstractStringBuilder insert(int offset, Type type) { ... }  //注意：此处offset的取值范围在[0, 可变字符串长度]之间，超出范围则就会抛出“字符串索引越界异常”。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>替换的方法</p><pre class="line-numbers language-Java"><code class="language-Java">//作用：把可变字符串索引为index的字符替换为ch即可。 public synchronized void setCharAt(int index, char ch) { ... } //  注意：此处index的取值范围在[0, 可变字符串长度 - 1]之间，超出范围则就会抛出“字符串索引越界异常”。 //作用：把可变字符串索引为[start, end)之间的元素替换为str即可。 public synchronized StringBuffer replace(int start, int end, String str) { ... } //注意：此处start的取值范围[0, 可变字符串长度 - 1]之间，end的取值范围在[0, 可变字符串长度]之间，并且end必须大于start。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除的方法</p><pre class="line-numbers language-Java"><code class="language-Java">//作用：删除可变字符串中索引为index的字符。public synchronized StringBuffer deleteCharAt(int index) { ... }// 注意：此处index的取值范围在[0, 可变字符串长度 - 1]之间，超出范围则就会抛出“字符串索引越界异常”。//作用：删除索引为[start, end)范围之间的元素。 public synchronized StringBuffer delete(int start, int end) {  ... } //注意：此处start的取值范围[0, 可变字符串长度 - 1]之间，end的取值范围在[0, 可变字符串长度]之间，并且end必须大于start。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>查找的方法</p><pre class="line-numbers language-Java"><code class="language-Java">charAt(int index)                    //返回 char在指定索引在这个序列值。indexOf(String str)                //返回指定子字符串第一次出现的字符串内的索引。indexOf(String str, int fromIndex)    //返回指定子串的第一次出现的字符串中的索引，从指定的索引开始。lastIndexOf(String str)            //返回指定子字符串最右边出现的字符串内的索引。lastIndexOf(String str, int fromIndex)//返回指定子字符串最后一次出现的字符串中的索引，从指定的索引开始。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>反转的方法</p><pre class="line-numbers language-Java"><code class="language-Java">public synchronized StringBuffer reverse() 把可变字符串中的内容进行反转操作<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>操作字符串长度的方法</p><pre class="line-numbers language-Java"><code class="language-Java">// 作用：获得可变字符串的长度 public synchronized int length() { ... }// 作用：修改可变字符串的长度。public synchronized void setLength(int newLength) { ... }//注意：如果“设置的长度”大于“可变字符串的长度”，则默认做“扩容操作”。//如果“设置的长度”小于“可变字符串的长度”，则默认做“剪切操作”。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>字符串截取的方法</p><pre class="line-numbers language-Java"><code class="language-Java">substring(int start)        //返回一个新的 String ，其中包含此字符序列中当前包含的字符的子序列。substring(int start, int end)//返回一个新的 String ，其中包含此序列中当前包含的字符的子序列。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>转化为String类的方法</p><pre class="line-numbers language-Java"><code class="language-Java">// 作用：把StringBuffer对象转化为String类型。public synchronized String toString() { ... }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol></li></ul><h4 id="StringBuilder类的概述"><a href="#StringBuilder类的概述" class="headerlink" title="StringBuilder类的概述"></a>StringBuilder类的概述</h4><ul><li>StringBuilder类继承于AbstractStringBuilder抽象类，StringBuilder类底层维护者一个char类型的数组，并且该char类型的数组没有使用final修饰，也就意味着该char类型的数组可以自动扩容，也就是StringBuilder类存储的字符内容可以改变，因此我们就称呼StringBuilder类为“可变的Unicode编码序列”，简称“可变字符串”。并且，StringBuilder类采用final修饰，也就意味着StringBuilder不能被继承。</li></ul><h4 id="StringBuffer类和StringBuilder类的特点"><a href="#StringBuffer类和StringBuilder类的特点" class="headerlink" title="StringBuffer类和StringBuilder类的特点"></a>StringBuffer类和StringBuilder类的特点</h4><ol><li>相同点<ul><li>a)底层都包含char类型的数组，并且该char类型的数组都没使用final修饰，因此都称之为“可变字符串”。</li><li>b)这两个类都采用了final关键字来修饰，也就意味着StringBuffer类和StringBuilder类都不能被继承。</li><li>c)都继承于AbstractStringBuilder抽象类，并且这两个类拥有的方法都相同，因此使用方法属于类似的。</li></ul></li><li>不同点<ul><li>StringBuffer：线程安全的，会做线程同步检查，因此效率较低（不常用）。</li><li>StringBuilder：线程不安全的，不会做线程同步检查，因此效率较高（常用）。</li></ul></li></ol><h4 id="使用“-”连接符完成字符串拼接操作的底层分析（重点）"><a href="#使用“-”连接符完成字符串拼接操作的底层分析（重点）" class="headerlink" title="使用“+”连接符完成字符串拼接操作的底层分析（重点）"></a>使用“+”连接符完成字符串拼接操作的底层分析（重点）</h4><ol><li>情况一：两个字符串都是常量时，使用“+”来完成拼接操作<ul><li>底层：因为常量保存的内容不可改变，也就是编译时期就能确定常量的值，因此为了提高字符串的拼接效率，所以就在编译时期就完成了拼接操作。</li></ul></li><li>情况二：其中一个为字符串变量时，使用“+”来完成拼接操作<ul><li>底层：因为编译时期无法确定变量的值，因此其中一个为字符串变量的拼接操作，那么肯定不是在编译时期完成，而是在运行时期来完成的，并且实现步骤如下。</li></ul></li></ol><h4 id="三种字符串的拼接效率（重点）"><a href="#三种字符串的拼接效率（重点）" class="headerlink" title="三种字符串的拼接效率（重点）"></a>三种字符串的拼接效率（重点）</h4><ol><li><p>System.currentTimeMillis()方法的概述？</p><ul><li>作用：获得“当前时间”距离1970年1月1日凌晨的毫秒数。</li><li>–&gt; 公式：1秒 &#x3D; 1000毫秒</li><li>使用：计算完成某个功能所需要的耗时，则就可以使用该方法来实现。</li><li>–&gt; 耗时：结束时间 - 开始时间</li></ul></li><li><p>三种字符串的拼接效率？</p><ul><li><p><strong>StringBuilder的拼接效率最高，StringBuffer的拼接效率次之，String的拼接效率最低。</strong></p></li><li><p>注意：<strong>如果需要大量执行字符串的拼接操作，则建议使用StringBuilder类来完成拼接操作。</strong></p></li></ul></li></ol><h4 id="链式调用语法（了解）"><a href="#链式调用语法（了解）" class="headerlink" title="链式调用语法（了解）"></a>链式调用语法（了解）</h4><p>理解：每个成员方法体中都返回this，也就是每个成员方法体中都返回该方法的调用者对象。</p><ol><li>问题：在目前已经学习的类中，哪些类支持链式调用语法呢？？？<ul><li>答案：StringBuilder和StringBuffer</li></ul></li></ol><hr><h2 id="日期时间类"><a href="#日期时间类" class="headerlink" title="日期时间类"></a>日期时间类</h2><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><ul><li><p>java.util.Date() 我们称为时间类，程序中我们通过new对象保存时间（单位为毫秒）</p><ul><li><p>Date()类的构造方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>…<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>作用：获得保存“当前时间”的Date对象。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Date</span><span class="token punctuation">(</span><span class="token keyword">long</span> date<span class="token punctuation">)</span> <span class="token punctuation">{</span>…<span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>作用：获得保存“指定时间”的Date 对象（表示的就是“指定时间”距离1970年1月1日凌晨的毫秒数）</li></ul></li></ul></li><li><p>Date()类的成员方法：</p><ul><li>Long getTime();返回当前时间距离1970年1月1日凌晨的毫秒数。（获得时间）</li><li>void setTime(long time);使用给指定的毫秒时间值设置现有的Date对象。（修改时间）</li></ul></li><li><p>SimpleDateFormat 类的引入</p><ul><li>Java.text.SimpleDateFormat类属于DateFormat抽象类的实现类，开发中用来实现“Date对象”保存时间和“字符串”保存时间之间的相互转换。</li></ul></li><li><p>测试代码</p></li></ul><pre class="line-numbers language-Java"><code class="language-Java">public class Test01 {    public static void main(String[] args) throws IOException {        //获取当前时间        Date date = new Date();        System.out.println(date);        SimpleDateFormat sf = new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒");        System.out.println(sf.format(date));        //将date对象保存的时间转换为calendar对象保存的时间        Calendar calendar = Calendar.getInstance();        calendar.setTime(date);        System.out.println(calendar);        //将calendar对象保存的时间转换为date对象保存的时间        Date date1 = calendar.getTime();        String s = sf.format(date1);        System.out.println(s);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="时间日期转换格式"><a href="#时间日期转换格式" class="headerlink" title="时间日期转换格式"></a>时间日期转换格式</h4><ul><li><p>当出现y时，会将y替换成年。</p></li><li><p>当出现M时，会将M替换成月。</p></li><li><p>当出现d 时，会将d替换成日。</p></li><li><p>当出现h时，会将h替换成时(12小时制)。</p></li><li><p>当出现H时，会将H替换成时(24小时制)。</p></li><li><p>当出现m时，会将m替换成分。</p></li><li><p>当出现s 时，会将s替换成秒。</p></li><li><p>当出现s 时，会将s替换成毫秒。</p></li><li><p>当出现D时，获得当前时间是今年的第几天。</p></li><li><p>当出现w时，获得当前时间是今年的第几周。</p></li><li><p>当出现w时，获得当前时间是本月的第几周。</p></li></ul><h4 id="时间类的构造方法"><a href="#时间类的构造方法" class="headerlink" title="时间类的构造方法"></a>时间类的构造方法</h4><ul><li><p>SimpleDateFormat类的构造方法：</p><pre class="line-numbers language-Java"><code class="language-Java">public SimpleDateFormat（String pattern）{…}<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>作用：实例化SimpleDateFormat对象，并且还能设置指定的格式规则</li></ul></li><li><p>Public SimpleDateFormat类的成员方法：（重点方法）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">format</span><span class="token punctuation">(</span>Date date<span class="token punctuation">)</span><span class="token punctuation">{</span>…<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>作用：把Date对象保存的时间转换为字符串保存时间。</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> Date <span class="token function">parse</span><span class="token punctuation">(</span>String source<span class="token punctuation">)</span> <span class="token keyword">throws</span> ParseException<span class="token punctuation">{</span>…<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>作用：把字符串保存的时间转换为Date对象保存的时间</li></ul></li></ul><h4 id="时间日期的其他常用类"><a href="#时间日期的其他常用类" class="headerlink" title="时间日期的其他常用类"></a>时间日期的其他常用类</h4><ul><li><p>Calendar类（日历类）</p><ul><li>Java,util.Calendar类，通过Calendar可以表示年、月、日、是、分、秒的一个具体时间，而且还提供了日期相关的计算功能。</li></ul></li><li><p>Calendar类的实例化？？？</p><ul><li>Calendar类是一个抽象类，无法实例化，而是调用Calendar类的“Calendar getInstance()”静态方法来获得一个保存“当前时间”的</li></ul></li><li><p>Calendar对象。</p><ul><li>Calendaer 类中提供的字段，默认全部是int类型的“全局静态常量”。</li><li>calendar. YEAR获取年份</li><li>calendar . MONTH获取月份，o表示1月，1表示2月，…，11表示12月</li><li>calendar . DAY_OF_MONTH获取本月的第几天</li><li>calendar . DAY_OF_YEAR获取本年的第几天</li><li>calendar . HOUR_OF_DAY 小时，24小时制calendar. HOUR小时，12小时制</li><li>calendar.MINUTE 获取分钟</li><li>calendar.sECOND获取秒</li><li>calendar.MILLISECOND获取毫秒</li><li>calendar .DAY_OF_WEEK 获取星期几，1表示星期日，2表示星期一，…，7表示星期六</li></ul></li></ul><h4 id="时间日期的计算及转换"><a href="#时间日期的计算及转换" class="headerlink" title="时间日期的计算及转换"></a>时间日期的计算及转换</h4><ul><li><p>计算的方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//根据字段来“增加”或“减少”数据（在“年或月..”增加或者减少多少）。</span>Public <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> field<span class="token punctuation">,</span><span class="token keyword">int</span> amount<span class="token punctuation">)</span><span class="token punctuation">{</span>…<span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>转换方法：</p></li><li><p>明确：开放中，经常设计到Date对象保存时间和Calendar对象保存时间之间的相互转换。</p><pre class="line-numbers language-java"><code class="language-java">Public <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setTime</span><span class="token punctuation">(</span>Date date<span class="token punctuation">)</span><span class="token punctuation">{</span>…<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作用：把Date对象保存时间转换为calendar对象保存的时间</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><hr><h2 id="枚举（enum）"><a href="#枚举（enum）" class="headerlink" title="枚举（enum）"></a>枚举（enum）</h2><ul><li><p>枚举语法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token punctuation">[</span>修饰符<span class="token punctuation">]</span> <span class="token keyword">enum</span> 枚举名｛          枚举值<span class="token number">1</span>，枚举值<span class="token number">2</span>，枚举值<span class="token number">3</span>，…<span class="token punctuation">.</span><span class="token punctuation">.</span>      ｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>使用语法：枚举名.枚举值</p></li><li><p>注意：在switch选择结构中，我们使用“枚举值”的时候必须省略“枚举名”。</p></li></ul></li><li><p>枚举的底层？<br>在Java中枚举本质上就是一个被final修饰的类，并且继承了Java.long.Enum抽象类<br>类型的枚举中的所有枚举值，默认都是类型的全局静态常量。</p></li><li><p>对枚举进行反编译，发现枚举中还提供了values（）的全局静态方法，调用该方法就能返回枚举中的所有枚举值（用数组来存储）。</p></li></ul><hr><h2 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h2><h4 id="System的常用方法"><a href="#System的常用方法" class="headerlink" title="System的常用方法"></a>System的常用方法</h4><pre class="line-numbers language-java"><code class="language-java">    数组拷贝：<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">arraycopy</span><span class="token punctuation">(</span>object src<span class="token punctuation">,</span><span class="token keyword">int</span> srcPos<span class="token punctuation">,</span>object dest<span class="token punctuation">,</span><span class="token keyword">int</span> destPos<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span>        输出当前时间的毫秒数：<span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        终止当前程序，退出Java虚拟机：<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">(</span>当s等于<span class="token number">0</span>时退出<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h4><pre class="line-numbers language-java"><code class="language-java">    <span class="token function">charAt</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span>         返回指定索引处的 <span class="token keyword">char</span> 值    <span class="token function">concat</span><span class="token punctuation">(</span>String str<span class="token punctuation">)</span>        将指定字符串连接到此字符串的结尾    <span class="token function">contains</span><span class="token punctuation">(</span>CharSequence s<span class="token punctuation">)</span>        判断是否包含次字符串：    <span class="token function">copyValueOf</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">)</span>        返回数组中表示次字符的字符串    <span class="token function">copyValueOf</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span>        返回数组中指定下标的字符串    <span class="token function">endsWith</span><span class="token punctuation">(</span>String suffix<span class="token punctuation">)</span>        判断字符串是否以 指定字符串结尾    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Math类的常用方法"><a href="#Math类的常用方法" class="headerlink" title="Math类的常用方法"></a>Math类的常用方法</h4><pre class="line-numbers language-Java"><code class="language-Java">    Math.PI;        取圆周率：    Math.abs(基本数据类型 a);        取绝对值：    Math.cbrt(double a);        立方根：    Math.ceil(double a);        向上取整：    Math.floor(double a);        向下取整：     Math.max(int a,int b);        取两个数中的最大值：    Math.min(int a,int b);        取两个数中的最小值    Math.random();        [0，1)之间的随机数    Math.round(double a);        四舍五入：    Math.round(float a);        四舍五入：    （long）Math.fioor(数值+0.5)        注意：四舍五入的计算规则：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="UUID类"><a href="#UUID类" class="headerlink" title="UUID类"></a>UUID类</h4><ul><li>表示通用的唯一标识符（UUID）类。表示一个128位的值</li></ul><hr><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li>就是方法体中直接或间接的调用方法自身</li><li>使用递归：<br>1.必须创建方法。<br>2.必须有结束条件，（不然就会形成死递归，导致栈溢出）。<br>3.构造函数不能使用递归。</li><li>递归的思想：<br>将一个大的问题拆分成几个小问题，所有小问题解决了，大问题就解决了。</li><li>注意：循环能够解决的问题递归一定能够解决，反之则不一定。<br>如果循环嵌套层次过多，则可以使用递归，但是递归效率比循环效率更低。</li></ul><hr><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h4 id="集合Collection接口的继承结构图"><a href="#集合Collection接口的继承结构图" class="headerlink" title="集合Collection接口的继承结构图"></a>集合Collection接口的继承结构图</h4><p><img src="/images/Javase/list.png" alt="list.png"></p><h4 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h4><ul><li><p>实现的接口：</p><ul><li>collection接口，List接口，Deque接口（双端队列）</li></ul></li><li><p>链表之单向链表</p><ul><li><p>一个节点由数据位和地址位组成，数据位就是存储元素，地址位就是下一个节点的地址。</p><p><img src="/images/Javase/linkde1.png" alt="linked1"></p></li></ul></li><li><p>链表之双向链表</p><ul><li><p>一个节点由两个地址位和一个数据位，数据位存储元素，地址位一个地址位指向前一个节点的地址，一个指向下一个节点的地址。</p><p><img src="/images/Javase/linkde2.png" alt="linkde2"></p></li></ul></li><li><p>链表的特点：</p><ul><li>链表是由节点链接而成的</li><li>链表在内存中不是一段连续的内存空间，添加一个节点就在内存中新开一个空间存储节点</li><li>链表的增删效率高，查改的效率低。</li><li>非线程安全，安全性低，效率高。</li></ul></li></ul><h4 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h4><ul><li>向量类<br> 1. List的实现类<br> 2. 底层数据结构：动态数组<br> 3. 增删效率低，查改效率高<br> 4. 线程安全的，安全性高，效率低（几乎不用）</li></ul><h4 id="泛型（genericity）"><a href="#泛型（genericity）" class="headerlink" title="泛型（genericity）"></a>泛型（genericity）</h4><ul><li><p>泛型：又叫参数化类型，就是应用数据类型作为参数了。（泛型也有形参和实参）</p><ul><li>泛型的形参：仅仅表示这是一个泛型，没有具体的数据类型。（可以用 E T…）</li><li>泛型的实参：在创建对象时定义实参，约束集合的数据类型。</li></ul></li><li><p>注意：只有引用数据类型才能作为泛型。</p></li><li><p>泛型的作用：约束集合中的元素的数据类型，将元素类型的检测从运行时提升到编译时。</p></li><li><p>泛型的方法：（该方法没什么实际运用，了解语法即可）</p><ul><li>泛型方法的定义上一定有&lt;泛型的形参&gt;的方法才是泛型方法</li></ul></li><li><p>泛型方法的语法格式：</p><pre class="line-numbers language-Java"><code class="language-Java">修饰符 <泛型> 返回值类型  方法名（参数列表）｛｝<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​</p></li><li><p>泛型通配符：？（没什么鸟用，了解即可）</p><ul><li><?>这里的？就是泛型通配符。</li><li>泛型通配符？：表示所有泛型实参，就是可以表示泛型所有的具体类型</li><li><E>：这里的E表示的是泛型所有的形参。</li></ul></li><li><p>泛型通配符主要配合泛型的限定来使用</p></li><li><p>泛型的限定：</p><ul><li>上限：&lt;? extends T&gt; 表示？只能是T类及其子类</li><li>下限：&lt;? super T&gt;表示？只能是T类及其父类</li><li>注意：T 表示一个类（自定义类也行）</li></ul></li><li><p>泛型擦除：</p><ul><li>源代码中使用的泛型，在经过编译后，代码中就看不大泛型，就是泛型擦除。</li><li>（泛型擦除不是泛型丢失了，而是在编译后的字节码文件中使用单独的标识来存储泛型了）</li></ul></li></ul><h4 id="set接口"><a href="#set接口" class="headerlink" title="set接口"></a>set接口</h4><ul><li>是collection接口的子接口。</li><li>特点：元素不能重复，元素重复是否有序和实现类有关。</li></ul><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul><li>HsahSet是set接口的实现类。<ol><li>元素不能重复</li><li>元素无序，特别是它不保证该顺序恒久不变。</li><li>底层的数据结构是HashMap&lt;k,v&gt;,HashMap的底层结构是哈希表</li></ol></li><li>哈希表：也叫散列表，是根据关键码值（key）而直接进行访问的数据结构</li><li>哈希表是一个数组。</li><li>哈希表中的数据会产生哈希冲突（碰撞）<ul><li>哈希冲突：不同的key，hashCode值一样，哈希表中的索引就一样，这就是哈西冲突。</li></ul></li></ul><h4 id="LinedHashSet类"><a href="#LinedHashSet类" class="headerlink" title="LinedHashSet类"></a>LinedHashSet类</h4><ul><li>是HashSet的子类<ul><li>底层为 链表+哈希表</li></ul></li><li>特点：元素唯一且有序。</li></ul><h4 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h4><ul><li><p>TreeSet类是set接口的实现类</p></li><li><p>treeSet元素不重复</p></li><li><p>底层结构是TreeSetMap，treeMap的底层是红黑树</p></li><li><p>treeSet是根据元素进行排序</p></li><li><p>排序方法：</p><ol><li><p>使用自然排序接口（Comparable）实现排序：</p><ul><li><p>需要元素类实现该接口并且（添加泛型），才能实现排序功能</p></li><li><p>（设置排序规则：返回值&lt; 0 倒序，返回值 &#x3D; 0 元素相同，返回值 &gt; 0 正序）</p></li><li><p>缺点：扩展性差，不易修改</p></li></ul></li><li><p>使用比较器排序接口（Comparator）实现排序：</p><ul><li><p>不需要元素类实现该接口，需要构造一个类实现该接口，在构造的类中写入比较条件。</p></li><li><p>优点：和比较的类解耦合，满足ocp原则，可以做多种排序要求。</p></li></ul></li><li><p>注意：当利用无参构造创建对象时，调用的是自然排序。用有参构造new了一个比较器时，调用比较器排序。</p></li></ol></li></ul><h4 id="Map-lt-K-V-gt-接口"><a href="#Map-lt-K-V-gt-接口" class="headerlink" title="Map&lt;K,V&gt;接口"></a>Map&lt;K,V&gt;接口</h4><ul><li><p>HashMap实现类 , Hashtable实现类 , TreeMap实现类</p></li><li><p>map的结构继承图：</p></li></ul><p><img src="/images/Javase/map.png" alt="map"></p><ul><li><p>注意:根据以上的继承关系我们知道Map接口和Collection接口是没有关系的。</p><ul><li><p>但是在开发中我们还是把Map叫做Map集合;因为Map接口也是java集合框架的成员。</p></li><li><p>此接口是Java Collections Framework的成员。</p></li></ul></li></ul><h4 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h4><ul><li><p>是Map 接口的实现类</p></li><li><p>底层是哈希表</p></li><li><p>线程不安全的，安全性低，效率高</p></li><li><p>允许使用null键，null值。</p></li><li><p>哈希表中的数组初始容量是16，当Map中的元素达到容量的0.75倍就会扩容。0.75是map的负载因子。这个数在时间和空间上都是相对最合适的</p></li><li><p>扩容：新容量&#x3D;旧容量的2倍。</p></li><li><p>容量必须满足：&lt;&#x3D; 2的30次方。</p></li></ul><h4 id="LinkdHashMap类"><a href="#LinkdHashMap类" class="headerlink" title="LinkdHashMap类"></a>LinkdHashMap类</h4><ul><li>保证了存储元素时的有序性。</li></ul><h4 id="TreeMap类"><a href="#TreeMap类" class="headerlink" title="TreeMap类"></a>TreeMap类</h4><ol><li>是Map接口的实现类</li><li>底层是红黑树。</li><li>红黑树的数据结构是约束key的</li><li>可以对Map中的key排序</li><li>也有“自然排序”和“比较器排序”两种。</li></ol><h4 id="集合的部分方法扩展"><a href="#集合的部分方法扩展" class="headerlink" title="集合的部分方法扩展"></a>集合的部分方法扩展</h4><ul><li><p>集合的添加元素</p><ul><li><p>Collections中的静态方法addAll方法可以将指定的多个元素全部加到集合中</p><pre class="line-numbers language-Java"><code class="language-Java">Collections.addAll("集合名",添加的元素,添加的元素,.......);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>集合的forEach遍历方法</p><ul><li><p>在forEach中new一个Consumer接口，consumer接口也是函数表达式，里面的抽象方法是没有返回值，有一个参数。</p></li><li><p>这是lambda表达式：（lambda内容见下）</p><pre class="line-numbers language-java"><code class="language-java">集合名<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>简写方法</p><pre class="line-numbers language-java"><code class="language-java">集合名<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>集合的排序</p><ul><li><p>使用list.sort()方法中，传入Comparator接口类型的参数， Comparator接口是函数表达式，里面的抽象方法：返回值是int类型，有两个参数。</p><pre class="line-numbers language-Java"><code class="language-Java">list.sort((x,y) -> x-y);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>lambda表达式：Comparator.comparing（元素对象：：元素属性）（根据属性升序）（根据存储的元素，是基本数据类型，还是存储的对象，来确定是否调用方法的）</p><pre class="line-numbers language-Java"><code class="language-Java">list.sort(Comparator.comparing(a -> a.方法));list.sort(Comparator.comparing(对象::方法));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li></ul><hr><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h4 id="IO流的思维导图"><a href="#IO流的思维导图" class="headerlink" title="IO流的思维导图"></a>IO流的思维导图</h4><p><img src="/images/Javase/io.png" alt="io"></p><h4 id="io流的引入"><a href="#io流的引入" class="headerlink" title="io流的引入"></a>io流的引入</h4><ul><li>我们要将数据以文件的形式永久的保存到硬盘上，而要将数据写入文件中；或者从文件中读取数据，就需要使用io流<ul><li>IO流：<ul><li>io：输入输出</li><li>流：数据流，连续不断的数据</li></ul></li></ul></li></ul><h4 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h4><ul><li><p>根据流向的不同分为：</p><ul><li><p>输入流：读数据，将数据读取到程序中</p></li><li><p>输出流：写数据，将程序中的数据写到文件中</p></li></ul></li><li><p>根据操作数据的不同分为：</p><ul><li>字节流：按照字节为单位写数据</li><li>字符流：按照字符为单位写数据</li></ul></li><li><p>流根据不同功能分为：</p><ul><li>节点流（普通流）：真正读写数据的流。真正干活的。</li><li>处理流（包装流）：是对节点流的封装，也就是在节点流的基础上增加心得功能。但是读写数据还是使用节点流</li></ul></li><li><p>注意：</p><ul><li><p>字节流是万能流，什么文件都可以操作，</p></li><li><p>字符流不是万能的，只有记事本打开不会乱码的文件，才可以用字符流操作。</p></li></ul></li></ul><h4 id="四大基本抽象流"><a href="#四大基本抽象流" class="headerlink" title="四大基本抽象流"></a>四大基本抽象流</h4><ul><li><p>字节输入流(InputStream)：按照字节为单位读数据</p><ul><li>表示所有输出字节流的超类</li></ul></li><li><p>字节输出流(outputstream) :按照字节为单位写数据</p><ul><li>表示所有输入字节流的超类</li></ul></li><li><p>字符输入流(Reader):按照字符为单位读数据</p></li><li><p>字符输出流(writer):按照字符为单位写数据</p></li></ul><h4 id="文件输入输出流"><a href="#文件输入输出流" class="headerlink" title="文件输入输出流"></a>文件输入输出流</h4><ul><li><p>文件输入输出流是一种普通流，真正干活的。</p></li><li><p>文件输入流(FileInputStream)</p><ul><li>用于读取硬盘中文件的数据。（以字节为单位读取）</li></ul></li><li><p>文件便捷输入流(FileReader)</p><ul><li>用于读取硬盘中文件的数据。（以字符为单位读取）</li></ul></li><li><p>文件输出流(FileOutputStream)</p><ul><li>用于向硬盘中的文件写入数据。（以字节为单位写入）</li></ul></li><li><p>文件便捷输出流(FileWriter)</p><ul><li>用于向硬盘中的文件写入数据。（以字符为单位写入）</li></ul></li></ul><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><ul><li><p>缓冲流是一种处理流，在节点流的基础上增加了缓冲区。</p></li><li><p>字节缓冲输入流()BufferedInputStream)</p><ul><li>BufferedInputStream为另一个输入流添加一些功能，即华冲输入以及支持mark和reset方法的能力</li></ul></li><li><p>字节缓冲输出流(BufferedOutputStream)</p><ul><li>该类实现缓冲的输出流，通过设置这种输出流，应用程序就可以将各个字节写入底层输出流中，而不必针对每次字节写入调用底层系统。</li></ul></li></ul><h4 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h4><ul><li><p>计算机中的标准输入设备：键盘</p></li><li><p>标准输出设备：显示器</p></li><li><p>system类中的静态方法：</p><ul><li><p>标准错误输出流(static Printstream err)</p></li><li><p>标准输入流(static Inputstream in)</p><ul><li>作用于键盘</li></ul></li></ul><ul><li>标准输出流(static Printstream out)<ul><li>作用于显示器</li></ul></li></ul></li></ul><h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><ul><li>打印流(PrintStream)<br>打印流是一种处理流，为其他输出流添加了功能，使它们能够方便地打印各种数据值表示形式。</li></ul><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><ul><li><p>数据流只有字节流，没有字符流</p></li><li><p>序列化(DataOutputStream)</p><ul><li><p>将数据以乱码的方式写入，读需要使用反序列化(DataInputStream)来读取数据</p><pre class="line-numbers language-Java"><code class="language-Java">public class Test03 {    public static void main(String[] args) {        DataOutputStream dos = null;        try {            dos = new DataOutputStream(new FileOutputStream("E:\\a.txt"));            dos.writeInt(1);            dos.writeInt(2);            dos.writeChar('a');            dos.writeChar('b');            dos.flush();        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }finally {            if (dos != null) {                try {                    dos.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>反序列化(DataInputStream)</p><ul><li><p>读取序列化后的数据，读取时需要与写入时的数据类型顺序对应，否则会报错</p><pre class="line-numbers language-Java"><code class="language-Java">public class Test04 {    public static void main(String[] args) {        DataInputStream dis = null;        try {            dis = new DataInputStream(new FileInputStream("E:\\a.txt"));            System.out.println(dis.readInt());            System.out.println(dis.readInt());            System.out.println(dis.readChar());            System.out.println(dis.readChar());            System.out.println(dis.readByte());        } catch (Exception e) {            e.printStackTrace();        } finally {            if (dis != null) {                try {                    dis.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul><hr><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h4 id="线程（Thread）"><a href="#线程（Thread）" class="headerlink" title="线程（Thread）"></a>线程（Thread）</h4><ul><li><p>Java中使用Thread类表示线程。</p></li><li><p>注意：只有Thread类及其子类才能叫做线程</p></li><li><p>线程就是进程的执行路径。作用就是将程序指令交个CPU执行。一个进程至少需要一个线程。线程将指令交给CPU执行，是需要抢占CPU的时间片才能执行。CPU的一个核心执行一个线程。</p></li><li><p>多线程</p><ul><li>一个程序有多个执行路径，那么这个程序就是多线程的程序。</li></ul></li><li><p>创建线程</p><ul><li>方法一：<ol><li>创建Thread类的子类</li><li>子类重写run()方法</li><li>创建子类对象并成功</li></ol></li><li>方法二：<ol><li>创建Runnable接口的实现类</li><li>实现类重写run()方法</li><li>创建Thread时将实现类对象作为参数传递，启动Thread</li></ol></li></ul></li><li><p>守护线程</p><pre class="line-numbers language-Java"><code class="language-Java">void setDaemon(boolean on) ,当为true时用户线程变为守护线程。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>礼让线程</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  （没什么用）<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h4 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h4><ul><li>进程是运行中的程序，是计算机中分配资源的最小单位。</li><li>线程是程序的执行路径，线程是在进程中的。线程是程序执行的最小单位。</li></ul><h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><ul><li><p>线程的状态：新建，就绪，运行，阻塞，死亡</p><p><img src="/images/Javase/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE.png" alt="线程生命周期"></p></li></ul><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><ul><li>返回线程优先级：int getPriority();</li><li>设置线程优先级：void setPriority(int a)<ul><li>(最小优先级&#x3D;1 &lt;&#x3D; a &lt;&#x3D; 最大优先级&#x3D;10 ，默认优先级&#x3D;5)</li></ul></li><li>在cpu资源充足的情况下，设置优先级没有效果;在资源不足的情况下，优先级高的线程获取到资源的几率大一点。</li></ul><h4 id="中断线程"><a href="#中断线程" class="headerlink" title="中断线程"></a>中断线程</h4><ul><li><p>中断标记</p><pre class="line-numbers language-Java"><code class="language-Java">Void interrupt()    //给线程设置一个中断标记，不会中断线程。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>获取中断标记</p><pre class="line-numbers language-java"><code class="language-java">Static <span class="token keyword">boolean</span>  <span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//(获取后会清除标记)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="线程同步机制"><a href="#线程同步机制" class="headerlink" title="线程同步机制"></a>线程同步机制</h4><ul><li><p>同步代码块</p><pre class="line-numbers language-Java"><code class="language-Java">synchronized（对象锁）｛    //操作共享数据的代码｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>被synchronized修饰的代码具备有原子性。（要么不执行，要么执行结束）</p></li><li><p>对象锁：所有的多个线程是同一个锁。</p></li></ul></li><li><p>同步方法</p><pre class="line-numbers language-Java"><code class="language-Java">修饰符 synchronized 返回值 方法名（实参列表）｛        //共享修改的数据｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>方法结束释放锁</li><li>建议方法中的代码全是共享的的数据</li><li>方法中的对象锁是：this</li><li>注意：静态的同步方法的对象锁是：字节码对象 (类名.class)</li></ul></li><li><p>同步：（效率低）</p><ul><li>多个线程执行时，线程是阻塞的，需要得到前一个线程的结果，另一个线程才能执行</li></ul></li><li><p>异步：（效率高）</p><ul><li>多个线程执行时，非阻塞的，线程之间是并发执行，不需要等待前面的结果。</li></ul></li><li><p>Synchronized的可重入性：</p><ol><li>synchronized是一个不公平锁<ul><li>公平锁：按照进入阻塞队列的顺序获取锁。</li><li>不公平锁：不管先后顺序，谁抢到就是谁的。</li></ul></li><li>synchronized是一个可重入锁<ul><li>使用synchronized时，当一个线程得到一个&#x3D;对象锁后，只要该线程还没有释放这个对象锁，再次请求此对象锁时可以再次获得该对象的锁。</li><li>可重入锁也支持在父子类继承的环境中，当存在父子类继承关系时，子类是完全可以通过“可重入锁”调用父类的同步方法。</li></ul></li></ol></li></ul><h4 id="线程之间通信机制"><a href="#线程之间通信机制" class="headerlink" title="线程之间通信机制"></a>线程之间通信机制</h4><ul><li><p>线程通信使用的是 “等待唤醒” 机制</p><ul><li><p>等待：wait();(会自动释放锁)</p></li><li><p>唤醒：notify();或者notifyAll();（不会释放锁）</p></li></ul></li><li><p>wait();notify();或者notifyAll();这几个方法必须出现在同步代码块中或者在同步方法中（用对象锁来调用）</p></li><li><p>notify();随机唤醒一个线程，notifyAll();将所有等待线程全部唤醒</p></li><li><p>Lock锁</p><pre class="line-numbers language-Java"><code class="language-Java">    public interface Lock<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>Lock、实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的Condition对象。<ol><li>synchronized是关键字，我们不能修改。</li><li>Lock的接口，接口中就是方法，接口的方法可以重写，还可以接收参数，所以比 synchronized更加灵活。</li></ol></li></ul></li><li><p>condition接口</p><ul><li>Condition将object监视器方法(wait、notify和 notifyAll)分解成截然不同的对象，以便通过将这些对象与任意Lock 实现组合使用，为每个对象提供多个等待 set (wait-set)。其中,Lock 替代了synchronized方法和语句的使用，condition替代了object监视器方法的使用。</li></ul><ol><li>notify()&#x2F;notifyAll()只能在配合synchronized使用</li><li>condition接口的等待唤醒只能配合Lock使用</li><li>condition接口的await&#x2F;signal方法也必须编写在lock()和unlock()之间</li></ol></li></ul><h4 id="单列模式"><a href="#单列模式" class="headerlink" title="单列模式"></a>单列模式</h4><ul><li><p>饿汉式</p></li><li><p>在类中就直接new对象</p><ol><li>私有化构造方法</li><li>定义一个本类类型的静态变量，并私有化。</li><li>封装 一个get方法</li></ol><pre class="line-numbers language-Java"><code class="language-Java">public class DanLie01 {    //不管是否调用，直接先new出对象    private static DanLie01 danLie01 = new DanLie01();    private DanLie01() {    }    public static DanLie01 getDanLie01() {        return danLie01;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>懒汉式</p></li><li><p>用的时候才创建对象。</p><ol><li>私有化构造方法</li><li>定义一个本类类型的静态变量，并私有化。（添加volatile关键字，解决指令重排)</li><li>封装一个静态方法（在方法中new对象）</li><li>添加同步代码块使线程安全</li></ol><pre class="line-numbers language-Java"><code class="language-Java">public class DanLie02 {    //添加关键字volatile 解决指令重排问题    private volatile static DanLie02 danLie02;    private DanLie02() {    }    public static DanLie02 setDanLie02(){        //这个if判断是为了减少同步代码块的调用，增加效率        if (danLie02 == null){            //使用同步代码块，防止多线程安全问题            synchronized (DanLie02.class) {                //如果danLie02为空，表示还没有创建对象，所以就创建对象                //如果不为空，表示对象已创建，静态变量不能二次赋值，所以直接返回，                // 保证对象的单列。                if (danLie02 == null) {                    danLie02 = new DanLie02();                }            }        }        return danLie02;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="定时器（Timer）"><a href="#定时器（Timer）" class="headerlink" title="定时器（Timer）"></a>定时器（Timer）</h4><ol><li><p>创建定时器类对象</p></li><li><p>自定义一个任务子类继承TimerTask</p></li><li><p>在任务类中写任务。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyDeTimer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建定时器对象</span>        Timer timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建定时器子类对象</span>        MyTimer myTimer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyTimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//让myTimer类在两秒后执行。</span>        timer<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>myTimer<span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//让myTimer类在一秒后开始执行，每间隔两秒执行一次。</span>        timer<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>myTimer<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 自定义定时器子类 */</span><span class="token keyword">class</span> <span class="token class-name">MyTimer</span> <span class="token keyword">extends</span> <span class="token class-name">TimerTask</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"开始了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="线程池（Exector）"><a href="#线程池（Exector）" class="headerlink" title="线程池（Exector）"></a>线程池（Exector）</h4><ul><li><p>线程池的工具类（Executors）</p></li><li><p>使用线程池创建单一线程：Executors . [**newSingleThreadExecutor**](mk:@MSITStore:C:\Users\ASUS\Desktop\JDK 1.6 API.chm::&#x2F;java&#x2F;util&#x2F;concurrent&#x2F;Executors.html#newSingleThreadExecutor())()</p></li><li><p>使用线程池创建多个固定可重复的线程：Executors . [**newFixedThreadPool**](mk:@MSITStore:C:\Users\ASUS\Desktop\JDK 1.6 API.chm::&#x2F;java&#x2F;util&#x2F;concurrent&#x2F;Executors.html#newFixedThreadPool(int))(int nThreads) </p></li><li><p>缓冲线程池：[**newCachedThreadPool**](mk:@MSITStore:C:\Users\ASUS\Desktop\JDK 1.6 API.chm::&#x2F;java&#x2F;util&#x2F;concurrent&#x2F;Executors.html#newCachedThreadPool())() </p></li><li><p>时间调度线程池：newS……</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyExecutor</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//创建多个固定可重复的线程</span>        ExecutorService service <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            service<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@Override</span>                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"开始"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//创建单一线程</span>        ExecutorService service1 <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newSingleThreadExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        service1<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"单一线程执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//创建缓冲线程</span>        ExecutorService service2 <span class="token operator">=</span> Executors<span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        service2<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"缓冲线程"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h4><ul><li><p>该类提供了线程局部变量</p></li><li><p>每个线程都有自己的局部变量</p></li><li><p>ThreadLocal本身不存储数据，真正存储数据的是线程内部的ThreadLocalMap,ThreadLocal是Map的key值</p></li><li><p>执行过程图</p><p><img src="/images/Javase/ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.png" alt="提供局部变量执行图"></p></li><li><p>使用匿名内部类时</p><pre class="line-numbers language-Java"><code class="language-Java">//自定义一个dog类class Dog{}/** * ThreadLocal类 */public class MyThreadLocal01 {    /**     * 创建时使用匿名内部类，重写initialValue方法，直接返回自定义类对象     * 这样输出方法中就可不用在new对象，     */    private static ThreadLocal<Dog> local = new ThreadLocal<Dog>(){        @Override        protected Dog initialValue() {            return new Dog();        }    };    public static void main(String[] args) {        //创建三个线程        for (int i = 0; i < 3; i++) {            Thread thread = new Thread(new Runnable() {                @Override                public void run() {                    m1();                    try {                        Thread.sleep(500);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    m2();                }            });            thread.start();        }    }    //定义两个方法    public static void m1(){        System.out.println(Thread.currentThread().getName() + "-->" + local.get() );    }    public static void m2(){        System.out.println(Thread.currentThread().getName() + "-->" + local.get() );    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建对象用set方法改变变量为局部变量</p><pre class="line-numbers language-Java"><code class="language-Java">//自定义一个类class Cat{}/** * ThreadLocal类 */public class MyThreadLocal02 {    //这个对象多线程无法起作用    //private static Cat cat = new Cat();    //创建一个ThreadLocal对象(泛型为cat)设置为静态，私有化    private static ThreadLocal<Cat> local = new ThreadLocal();    public static void main(String[] args) {        //创建三个线程        for (int i = 0; i < 3; i++) {            Thread t1 = new Thread(new Runnable() {                @Override                public void run() {                    //调用方法一                    m1();                    try {                        Thread.sleep(200);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    m2();                }            });            t1.start();        }    }    /**     * 如果要保证两个方法输出的cat值是同一个，则不能new两个cat对象     * 如果值new一个静态的cat的对象，那么多线程输出就会被最后执行的一个线程覆盖，不能起作用     * 所以只能将cat对象用（ThreadLocal类）绑定cat对象将其设置成局部对象     */    //定义两个静态输出Cat的方法    public static void m1(){        //创建cat对象        Cat cat = new Cat();        //使用ThreadLocal的set方法绑定Cat对象        local.set(cat);        //输出Cat        System.out.println(Thread.currentThread().getName() + "->" + local.get());    }    public static void m2(){        //输出Cat        System.out.println(Thread.currentThread().getName() + "====>" + local.get());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="CountDownLatch倒计时锁"><a href="#CountDownLatch倒计时锁" class="headerlink" title="CountDownLatch倒计时锁"></a>CountDownLatch倒计时锁</h4><ul><li><p>new一个对象出来，设置倒计时时长</p></li><li><p>调用conutDown方法一次可以减一。</p><pre class="line-numbers language-Java"><code class="language-Java">public class MyCountDownLatch {    public static void main(String[] args) {        //创建一个倒计时锁对象        CountDownLatch latch = new CountDownLatch(1);        //创建五个线程        for (int i = 0; i < 5; i++) {            Thread t1 = new Thread(new Runnable() {                @Override                public void run() {                    //倒计时数字减一                    //latch.countDown();                    try {                        latch.await();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    System.out.println(Thread.currentThread().getName() + "已到位====");                }            });            //启动线程            t1.start();        }        System.out.println("主程序启动");        try {            Thread.sleep(2000);        } catch (InterruptedException e) {            e.printStackTrace();        }        latch.countDown();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier 循环栅栏"></a>CyclicBarrier 循环栅栏</h4><ul><li><p>创建时设置线程数量</p><pre class="line-numbers language-Java"><code class="language-Java">public class MyCyclicBarrier {    public static void main(String[] args) {        /**         * 创建循环栅栏对象(设置线程个数)         * 这个线程数量必须小于等于创建的线程数量，否则程序将陷入死等待         */        CyclicBarrier barrier = new CyclicBarrier(5);        //使用线程池创建五个线程        ExecutorService service = Executors.newFixedThreadPool(5);        for (int i = 0; i < 5; i++) {            service.submit(new Runnable() {                @Override                public void run() {                    try {                        System.out.println(Thread.currentThread().getName() + "准备就绪");                        Thread.sleep(1000);                        //当循环栅栏中的线程全部到达时，才会唤醒等待状态                        barrier.await();                    } catch (InterruptedException e) {                        e.printStackTrace();                    } catch (BrokenBarrierException e) {                        e.printStackTrace();                    }                    System.out.println(Thread.currentThread().getName() + "开始执行。。。");                }            });        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore:信号量"></a>Semaphore:信号量</h4><ul><li><p>用来限制同时访问资源的线程数量</p><pre class="line-numbers language-Java"><code class="language-Java">public class MySemaphore {    public static void main(String[] args) {        //创建信号量对象，设置同时访问的数量为4        Semaphore semaphore = new Semaphore(4);        //创建是个线程，这里采用线程池的方式        ExecutorService service = Executors.newFixedThreadPool(10);        for (int i = 0; i < 10; i++) {            service.submit(new Runnable() {                @Override                public void run() {                    //使用信号量限定一次最多的执行次数                    try {                        semaphore.acquire();                        System.out.println(Thread.currentThread().getName() + "开始执行。。。");                    } catch (InterruptedException e) {                        e.printStackTrace();                    }finally {                        //执行结束后，让出信号位置                        semaphore.release();                    }                    System.out.println(Thread.currentThread().getName() + "停止执行！！");                }            });        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><hr><h2 id="反射机制与注解"><a href="#反射机制与注解" class="headerlink" title="反射机制与注解"></a>反射机制与注解</h2><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ul><li><p>根据字节码文件动态获取类信息</p></li><li><p>反射机制就是将类的各个组成部分（属性，方法 ，构造器 ）封装为其他对象。</p><p>获取类信息</p></li></ul><h4 id="获取class对象的四种方法"><a href="#获取class对象的四种方法" class="headerlink" title="获取class对象的四种方法"></a>获取class对象的四种方法</h4><ol><li>Calss.forName</li><li>类名.class (主要用于传参)</li><li>对象.getClass</li><li>包装类.TYPE</li></ol><h4 id="获取成员变量的字节码对象"><a href="#获取成员变量的字节码对象" class="headerlink" title="获取成员变量的字节码对象"></a>获取成员变量的字节码对象</h4><ul><li><p>类的指定公开成员变量 —-getField ()  加一个 s 表示获取所有的</p></li><li><p>获取成员变量的变量名—-getName()</p></li><li><p>获取成员变量的返回值—–getTypt()</p></li><li><p>获取成员变量的修饰符—–getModifiers()</p><pre class="line-numbers language-Java"><code class="language-Java"> Field nameField = aClass.getField("name"); System.out.println(nameField); System.out.println(nameField.getName());//获取字段名 System.out.println(nameField.getType());//获取字段返回值 System.out.println(nameField.getModifiers());//获取字段的修饰符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="使用构造方法创建对象"><a href="#使用构造方法创建对象" class="headerlink" title="使用构造方法创建对象"></a>使用构造方法创建对象</h4><ul><li><p>类的字节码文件对象.newInstance()</p><pre class="line-numbers language-Java"><code class="language-Java">//直接用字节码对象创建对象（默认调用无参构造方法）Object obj = aClass.newInstance();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>构造方法对象.newInstance()</p><pre class="line-numbers language-Java"><code class="language-Java">//通过无参构造对像创建对象Object obj = constructor.newInstance();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h4 id="获取构造方法的字节码对象"><a href="#获取构造方法的字节码对象" class="headerlink" title="获取构造方法的字节码对象"></a>获取构造方法的字节码对象</h4><ul><li><p>公开的构造方法：getConstructor()</p></li><li><p>非公开的构造方法：getDeclaredConstructor()</p><pre class="line-numbers language-Java"><code class="language-Java">//获取无参构造对象Constructor<?> constructor = aClass.getConstructor();//获取有参构造Constructor<?> constructor1 = aClass.getConstructor();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注意：使用所有非公开的对象时，需要提前</p></li><li><p>使用：setAccessible(true)方法，来暴力避开 非公开的修饰符</p></li></ul><h4 id="获取方法的字节码对象"><a href="#获取方法的字节码对象" class="headerlink" title="获取方法的字节码对象"></a>获取方法的字节码对象</h4><ul><li><p>获取公开的方法：getmethod()</p><pre class="line-numbers language-Java"><code class="language-Java">Method method = aClass1.getMethod("方法名");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>获取非公开的方法：getDeclaredMethod()</p></li></ul><h4 id="获取内部类的字节码对象"><a href="#获取内部类的字节码对象" class="headerlink" title="获取内部类的字节码对象"></a>获取内部类的字节码对象</h4><ul><li><p>获取所有的内部类：getClasses</p><pre class="line-numbers language-Java"><code class="language-Java">//通过外部类获取非静态内部类Class<?>[] classes = aClass.getClasses();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>判断是否是静态内部类</p><pre class="line-numbers language-Java"><code class="language-Java">Modifier.isStatic(modifiers);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>注意：获取所有的内部类后，如果要判断是否是静态内部类 则</p></li><li><p>需要先获取修饰符对象，然后使用 ：Modifier.isStatic静态方法判断</p></li></ul><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li><p>扩展类加载器</p></li><li><p>启动类加载器</p></li><li><p>应用类加载器</p></li><li><p>Classpath:类路径，就是字节码文件所在的路径</p><ul><li>（src下面就是第一级包）第一级包就是类路径的开始。</li></ul></li><li><p>那些内容可以加载进类路径：</p><ol><li>sre中的资源</li><li>被标记成resources root目录下的资源</li><li>第三方jar包</li></ol></li><li><p>打包jar包的方法</p><ol><li>选择左上角File –&gt; Project Student…（资源包）</li><li>选择 Artifacts(构建) –&gt;点击+号 —&gt;点击JAR –&gt;Form modules……</li><li>第一行选择你要打包的模块名 —&gt;第二行 选择你模块中要运行的主类名。</li><li>第一个选项是将其抽取为一个目标的jar，</li><li>再下面是默认的文件保存位置</li><li>弹出提示框，可以修改文件的输出目录。</li><li>选择上方的Build,选择Build Artifacts，选择模块名，选择Build.</li><li>程序中的配置文件要放到resources 目录（resources自己创建的文件夹，注意要修改类型）</li></ol></li></ul><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><ul><li><p>注释：解释说明代码的—-程序员看的</p></li><li><p>注解：解释说明代码的——程序看的</p></li><li><p>注解语法格式：</p><pre class="line-numbers language-Java"><code class="language-Java">元注解Pbulic @interface 注解名｛        属性；｝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>注解的属性</p><ul><li>注解的本质是接口，注解是jdk1.5出现的，所以注解使用的是1.5时候的接口，1.5的接口只有常量值和抽象方法。也就是注解中的属性要么是常量值；要么是抽象方法来表示</li><li>结论：注解中的属性是抽象方法</li><li>方法名就是属性名</li><li>方法的返回值类型就是属性的数据类型。</li></ul></li><li><p>注解中的属性的数据类型只能是：</p><ol><li>.基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>Class</li><li>以上数据类型的数组</li></ol></li><li><p>属性的使用细节：</p><ol><li>属性可以有默认值；如果属性有默认值，那么使用注解的时候，该属性可以不用显示赋值</li><li>如果属性的名称叫做value，那么使用注解的时候，只单独使用value属性时，属性名可以省略不写，但是如果使用多个属性的时候value不能省略</li><li>注解中数组使用｛｝表示；使用注解的时候，如果｛｝中只有一个值时，｛｝可以省略不写</li><li>多个属性之间使用逗号分隔。</li></ol></li><li><p>内置的元注解：</p><ol><li>@target : 标记定义的注解可以贴在那些地方</li><li>@Retention : 表示注解可以保留到什么阶段。</li></ol></li><li><p>注解有三个功能：</p><ol><li>我们只能用一个就是用来“简化代码”。</li></ol></li></ul><h2 id="lambda表达式和Stream流"><a href="#lambda表达式和Stream流" class="headerlink" title="lambda表达式和Stream流"></a>lambda表达式和Stream流</h2><h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h4><ul><li><p>是用来简化函数式接口的匿名内部类代码的。</p></li><li><p>函数式接口：只有一个抽象方法的接口，使用@FunctionalInterface进行注解</p></li><li><p>语法：</p><pre class="line-numbers language-Java"><code class="language-Java">（参数列表）-> {        函数体；        [return  [返回值];]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>方法引用</p><ul><li>当lambda表达式的函数体中只有一条语句且这条语句是调用其他方法完成功能，那么此时就可以使用方法引用简化lambda表达式</li><li>注意：函数体中的方法需要使用到参数列表中的参数</li></ul></li><li><p>简化语法：</p><ol><li>对象：：实例方法</li><li>类名：：静态方法</li><li>类名：：实例方法</li></ol><ul><li>注意：当lambda表达式的函数体中只有一条语句且这条语句是调用其他方法完成功能，同时参数列表的第一个参数作为方法的调用者，其余参数作为方法的参数传递，此时可以使用 第三种方法 3.类名：：实例方法</li></ul></li><li><p>构造方法引用</p><ul><li>当lambda表达式的函数体中只有一条语句，返回值为需要创建的对象类型，没有参数为无参构造，有参数为有参构造。</li></ul></li><li><p>简化语法</p><ol><li>类名：：new</li></ol></li></ul><h4 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h4><ul><li><p>Stream中的方法分为中间操作和终端操作</p><ul><li><p>中间操作：方法的返回值是Stream，该方法就是中间操作</p></li><li><p>终端操作：方法的返回值不是stream，该方法就是终端操作</p></li></ul></li><li><p>注意：终端操作不能写多个，想写多个只能重写多个流</p></li><li><p>顺序流：Stream（单线程的流）</p></li><li><p>并行流：parallelStream（多线程的流）</p></li><li><p>创建流的方法：</p><pre class="line-numbers language-Java"><code class="language-Java">集合名.stream()//创建单线程流集合名.parallelStream()//创建多线程流<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>Stream的静态方法：of()   iterate()    generate()</p><ul><li><p>of():直接添加元素在流中，返回一个流</p></li><li><p>iterate():无限迭代数据（limit可以设置迭代个数）（skip设置跳过几个数据）</p></li><li><p>generate()：无限的生成数据。</p></li></ul></li><li><p>stream流的常用方法：</p><ul><li><p>遍历：forEach ： 遍历流中的元素</p></li><li><p>过滤：filter：根据条件筛选出想要的元素</p></li><li><p>查找：</p><ol><li><p>findFirst()：找出集合中的第一个元素</p></li><li><p>findAny()：配合并行流使用，找出任意一个线程的头元素。</p></li></ol></li><li><p>匹配：</p><ol><li>anyMatch():只要有任意一个元素匹配条件则返回true</li><li>allMatch():需要所有元素匹配条件则返回true</li></ol></li></ul></li><li><p>收集元素：collect()</p></li><li><p>收集器工具类：Collectors()</p></li><li><p>聚合：（max&#x2F;min&#x2F;count）</p><ul><li>Max:默认获取字符最长的元素</li><li>Min:默认获取字符最短的的元素</li><li>注意：如果需要获取字节的长度，需要使用getBytes()方法转换</li><li>Count:获取元素的个数</li></ul></li><li><p>映射：（map&#x2F;flatMap）</p><ul><li>map的特点：流进一个，流出一个（一对一的关系）</li><li>flatMap的特点：进去一个，可以出来多个 （一对多的关系）</li></ul></li><li><p>归约：（reduce）</p><ul><li><p>归约：也称 缩减，顾名思义，是把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作。</p></li><li><p>归约中有三个重载方法（下列例子中演示的为集合中元素求和）</p><ol><li><p>只有一个参数的</p><pre class="line-numbers language-Java"><code class="language-Java">/*Optional<Integer> reduce1 = stream.reduce((a, b) -> {    System.out.println("a=" + a + " ,b=" + b);    //流中执行的规则      a=2 ,b=4      a=6 ,b=6      a=12 ,b=7      a=19 ,b=8      a=27 ,b=9      36    return a + b;});*/Optional<Integer> reduce = stream.reduce((a, b) -> a + b);Optional<Integer> reduce = stream.reduce((a, b) -> Integer.sum(a,b));Optional<Integer> reduce = stream.reduce(Integer::sum);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>有两个参数的</p><pre class="line-numbers language-Java"><code class="language-Java">//identity参数：恒等的，在流中给第一个变量赋上一个初始值Integer reduce = stream.reduce(0, (a, b) -> a + b);Integer reduce = stream.reduce(10, (a, b) -> a + b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>有三个参数的</p><ul><li>注意：第三个参数，只有在并行流中才能执行，在顺序流中不会执行</li></ul><pre class="line-numbers language-Java"><code class="language-Java">//  第一个参数表示赋一个初始值//  第二个参数accumulator表示 线程内部累加//  第三个参数combiner表示 线程之间累加//  线程每次都会获取identity进行操作Stream<Integer> stream = list.parallelStream();Integer reduce = stream.reduce(10, (a, b) -> a + b, (x, y) -> x + y);Integer reduce = stream.reduce(10, Integer::sum, (x, y) -> x + y);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li></ul></li><li><p>归集：（toList&#x2F;toSet&#x2F;toMap）</p><ul><li>toList：将收集器收集到的元素打包成List集合返回</li><li>toSet：将收集器收集到的元素打包成 set集合返回</li><li>toMap：将收集器收集到的元素打包成map集合返回</li></ul></li><li><p>统计：(count&#x2F;averaging)</p><ul><li><p>注：以下全是收集器工具类中的方法</p></li><li><p>计数：counting()</p></li><li><p>平均值：averagingInt、averagingLong、averagingDouble</p></li><li><p>最值：maxBy、minBy</p></li><li><p>求和：summingInt、summingLong、summingDouble</p></li><li><p>统计以上所有：summarizingInt、summarizingLong、summarizingDouble</p></li></ul></li><li><p>分组：（partitioningBy&#x2F;groupungBy）</p><ul><li><p>partitioningBy: 将元素通过某个条件分割为两个区</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//根据工资将元素分为是否高于7000的两个区</span>Map<span class="token operator">&lt;</span>Boolean<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Student<span class="token operator">>></span> collect <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">partitioningBy</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">getWages</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">7000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>groupungBy： 根据条件将元素分割为多个区，可使用多个条件分割多次</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//根据所在地将元素分隔成多个区</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Student<span class="token operator">>></span> collect <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">getAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li><p>拼接：joining：收集器里面的方法，元素拼接在一起</p><pre class="line-numbers language-java"><code class="language-java">将所有的元素的名字拼接起来String collect <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>自然排序：(sorted()) </p><ul><li><p>元素类需要实现comparable接口，重写方法</p></li><li><p>注意：实现接口时需要使用泛型。</p><pre class="line-numbers language-Java"><code class="language-Java">Stream<Student> sorted = stream.sorted();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li><li><p>比较器排序：comparator</p><ul><li><p>排序规则反转方法：reversed()</p></li><li><p>二次排序方法：thenComparing（）</p></li><li><p>注意：使用二次排序前 必须使前一个条件使用lambda方式书写成：对象：：方法</p><pre class="line-numbers language-Java"><code class="language-Java">//自定义排序规则Stream<Student> sorted1 = stream.sorted((a,b) -> b.getId() - a.getId());Stream<Student> sorted1 = stream.sorted(Comparator.comparingInt(s -> s.getId()));Stream<Student> sorted1 = stream.sorted(Comparator.comparingInt(Student::getId).reversed());//二次排序的方法Stream<Student> sorted = stream.sorted(Comparator.comparingDouble(Student::getWages).reversed().thenComparingInt(Student::getId));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>Stream流的静态方法：</p><ul><li><p>提取：Stream.iterate() ：定义初始值，取出什么值 </p><ul><li><p>提取多少个limit（）</p></li><li><p>是否需要跳过多少个  skip() </p><pre class="line-numbers language-Java"><code class="language-Java">//提取出3,4,5,6,7System.out.println(Stream.iterate(1, a -> a + 1).skip(2).limit(5).collect(Collectors.toList()));//提取出3,4,5System.out.println(Stream.iterate(1, a -> a + 1).limit(5).skip(2).collect(Collectors.toList()));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>组合：Stream.concat() : 将两个流组合成一个流。</p><ul><li><p>去除重复值：distinct()</p><pre class="line-numbers language-Java"><code class="language-Java">//创建两个流Stream<String> stream = list.stream();Stream<String> stream1 = list1.stream();//合并两个流,然后去除重复值，在返回成一个数组List<String> collect = Stream.concat(stream,stream1).distinct().collect(Collectors.toList());<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> javaSE学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyMarkdown</title>
      <link href="/2020/02/16/Markdown/"/>
      <url>/2020/02/16/Markdown/</url>
      
        <content type="html"><![CDATA[<ol><li><p>字体加粗：** 文本 **，不要加空格，下同。</p></li><li><p>斜体：* 文本 * </p></li><li><p>斜体加粗： ** * 文本 * **</p></li><li><p>删除线： ~~ 文本 ~~</p></li><li><p>引用 ： &gt; + 空格</p></li><li><p>分割线：— + 换行符  或者 *** + 换行符</p></li><li><p>添加图片：<img src="D:/course11/note/图片路径" alt="图片名"></p></li><li><p>添加超链接： [文本] (网址)</p></li><li><p>有序列表：1. + 空格</p></li><li><p>无序列表：- + 空格</p></li><li><p>博客令牌密码：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</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Markdown编辑器 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
